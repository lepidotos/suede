/*
 * This file was generated by orbit-idl - DO NOT EDIT!
 */

#include <string.h>
#include "control-center.h"

void
_ORBIT_skel_GNOME_capplet_try(POA_GNOME_capplet * _ORBIT_servant,
			      GIOPRecvBuffer * _ORBIT_recv_buffer,
			      CORBA_Environment * ev,
			      void (*_impl_try) (PortableServer_Servant
						 _servant,
						 const CORBA_long id,
						 CORBA_Environment * ev))
{
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_try(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_revert(POA_GNOME_capplet * _ORBIT_servant,
				 GIOPRecvBuffer * _ORBIT_recv_buffer,
				 CORBA_Environment * ev,
				 CORBA_boolean(*_impl_revert)
				 (PortableServer_Servant _servant,
				  const CORBA_long id,
				  CORBA_Environment * ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _ORBIT_retval = _impl_revert(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_ok(POA_GNOME_capplet * _ORBIT_servant,
			     GIOPRecvBuffer * _ORBIT_recv_buffer,
			     CORBA_Environment * ev,
			     CORBA_boolean(*_impl_ok) (PortableServer_Servant
						       _servant,
						       const CORBA_long id,
						       CORBA_Environment *
						       ev))
{
   CORBA_boolean _ORBIT_retval;
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _ORBIT_retval = _impl_ok(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_cancel(POA_GNOME_capplet * _ORBIT_servant,
				 GIOPRecvBuffer * _ORBIT_recv_buffer,
				 CORBA_Environment * ev,
				 void (*_impl_cancel) (PortableServer_Servant
						       _servant,
						       const CORBA_long id,
						       CORBA_Environment *
						       ev))
{
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_cancel(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_help(POA_GNOME_capplet * _ORBIT_servant,
			       GIOPRecvBuffer * _ORBIT_recv_buffer,
			       CORBA_Environment * ev,
			       void (*_impl_help) (PortableServer_Servant
						   _servant,
						   const CORBA_long id,
						   CORBA_Environment * ev))
{
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_help(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_new_multi_capplet(POA_GNOME_capplet *
					    _ORBIT_servant,
					    GIOPRecvBuffer *
					    _ORBIT_recv_buffer,
					    CORBA_Environment * ev,
					    void (*_impl_new_multi_capplet)
					    (PortableServer_Servant _servant,
					     const CORBA_long id,
					     const CORBA_long newid,
					     const CORBA_unsigned_long newxid,
					     const CORBA_long newcapid,
					     CORBA_Environment * ev))
{
   CORBA_long id;
   CORBA_long newid;
   CORBA_unsigned_long newxid;
   CORBA_long newcapid;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 (*((guint32 *) & (newid))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 (*((guint32 *) & (newxid))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 (*((guint32 *) & (newcapid))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 newid = *((CORBA_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 newxid = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 newcapid = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_new_multi_capplet(_ORBIT_servant, id, newid, newxid, newcapid, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_page_hidden(POA_GNOME_capplet * _ORBIT_servant,
				      GIOPRecvBuffer * _ORBIT_recv_buffer,
				      CORBA_Environment * ev,
				      void (*_impl_page_hidden)
				      (PortableServer_Servant _servant,
				       const CORBA_long id,
				       CORBA_Environment * ev))
{
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_page_hidden(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_capplet_page_shown(POA_GNOME_capplet * _ORBIT_servant,
				     GIOPRecvBuffer * _ORBIT_recv_buffer,
				     CORBA_Environment * ev,
				     void (*_impl_page_shown)
				     (PortableServer_Servant _servant,
				      const CORBA_long id,
				      CORBA_Environment * ev))
{
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_page_shown(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_control_center_register_capplet(POA_GNOME_control_center *
						  _ORBIT_servant,
						  GIOPRecvBuffer *
						  _ORBIT_recv_buffer,
						  CORBA_Environment * ev,
						  CORBA_long
						  (*_impl_register_capplet)
						  (PortableServer_Servant
						   _servant,
						   const CORBA_long id,
						   const GNOME_capplet cap,
						   CORBA_Environment * ev))
{
   CORBA_long _ORBIT_retval;
   CORBA_long id;
   GNOME_capplet cap;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 cap =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 cap =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      }
   }
   _ORBIT_retval = _impl_register_capplet(_ORBIT_servant, id, cap, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
					     (_ORBIT_send_buffer), 4);
	    {
	       guchar *_ORBIT_t;

	       _ORBIT_t = alloca(sizeof(_ORBIT_retval));
	       memcpy(_ORBIT_t, &(_ORBIT_retval), sizeof(_ORBIT_retval));
	       giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					      (_ORBIT_send_buffer),
					      (_ORBIT_t),
					      sizeof(_ORBIT_retval));
	    }
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      CORBA_Object_release((CORBA_Object) cap, ev);
   }
}
void
_ORBIT_skel_GNOME_control_center_state_changed(POA_GNOME_control_center *
					       _ORBIT_servant,
					       GIOPRecvBuffer *
					       _ORBIT_recv_buffer,
					       CORBA_Environment * ev,
					       void (*_impl_state_changed)
					       (PortableServer_Servant
						_servant, const CORBA_long id,
						const CORBA_boolean undoable,
						CORBA_Environment * ev))
{
   CORBA_long id;
   CORBA_boolean undoable;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 undoable = *((CORBA_boolean *) _ORBIT_curptr);
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 undoable = *((CORBA_boolean *) _ORBIT_curptr);
      }
   }
   _impl_state_changed(_ORBIT_servant, id, undoable, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_control_center_register_capplet_new(POA_GNOME_control_center
						      * _ORBIT_servant,
						      GIOPRecvBuffer *
						      _ORBIT_recv_buffer,
						      CORBA_Environment * ev,
						      void
						      (*_impl_register_capplet_new)
						      (PortableServer_Servant
						       _servant,
						       const GNOME_capplet
						       cap,
						       const CORBA_char *
						       name,
						       const CORBA_long capid,
						       CORBA_unsigned_long *
						       xid,
						       CORBA_long * newid,
						       CORBA_Environment *
						       ev))
{
   GNOME_capplet cap;
   CORBA_char *name;
   CORBA_long capid;
   CORBA_unsigned_long xid;
   CORBA_long newid;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;
      register CORBA_unsigned_long _ORBIT_tmpvar_2;
      CORBA_unsigned_long _ORBIT_tmpvar_3;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 cap =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (_ORBIT_tmpvar_3))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
	 _ORBIT_curptr += 4;
	 name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(name[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (capid))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur = _ORBIT_curptr;
	 cap =
	    ORBit_demarshal_object(_ORBIT_recv_buffer,
				   (((ORBit_ObjectKey *) _ORBIT_servant->
				     _private)->object->orb));
	 _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 _ORBIT_tmpvar_3 = *((CORBA_unsigned_long *) _ORBIT_curptr);
	 _ORBIT_curptr += 4;
	 name = (void *) _ORBIT_curptr;
	 _ORBIT_curptr += sizeof(name[_ORBIT_tmpvar_2]) * _ORBIT_tmpvar_3;
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 capid = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_register_capplet_new(_ORBIT_servant, cap, name, capid, &(xid),
			      &(newid), ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	    giop_message_buffer_do_alignment(GIOP_MESSAGE_BUFFER
					     (_ORBIT_send_buffer), 4);
	    giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					   (_ORBIT_send_buffer), &(xid),
					   sizeof(xid));
	    giop_message_buffer_append_mem(GIOP_MESSAGE_BUFFER
					   (_ORBIT_send_buffer), &(newid),
					   sizeof(newid));
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
      CORBA_Object_release((CORBA_Object) cap, ev);
   }
}
void
_ORBIT_skel_GNOME_control_center_show_control_center(POA_GNOME_control_center
						     * _ORBIT_servant,
						     GIOPRecvBuffer *
						     _ORBIT_recv_buffer,
						     CORBA_Environment * ev,
						     void
						     (*_impl_show_control_center)
						     (PortableServer_Servant
						      _servant,
						      CORBA_Environment * ev))
{
   _impl_show_control_center(_ORBIT_servant, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
void
_ORBIT_skel_GNOME_control_center_changes_are_immediate
   (POA_GNOME_control_center * _ORBIT_servant,
    GIOPRecvBuffer * _ORBIT_recv_buffer, CORBA_Environment * ev,
    void (*_impl_changes_are_immediate) (PortableServer_Servant _servant,
					 const CORBA_long id,
					 CORBA_Environment * ev))
{
   CORBA_long id;

   {				/* demarshalling */
      guchar *_ORBIT_curptr;

      _ORBIT_curptr = GIOP_RECV_BUFFER(_ORBIT_recv_buffer)->cur;
      if (giop_msg_conversion_needed(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer))) {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 (*((guint32 *) & (id))) =
	    GUINT32_SWAP_LE_BE(*((guint32 *) _ORBIT_curptr));
      } else {
	 _ORBIT_curptr = ALIGN_ADDRESS(_ORBIT_curptr, 4);
	 id = *((CORBA_long *) _ORBIT_curptr);
      }
   }
   _impl_changes_are_immediate(_ORBIT_servant, id, ev);
   {				/* marshalling */
      register GIOPSendBuffer *_ORBIT_send_buffer;

      _ORBIT_send_buffer =
	 giop_send_reply_buffer_use(GIOP_MESSAGE_BUFFER(_ORBIT_recv_buffer)->
				    connection, NULL,
				    _ORBIT_recv_buffer->message.u.request.
				    request_id, ev->_major);
      if (_ORBIT_send_buffer) {
	 if (ev->_major == CORBA_NO_EXCEPTION) {
	 } else
	    ORBit_send_system_exception(_ORBIT_send_buffer, ev);
	 giop_send_buffer_write(_ORBIT_send_buffer);
	 giop_send_buffer_unuse(_ORBIT_send_buffer);
      }
   }
}
static ORBitSkeleton
get_skel_GNOME_capplet(POA_GNOME_capplet * servant,
		       GIOPRecvBuffer * _ORBIT_recv_buffer, gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'c':
	if (strcmp((opname + 1), "ancel"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_capplet_epv->cancel;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_capplet_cancel;
	break;
     case 'h':
	if (strcmp((opname + 1), "elp"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_capplet_epv->help;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_capplet_help;
	break;
     case 'n':
	if (strcmp((opname + 1), "ew_multi_capplet"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_capplet_epv->new_multi_capplet;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_capplet_new_multi_capplet;
	break;
     case 'o':
	if (strcmp((opname + 1), "k"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_capplet_epv->ok;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_capplet_ok;
	break;
     case 'p':
	switch (opname[1]) {
	  case 'a':
	     switch (opname[2]) {
	       case 'g':
		  switch (opname[3]) {
		    case 'e':
		       switch (opname[4]) {
			 case '_':
			    switch (opname[5]) {
			      case 'h':
				 if (strcmp((opname + 6), "idden"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_capplet_epv->page_hidden;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_capplet_page_hidden;
				 break;
			      case 's':
				 if (strcmp((opname + 6), "hown"))
				    break;
				 *impl =
				    (gpointer) servant->vepv->
				    GNOME_capplet_epv->page_shown;
				 return (ORBitSkeleton)
				    _ORBIT_skel_GNOME_capplet_page_shown;
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 'r':
	if (strcmp((opname + 1), "evert"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_capplet_epv->revert;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_capplet_revert;
	break;
     case 't':
	if (strcmp((opname + 1), "ry"))
	   break;
	*impl = (gpointer) servant->vepv->GNOME_capplet_epv->try;
	return (ORBitSkeleton) _ORBIT_skel_GNOME_capplet_try;
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_capplet(CORBA_Object obj, POA_GNOME_capplet * servant)
{
   obj->vepv[GNOME_capplet__classid] = servant->vepv->GNOME_capplet_epv;
}

void
POA_GNOME_capplet__init(PortableServer_Servant servant,
			CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_capplet, "IDL:GNOME/capplet:1.0",
(ORBit_local_objref_init) & init_local_objref_GNOME_capplet };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_capplet__classid)
      GNOME_capplet__classid = ORBit_register_class(&class_info);
}

void
POA_GNOME_capplet__fini(PortableServer_Servant servant,
			CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}

static ORBitSkeleton
get_skel_GNOME_control_center(POA_GNOME_control_center * servant,
			      GIOPRecvBuffer * _ORBIT_recv_buffer,
			      gpointer * impl)
{
   gchar *opname = _ORBIT_recv_buffer->message.u.request.operation;

   switch (opname[0]) {
     case 'c':
	if (strcmp((opname + 1), "hanges_are_immediate"))
	   break;
	*impl =
	   (gpointer) servant->vepv->GNOME_control_center_epv->
	   changes_are_immediate;
	return (ORBitSkeleton)
	   _ORBIT_skel_GNOME_control_center_changes_are_immediate;
	break;
     case 'r':
	switch (opname[1]) {
	  case 'e':
	     switch (opname[2]) {
	       case 'g':
		  switch (opname[3]) {
		    case 'i':
		       switch (opname[4]) {
			 case 's':
			    switch (opname[5]) {
			      case 't':
				 switch (opname[6]) {
				   case 'e':
				      switch (opname[7]) {
					case 'r':
					   switch (opname[8]) {
					     case '_':
						switch (opname[9]) {
						  case 'c':
						     switch (opname[10]) {
						       case 'a':
							  switch (opname[11]) {
							    case 'p':
							       switch (opname
								       [12]) {
								 case 'p':
								    switch
								       (opname
									[13])
								      {
								      case 'l':
									 switch
									    (opname
									     [14])
									   {
									   case 'e':
									      switch
										 (opname
										  [15])
										{
										case 't':
										   switch
										      (opname
										       [16])
										     {
										     case '\0':
											*impl
											   =
											   (gpointer)
											   servant->
											   vepv->
											   GNOME_control_center_epv->
											   register_capplet;
											return
											   (ORBitSkeleton)
											   _ORBIT_skel_GNOME_control_center_register_capplet;
											break;
										     case '_':
											if (strcmp((opname + 17), "new"))
											   break;
											*impl
											   =
											   (gpointer)
											   servant->
											   vepv->
											   GNOME_control_center_epv->
											   register_capplet_new;
											return
											   (ORBitSkeleton)
											   _ORBIT_skel_GNOME_control_center_register_capplet_new;
											break;
										     default:
											break;
										   }
										   break;
										default:
										   break;
									      }
									      break;
									   default:
									      break;
									 }
									 break;
								      default:
									 break;
								    }
								    break;
								 default:
								    break;
							       }
							       break;
							    default:
							       break;
							  }
							  break;
						       default:
							  break;
						     }
						     break;
						  default:
						     break;
						}
						break;
					     default:
						break;
					   }
					   break;
					default:
					   break;
				      }
				      break;
				   default:
				      break;
				 }
				 break;
			      default:
				 break;
			    }
			    break;
			 default:
			    break;
		       }
		       break;
		    default:
		       break;
		  }
		  break;
	       default:
		  break;
	     }
	     break;
	  default:
	     break;
	}
	break;
     case 's':
	switch (opname[1]) {
	  case 'h':
	     if (strcmp((opname + 2), "ow_control_center"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_control_center_epv->
		show_control_center;
	     return (ORBitSkeleton)
		_ORBIT_skel_GNOME_control_center_show_control_center;
	     break;
	  case 't':
	     if (strcmp((opname + 2), "ate_changed"))
		break;
	     *impl =
		(gpointer) servant->vepv->GNOME_control_center_epv->
		state_changed;
	     return (ORBitSkeleton)
		_ORBIT_skel_GNOME_control_center_state_changed;
	     break;
	  default:
	     break;
	}
	break;
     default:
	break;
   }
   return NULL;
}

static void
init_local_objref_GNOME_control_center(CORBA_Object obj,
				       POA_GNOME_control_center * servant)
{
   obj->vepv[GNOME_control_center__classid] =
      servant->vepv->GNOME_control_center_epv;
}

void
POA_GNOME_control_center__init(PortableServer_Servant servant,
			       CORBA_Environment * env)
{
   static const PortableServer_ClassInfo class_info =
      { (ORBit_impl_finder) & get_skel_GNOME_control_center,
"IDL:GNOME/control_center:1.0", (ORBit_local_objref_init) & init_local_objref_GNOME_control_center };
   PortableServer_ServantBase__init(((PortableServer_ServantBase *) servant),
				    env);
   ORBIT_OBJECT_KEY(((PortableServer_ServantBase *) servant)->_private)->
      class_info = (PortableServer_ClassInfo *) & class_info;
   if (!GNOME_control_center__classid)
      GNOME_control_center__classid = ORBit_register_class(&class_info);
}

void
POA_GNOME_control_center__fini(PortableServer_Servant servant,
			       CORBA_Environment * env)
{
   PortableServer_ServantBase__fini(servant, env);
}
