<TYPEDEF>
<NAME>BonoboArg</NAME>
typedef CORBA_any      BonoboArg;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboArgType</NAME>
typedef CORBA_TypeCode BonoboArgType;
</TYPEDEF>
<MACRO>
<NAME>BONOBO_ARG_NULL</NAME>
#define BONOBO_ARG_NULL    TC_null
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_BOOLEAN</NAME>
#define BONOBO_ARG_BOOLEAN TC_boolean
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_INT</NAME>
#define BONOBO_ARG_INT     TC_long
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_LONG</NAME>
#define BONOBO_ARG_LONG    TC_long
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_FLOAT</NAME>
#define BONOBO_ARG_FLOAT   TC_float
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_DOUBLE</NAME>
#define BONOBO_ARG_DOUBLE  TC_double
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_STRING</NAME>
#define BONOBO_ARG_STRING  TC_string
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_GENERAL</NAME>
#	define BONOBO_ARG_GET_GENERAL(a,c,t,e)   (g_assert (bonobo_arg_type_is_equal ((a)->_type, c, e)),\
					          *((t *)(a->_value)))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_GENERAL</NAME>
#	define BONOBO_ARG_SET_GENERAL(a,v,c,t,e) (g_assert (bonobo_arg_type_is_equal ((a)->_type, c, e)),\
					          *((t *)(a->_value)) = (t)(v))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_GENERAL</NAME>
#	define BONOBO_ARG_GET_GENERAL(a,c,t,e)   (*((t *)(a->_value)))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_GENERAL</NAME>
#	define BONOBO_ARG_SET_GENERAL(a,v,c,t,e) (*((t *)(a->_value)) = (t)(v))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_BOOLEAN</NAME>
#define BONOBO_ARG_GET_BOOLEAN(a)   (BONOBO_ARG_GET_GENERAL (a, TC_boolean, CORBA_boolean, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_BOOLEAN</NAME>
#define BONOBO_ARG_SET_BOOLEAN(a,v) (BONOBO_ARG_SET_GENERAL (a, v, TC_boolean, CORBA_boolean, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_INT</NAME>
#define BONOBO_ARG_GET_INT(a)       (BONOBO_ARG_GET_GENERAL (a, TC_long, CORBA_long, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_INT</NAME>
#define BONOBO_ARG_SET_INT(a,v)     (BONOBO_ARG_SET_GENERAL (a, v, TC_long, CORBA_long, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_LONG</NAME>
#define BONOBO_ARG_GET_LONG(a)      (BONOBO_ARG_GET_GENERAL (a, TC_long, CORBA_long, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_LONG</NAME>
#define BONOBO_ARG_SET_LONG(a,v)    (BONOBO_ARG_SET_GENERAL (a, v, TC_long, CORBA_long, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_FLOAT</NAME>
#define BONOBO_ARG_GET_FLOAT(a)     (BONOBO_ARG_GET_GENERAL (a, TC_float, CORBA_float, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_FLOAT</NAME>
#define BONOBO_ARG_SET_FLOAT(a,v)   (BONOBO_ARG_SET_GENERAL (a, v, TC_float, CORBA_float, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_DOUBLE</NAME>
#define BONOBO_ARG_GET_DOUBLE(a)    (BONOBO_ARG_GET_GENERAL (a, TC_double, CORBA_double, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_DOUBLE</NAME>
#define BONOBO_ARG_SET_DOUBLE(a,v)  (BONOBO_ARG_SET_GENERAL (a, v, TC_double, CORBA_double, NULL))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_GET_STRING</NAME>
#define BONOBO_ARG_GET_STRING(a)    (g_assert ((a)->_type->kind == CORBA_tk_string),	\
				     *((CORBA_char **)(a->_value)))
</MACRO>
<MACRO>
<NAME>BONOBO_ARG_SET_STRING</NAME>
#define BONOBO_ARG_SET_STRING(a,v)  (g_assert ((a)->_type->kind == CORBA_tk_string),	\
				     *((CORBA_char **)(a->_value)) = CORBA_string_dup ((v)?(v):""))
</MACRO>
<FUNCTION>
<NAME>bonobo_arg_new</NAME>
<RETURNS>BonoboArg     *</RETURNS>
BonoboArgType  t
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_release</NAME>
<RETURNS>void  </RETURNS>
BonoboArg     *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_copy</NAME>
<RETURNS>BonoboArg     *</RETURNS>
const BonoboArg *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_from_gtk</NAME>
<RETURNS>void  </RETURNS>
BonoboArg    *a,const GtkArg *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_type_from_gtk</NAME>
<RETURNS>BonoboArgType  </RETURNS>
GtkType t
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_to_gtk</NAME>
<RETURNS>void  </RETURNS>
GtkArg          *a,const BonoboArg *arg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_type_to_gtk</NAME>
<RETURNS>GtkType  </RETURNS>
BonoboArgType id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_is_equal</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboArg         *a,BonoboArg         *b,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_arg_type_is_equal</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboArgType      a,BonoboArgType      b,CORBA_Environment *opt_ev
</FUNCTION>
<ENUM>
<NAME>BonoboAsyncArgFlag</NAME>
typedef enum {
	BONOBO_ASYNC_IN  = 0x1,
	BONOBO_ASYNC_OUT = 0x2
} BonoboAsyncArgFlag;
</ENUM>
<TYPEDEF>
<NAME>BonoboAsyncArg</NAME>
typedef struct {
	const CORBA_TypeCode  type;
	BonoboAsyncArgFlag    flag;
} BonoboAsyncArg;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboAsyncMethod</NAME>
typedef struct {
	const char           *name;
	const CORBA_TypeCode  ret_type;
	const BonoboAsyncArg *arguments;  /* NULL-terminated */
	const CORBA_TypeCode *exceptions; /* NULL-terminated */
} BonoboAsyncMethod;
</TYPEDEF>
<STRUCT>
<NAME>BonoboAsyncReply</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboAsyncCallback</NAME>
<RETURNS>void </RETURNS>
BonoboAsyncReply  *reply,
				     CORBA_Environment *ev,
				     gpointer           user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_async_demarshal</NAME>
<RETURNS>void  </RETURNS>
BonoboAsyncReply        *reply,gpointer                 retval,gpointer                *out_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_async_invoke</NAME>
<RETURNS>void  </RETURNS>
const BonoboAsyncMethod *method,BonoboAsyncCallback      cb,gpointer                 user_data,guint                    timeout_msec,CORBA_Object             object,gpointer                *args,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_async_handle_get_recv</NAME>
<RETURNS>GIOPRecvBuffer  *</RETURNS>
BonoboAsyncReply *reply
</FUNCTION>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT_TYPE</NAME>
#define BONOBO_CANVAS_COMPONENT_TYPE        (bonobo_canvas_component_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT</NAME>
#define BONOBO_CANVAS_COMPONENT(o)          (GTK_CHECK_CAST ((o), BONOBO_CANVAS_COMPONENT_TYPE, BonoboCanvasComponent))
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_COMPONENT_CLASS</NAME>
#define BONOBO_CANVAS_COMPONENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CANVAS_COMPONENT__TYPE, BonoboCanvasComponentClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_COMPONENT</NAME>
#define BONOBO_IS_CANVAS_COMPONENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_CANVAS_COMPONENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_COMPONENT_CLASS</NAME>
#define BONOBO_IS_CANVAS_COMPONENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CANVAS_COMPONENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboCanvasComponentPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboCanvasComponent</NAME>
typedef struct {
	BonoboXObject base;
	BonoboCanvasComponentPrivate *priv;
} BonoboCanvasComponent;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboCanvasComponentClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;
	
	POA_Bonobo_Canvas_Component__epv epv;

	/* Signals */
	void (*set_bounds) (BonoboCanvasComponent *component,
			    Bonobo_Canvas_DRect   *bbox,
			    CORBA_Environment     *ev);
	
	gboolean (*event)  (BonoboCanvasComponent *component,
			    GdkEvent              *event);
} BonoboCanvasComponentClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_canvas_component_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_construct</NAME>
<RETURNS>BonoboCanvasComponent   *</RETURNS>
BonoboCanvasComponent       *comp,GnomeCanvasItem             *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_new</NAME>
<RETURNS>BonoboCanvasComponent   *</RETURNS>
GnomeCanvasItem             *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_get_item</NAME>
<RETURNS>GnomeCanvasItem         *</RETURNS>
BonoboCanvasComponent       *comp
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_grab</NAME>
<RETURNS>void 	</RETURNS>
BonoboCanvasComponent       *comp, guint mask, GdkCursor *cursor, guint32 time
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_ungrab</NAME>
<RETURNS>void 	</RETURNS>
BonoboCanvasComponent       *comp, guint32 time
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_component_get_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboCanvasComponent       *comp
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_new</NAME>
<RETURNS>GnomeCanvas  *</RETURNS>
gboolean                     is_aa,Bonobo_Canvas_ComponentProxy proxy
</FUNCTION>
<MACRO>
<NAME>BONOBO_CANVAS_ITEM</NAME>
#define BONOBO_CANVAS_ITEM(obj)          (GTK_CHECK_CAST((obj), bonobo_canvas_item_get_type (), BonoboCanvasItem))
</MACRO>
<MACRO>
<NAME>BONOBO_CANVAS_ITEM_CLASS</NAME>
#define BONOBO_CANVAS_ITEM_CLASS(k)      (GTK_CHECK_CLASS_CAST ((k), bonobo_canvas_item_get_type (), BonoboCanvasItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CANVAS_ITEM</NAME>
#define BONOBO_IS_CANVAS_ITEM(o)         (GTK_CHECK_TYPE((o), bonobo_canvas_item_get_type ()))
</MACRO>
<STRUCT>
<NAME>BonoboCanvasItemPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboCanvasItem</NAME>
typedef struct {
	GnomeCanvasItem         canvas_item;
	BonoboEmbeddable        *embeddable;
	BonoboCanvasItemPrivate *priv;
} BonoboCanvasItem;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboCanvasItemClass</NAME>
typedef struct {
	GnomeCanvasItemClass parent_class;
} BonoboCanvasItemClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_canvas_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_canvas_item_set_bounds</NAME>
<RETURNS>void 	</RETURNS>
BonoboCanvasItem *item, double x1, double y1, double x2, double y2
</FUNCTION>
<MACRO>
<NAME>BONOBO_CLIENT_SITE_TYPE</NAME>
#define BONOBO_CLIENT_SITE_TYPE        (bonobo_client_site_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CLIENT_SITE</NAME>
#define BONOBO_CLIENT_SITE(o)          (GTK_CHECK_CAST ((o), BONOBO_CLIENT_SITE_TYPE, BonoboClientSite))
</MACRO>
<MACRO>
<NAME>BONOBO_CLIENT_SITE_CLASS</NAME>
#define BONOBO_CLIENT_SITE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CLIENT_SITE_TYPE, BonoboClientSiteClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CLIENT_SITE</NAME>
#define BONOBO_IS_CLIENT_SITE(o)       (GTK_CHECK_TYPE ((o), BONOBO_CLIENT_SITE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CLIENT_SITE_CLASS</NAME>
#define BONOBO_IS_CLIENT_SITE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CLIENT_SITE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboClientSite</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboClientSitePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboClientSite</NAME>
struct BonoboClientSite {
	BonoboXObject base;

	BonoboItemContainer *container;
	BonoboObjectClient  *bound_embeddable; /* IDL:Bonobo/Embeddable:1.0 */
	GList		    *view_frames;
	GList               *canvas_items;
	unsigned int         child_shown:1;

	BonoboClientSitePrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboClientSiteClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_ClientSite__epv epv;

	void (*show_window)  (BonoboClientSite *, CORBA_boolean shown);
	void (*queue_resize) (BonoboClientSite *);
	void (*save_object)  (BonoboClientSite *, Bonobo_Persist_Status *status);
} BonoboClientSiteClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_client_site_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new</NAME>
<RETURNS>BonoboClientSite            *</RETURNS>
BonoboItemContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_construct</NAME>
<RETURNS>BonoboClientSite            *</RETURNS>
BonoboClientSite    *client_site,BonoboItemContainer *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_bind_embeddable</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboClientSite    *client_site,BonoboObjectClient  *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_embeddable</NAME>
<RETURNS>BonoboObjectClient          *</RETURNS>
BonoboClientSite    *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_container</NAME>
<RETURNS>BonoboItemContainer         *</RETURNS>
BonoboClientSite    *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_view_full</NAME>
<RETURNS>BonoboViewFrame             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIContainer  uic,gboolean            visible_cover,gboolean            active_view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_view</NAME>
<RETURNS>BonoboViewFrame             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIContainer  uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_new_item</NAME>
<RETURNS>GnomeCanvasItem             *</RETURNS>
BonoboClientSite   *client_site,Bonobo_UIContainer  uic,GnomeCanvasGroup   *group
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_get_verbs</NAME>
<RETURNS>GList                       *</RETURNS>
BonoboClientSite   *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_client_site_free_verbs</NAME>
<RETURNS>void  </RETURNS>
GList              *verb_list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_load</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboStorage *storage,const char *interface,BonoboClientSite *client_site
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_save</NAME>
<RETURNS>int  </RETURNS>
BonoboEmbeddable *bonobo_object,BonoboStorage   *storage,gboolean       same_as_loaded
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_load_from_stream</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboStream *stream,const char *interface
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_save_to_stream</NAME>
<RETURNS>int  </RETURNS>
BonoboEmbeddable *bonobo_object,BonoboStream    *stream
</FUNCTION>
<FUNCTION>
<NAME>gnome_get_class_id_from_file</NAME>
<RETURNS>char               *</RETURNS>
const char *filename
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_TYPE</NAME>
#define BONOBO_CONTROL_FRAME_TYPE        (bonobo_control_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME</NAME>
#define BONOBO_CONTROL_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_CONTROL_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_FRAME_TYPE, BonoboControlFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME</NAME>
#define BONOBO_IS_CONTROL_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_FRAME_CLASS</NAME>
#define BONOBO_IS_CONTROL_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControlFramePrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboControlFrame</NAME>
typedef struct {
	BonoboXObject base;
	BonoboControlFramePrivate *priv;
} BonoboControlFrame;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboControlFrameClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_ControlFrame__epv epv;

	/* Signals. */
	void (*activated)           (BonoboControlFrame *control_frame, gboolean state);
	void (*activate_uri)        (BonoboControlFrame *control_frame, const char *uri, gboolean relative);

} BonoboControlFrameClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_control_frame_new</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
Bonobo_UIContainer   ui_container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_widget</NAME>
<RETURNS>GtkWidget                     *</RETURNS>
BonoboControlFrame  *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_ui_container</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,Bonobo_UIContainer   uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autoactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autoactivate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autoactivate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control_property_bag</NAME>
<RETURNS>Bonobo_PropertyBag  </RETURNS>
BonoboControlFrame  *control_frame,CORBA_Environment   *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_propbag</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,BonoboPropertyBag   *propbag
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_propbag</NAME>
<RETURNS>BonoboPropertyBag             *</RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_control_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,GtkStateType         state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_set_autostate</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,gboolean             autostate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_autostate</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_bind_to_control</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame  *control_frame,Bonobo_Control       control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_control</NAME>
<RETURNS>Bonobo_Control  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboControlFrame  *control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_construct</NAME>
<RETURNS>BonoboControlFrame            *</RETURNS>
BonoboControlFrame  *control_frame,Bonobo_UIContainer   ui_container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_size_request</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *control_frame,int                *desired_width,int                *desired_height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_sync_realize</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_sync_unrealize</NAME>
<RETURNS>void  </RETURNS>
BonoboControlFrame *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_frame_focus</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControlFrame *frame, GtkDirectionType direction
</FUNCTION>
<MACRO>
<NAME>BONOBO_CONTROL_TYPE</NAME>
#define BONOBO_CONTROL_TYPE        (bonobo_control_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL</NAME>
#define BONOBO_CONTROL(o)          (GTK_CHECK_CAST ((o), BONOBO_CONTROL_TYPE, BonoboControl))
</MACRO>
<MACRO>
<NAME>BONOBO_CONTROL_CLASS</NAME>
#define BONOBO_CONTROL_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_CONTROL_TYPE, BonoboControlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL</NAME>
#define BONOBO_IS_CONTROL(o)       (GTK_CHECK_TYPE ((o), BONOBO_CONTROL_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_CONTROL_CLASS</NAME>
#define BONOBO_IS_CONTROL_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_CONTROL_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboControlPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboControl</NAME>
typedef struct {
	BonoboXObject base;

	BonoboControlPrivate *priv;
} BonoboControl;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboControlClass</NAME>
typedef struct {
	BonoboXObjectClass      parent_class;

	POA_Bonobo_Control__epv epv;

	/* Signals. */
	void (*set_frame)      (BonoboControl *control);
	void (*activate)       (BonoboControl *control, gboolean state);
} BonoboControlClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_control_new</NAME>
<RETURNS>BonoboControl               *</RETURNS>
GtkWidget     *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_widget</NAME>
<RETURNS>GtkWidget                   *</RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_automerge</NAME>
<RETURNS>void  </RETURNS>
BonoboControl *control,gboolean       automerge
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_automerge</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboControl *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,const char          *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_construct</NAME>
<RETURNS>BonoboControl               *</RETURNS>
BonoboControl       *control,GtkWidget           *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ui_component</NAME>
<RETURNS>BonoboUIComponent           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_ui_component</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboUIComponent   *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_remote_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_control_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,Bonobo_ControlFrame  control_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_control_frame</NAME>
<RETURNS>Bonobo_ControlFrame  </RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_set_properties</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,BonoboPropertyBag   *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_properties</NAME>
<RETURNS>BonoboPropertyBag           *</RETURNS>
BonoboControl       *control
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_get_ambient_properties</NAME>
<RETURNS>Bonobo_PropertyBag  </RETURNS>
BonoboControl       *control,CORBA_Environment   *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboControl       *control,gboolean             activated
</FUNCTION>
<FUNCTION>
<NAME>bonobo_control_windowid_from_x11</NAME>
<RETURNS>Bonobo_Control_windowId  </RETURNS>
guint32              x11_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_context_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
const CORBA_char  *context_name,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_context_add</NAME>
<RETURNS>void  </RETURNS>
const CORBA_char  *context_name,Bonobo_Unknown     context
</FUNCTION>
<FUNCTION>
<NAME>bonobo_context_running_get</NAME>
<RETURNS>BonoboObject   *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_running_context_auto_exit_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_context_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_context_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW_TYPE</NAME>
#define BONOBO_DESKTOP_WINDOW_TYPE        (bonobo_desktop_window_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW</NAME>
#define BONOBO_DESKTOP_WINDOW(o)          (GTK_CHECK_CAST ((o), BONOBO_DESKTOP_WINDOW_TYPE, BonoboDesktopWindow))
</MACRO>
<MACRO>
<NAME>BONOBO_DESKTOP_WINDOW_CLASS</NAME>
#define BONOBO_DESKTOP_WINDOW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_DESKTOP_WINDOW_TYPE, BonoboDesktopWindowClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_DESKTOP_WINDOW</NAME>
#define BONOBO_IS_DESKTOP_WINDOW(o)       (GTK_CHECK_TYPE ((o), BONOBO_DESKTOP_WINDOW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_DESKTOP_WINDOW_CLASS</NAME>
#define BONOBO_IS_DESKTOP_WINDOW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_DESKTOP_WINDOW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboDesktopWindowPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboDesktopWindow</NAME>
typedef struct {
	BonoboXObject base;
	GtkWindow   *window;
	BonoboDesktopWindowPrivate *priv;
} BonoboDesktopWindow;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboDesktopWindowClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_Desktop_Window__epv epv;
} BonoboDesktopWindowClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_desktop_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_construct</NAME>
<RETURNS>BonoboDesktopWindow  *</RETURNS>
BonoboDesktopWindow *desk_win,GtkWindow           *toplevel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_new</NAME>
<RETURNS>BonoboDesktopWindow  *</RETURNS>
GtkWindow           *toplevel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_desktop_window_control</NAME>
<RETURNS>void  </RETURNS>
BonoboObject        *object,GtkWindow           *win
</FUNCTION>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_TYPE</NAME>
#define BONOBO_EMBEDDABLE_TYPE        (bonobo_embeddable_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE</NAME>
#define BONOBO_EMBEDDABLE(o)          (GTK_CHECK_CAST ((o), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddable))
</MACRO>
<MACRO>
<NAME>BONOBO_EMBEDDABLE_CLASS</NAME>
#define BONOBO_EMBEDDABLE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_EMBEDDABLE_TYPE, BonoboEmbeddableClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE</NAME>
#define BONOBO_IS_EMBEDDABLE(o)       (GTK_CHECK_TYPE ((o), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EMBEDDABLE_CLASS</NAME>
#define BONOBO_IS_EMBEDDABLE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_EMBEDDABLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddableClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddablePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_FACTORY</NAME>
#define BONOBO_VIEW_FACTORY(fn) ((BonoboViewFactory)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewFactory</NAME>
<RETURNS>BonoboView *</RETURNS>
BonoboEmbeddable *embeddable, const Bonobo_ViewFrame view_frame, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeItemCreator</NAME>
<RETURNS>BonoboCanvasComponent *</RETURNS>
BonoboEmbeddable *embeddable, GnomeCanvas *canvas, void *user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachViewFn</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, void *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboEmbeddableForeachItemFn</NAME>
<RETURNS>void </RETURNS>
BonoboCanvasComponent *comp, void *data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboEmbeddable</NAME>
struct BonoboEmbeddable {
	BonoboXObject base;

	char *host_name;
	char *host_appname;
	Bonobo_ClientSite client_site;

	/*
	 * The URI this component represents
	 */
	char *uri;
	
	BonoboEmbeddablePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboEmbeddableClass</NAME>
struct BonoboEmbeddableClass {
	BonoboXObjectClass parent_class;

	POA_Bonobo_Embeddable__epv epv;

	/* Signals */
	void (*host_name_changed)  (BonoboEmbeddable *comp, const char *hostname);
	void (*uri_changed)        (BonoboEmbeddable *comp, const char *uri);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_embeddable_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboViewFactory factory,void             *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_new_canvas_item</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
GnomeItemCreator  item_factory,void             *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,BonoboViewFactory factory,void             *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_construct_full</NAME>
<RETURNS>BonoboEmbeddable  *</RETURNS>
BonoboEmbeddable *embeddable,BonoboViewFactory factory,void             *factory_data,GnomeItemCreator  item_factory,void             *item_factory_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_view_factory</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboViewFactory factory,void             *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_get_uri</NAME>
<RETURNS>const char       *</RETURNS>
BonoboEmbeddable *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_set_uri</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,const char       *uri
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_view</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachViewFn fn,void             *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_embeddable_foreach_item</NAME>
<RETURNS>void  </RETURNS>
BonoboEmbeddable *embeddable,BonoboEmbeddableForeachItemFn fn,void             *data
</FUNCTION>
<MACRO>
<NAME>BONOBO_EVENT_SOURCE_TYPE</NAME>
#define BONOBO_EVENT_SOURCE_TYPE        (bonobo_event_source_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_EVENT_SOURCE</NAME>
#define BONOBO_EVENT_SOURCE(o)          (GTK_CHECK_CAST ((o), BONOBO_EVENT_SOURCE_TYPE, BonoboEventSource))
</MACRO>
<MACRO>
<NAME>BONOBO_EVENT_SOURCE_CLASS</NAME>
#define BONOBO_EVENT_SOURCE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_EVENT_SOURCE_TYPE, BonoboEventSourceClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EVENT_SOURCE</NAME>
#define BONOBO_IS_EVENT_SOURCE(o)       (GTK_CHECK_TYPE ((o), BONOBO_EVENT_SOURCE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_EVENT_SOURCE_CLASS</NAME>
#define BONOBO_IS_EVENT_SOURCE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_EVENT_SOURCE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboEventSourcePrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboEventSource</NAME>
typedef struct {
	BonoboXObject             parent;
	BonoboEventSourcePrivate *priv;
} BonoboEventSource;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboEventSourceClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_EventSource__epv epv;
} BonoboEventSourceClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_event_source_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_source_new</NAME>
<RETURNS>BonoboEventSource  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_source_notify_listeners</NAME>
<RETURNS>void  </RETURNS>
BonoboEventSource *event_source,const char        *event_name,const CORBA_any   *value,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_source_notify_listeners_full</NAME>
<RETURNS>void  </RETURNS>
BonoboEventSource *event_source,const char        *path,const char        *type,const char        *subtype,const CORBA_any   *value,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_source_client_remove_listener</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Unknown     object,Bonobo_EventSource_ListenerId id,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_source_client_add_listener</NAME>
<RETURNS>Bonobo_EventSource_ListenerId</RETURNS>
Bonobo_Unknown           object,BonoboListenerCallbackFn event_callback,const char               *opt_mask,CORBA_Environment        *opt_ev,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_source_ignore_listeners</NAME>
<RETURNS>void  </RETURNS>
BonoboEventSource *event_source
</FUNCTION>
<MACRO>
<NAME>bonobo_exception_set</NAME>
#define bonobo_exception_set(opt_ev,repo_id) G_STMT_START{                  \
     if (opt_ev) {                                                          \
         CORBA_exception_set (opt_ev, CORBA_USER_EXCEPTION, repo_id, NULL); \
     } else {                                                               \
	 g_log (G_LOG_DOMAIN,						    \
		G_LOG_LEVEL_CRITICAL,					    \
		"file %s: line %d: bonobo exception: `%s'",                 \
		__FILE__,						    \
		__LINE__,						    \
		bonobo_exception_repoid_to_text (repo_id));                 \
     } }G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_return_if_fail</NAME>
#define bonobo_return_if_fail(expr,opt_ev) G_STMT_START{		\
     if (!(expr)) {							\
         if (opt_ev)                                                    \
	     CORBA_exception_set (opt_ev, CORBA_USER_EXCEPTION,         \
				  ex_Bonobo_BadArg, NULL);              \
         return;                                                        \
     };	}G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_return_val_if_fail</NAME>
#define bonobo_return_val_if_fail(expr,val,opt_ev) G_STMT_START{	\
     if (!(expr)) {							\
         if (opt_ev)                                                    \
	     CORBA_exception_set (opt_ev, CORBA_USER_EXCEPTION,         \
				  ex_Bonobo_BadArg, NULL);              \
         return val;                                                    \
     };	}G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_return_if_fail</NAME>
#define bonobo_return_if_fail(expr,opt_ev) G_STMT_START{		\
     if (!(expr)) {							\
         if (opt_ev)                                                    \
	     CORBA_exception_set (opt_ev, CORBA_USER_EXCEPTION,         \
				  ex_Bonobo_BadArg, NULL);              \
	 g_log (G_LOG_DOMAIN,						\
		G_LOG_LEVEL_CRITICAL,					\
		"file %s: line %d (%s): assertion `%s' failed.",	\
		__FILE__,						\
		__LINE__,						\
		G_GNUC_PRETTY_FUNCTION,					\
		#expr);							\
         return;                                                        \
     };	}G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_return_val_if_fail</NAME>
#define bonobo_return_val_if_fail(expr,val,opt_ev) G_STMT_START{	\
     if (!(expr)) {							\
         if (opt_ev)                                                    \
	     CORBA_exception_set (opt_ev, CORBA_USER_EXCEPTION,         \
				  ex_Bonobo_BadArg, NULL);              \
	 g_log (G_LOG_DOMAIN,						\
		G_LOG_LEVEL_CRITICAL,					\
		"file %s: line %d (%s): assertion `%s' failed.",	\
		__FILE__,						\
		__LINE__,						\
		G_GNUC_PRETTY_FUNCTION,					\
		#expr);							\
         return val;                                                    \
     };	}G_STMT_END
</MACRO>
<MACRO>
<NAME>BONOBO_EX</NAME>
#define BONOBO_EX(ev)         ((ev) && (ev)->_major != CORBA_NO_EXCEPTION)
</MACRO>
<MACRO>
<NAME>BONOBO_USER_EX</NAME>
#define BONOBO_USER_EX(ev,id) ((ev) && (ev)->major == CORBA_USER_EXCEPTION &&	\
			       (ev)->_repo_id != NULL && !strcmp ((ev)->_repo_id, id))
</MACRO>
<MACRO>
<NAME>BONOBO_RET_EX</NAME>
#define BONOBO_RET_EX(ev)		\
	G_STMT_START			\
		if (BONOBO_EX (ev))	\
			return;		\
	G_STMT_END
</MACRO>
<MACRO>
<NAME>BONOBO_RET_VAL_EX</NAME>
#define BONOBO_RET_VAL_EX(ev,v)		\
	G_STMT_START			\
		if (BONOBO_EX (ev))	\
			return (v);	\
	G_STMT_END
</MACRO>
<USER_FUNCTION>
<NAME>BonoboExceptionFn</NAME>
<RETURNS>char *</RETURNS>
CORBA_Environment *ev, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_get_text</NAME>
<RETURNS>char  *</RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_repoid_to_text</NAME>
<RETURNS>char  *</RETURNS>
const char *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_add_handler_str</NAME>
<RETURNS>void  </RETURNS>
const char *repo_id,const char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_exception_add_handler_fn</NAME>
<RETURNS>void  </RETURNS>
const char *repo_id,BonoboExceptionFn fn,gpointer          user_data,GDestroyNotify    destroy_fn
</FUNCTION>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_TYPE</NAME>
#define BONOBO_GENERIC_FACTORY_TYPE        (bonobo_generic_factory_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY</NAME>
#define BONOBO_GENERIC_FACTORY(o)          (GTK_CHECK_CAST ((o), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactory))
</MACRO>
<MACRO>
<NAME>BONOBO_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_GENERIC_FACTORY_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_GENERIC_FACTORY_TYPE, BonoboGenericFactoryClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY</NAME>
#define BONOBO_IS_GENERIC_FACTORY(o)       (GTK_CHECK_TYPE ((o), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_GENERIC_FACTORY_CLASS</NAME>
#define BONOBO_IS_GENERIC_FACTORY_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_GENERIC_FACTORY_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboGenericFactoryPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboGenericFactoryFn</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *Factory, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeFactoryCallback</NAME>
<RETURNS>BonoboObject *</RETURNS>
BonoboGenericFactory *factory, const char *component_id, gpointer closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboGenericFactory</NAME>
struct BonoboGenericFactory {
	BonoboObject base;

	/* The function factory */
	BonoboGenericFactoryFn factory; /* compat reasons only */
	GnomeFactoryCallback   factory_cb;
	gpointer               factory_closure;

	/* The component_id for this generic factory */
	char *oaf_iid;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboGenericFactoryClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/* Virtual methods */
	BonoboObject *(*new_generic) (BonoboGenericFactory *c_factory,
				      const char           *component_id);
} BonoboGenericFactoryClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_generic_factory_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_corba_object_create</NAME>
<RETURNS>CORBA_Object  </RETURNS>
BonoboObject *object,gpointer      shlib_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char            *oaf_iid,BonoboGenericFactoryFn factory,gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_new_multi</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char            *oaf_iid,GnomeFactoryCallback   factory_cb,gpointer               data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_construct</NAME>
<RETURNS>BonoboGenericFactory  *</RETURNS>
const char            *oaf_iid,BonoboGenericFactory  *c_factory,CORBA_Object           corba_factory,BonoboGenericFactoryFn factory,GnomeFactoryCallback   factory_cb,gpointer               user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_set</NAME>
<RETURNS>void  </RETURNS>
BonoboGenericFactory  *c_factory,BonoboGenericFactoryFn factory,void                  *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_generic_factory_get_epv</NAME>
<RETURNS>POA_GNOME_ObjectFactory__epv  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_OAF_FACTORY</NAME>
#define BONOBO_OAF_FACTORY(oafiid, descr, version, fn, data)                  \
int main (int argc, char *argv [])                                            \
{                                                                             \
	BonoboGenericFactory *factory;                                        \
	CORBA_Environment ev;                                                 \
	CORBA_ORB orb;                                                        \
                                                                              \
	CORBA_exception_init (&ev);                                           \
	gnome_init_with_popt_table (descr, version, argc, argv,               \
				    oaf_popt_options, 0, NULL);               \
        orb = oaf_init (argc, argv);                                          \
	if (!bonobo_init (orb, CORBA_OBJECT_NIL, CORBA_OBJECT_NIL))           \
		g_error (_("Could not initialize Bonobo"));                   \
	factory = bonobo_generic_factory_new (oafiid, fn, data);              \
	bonobo_running_context_auto_exit_unref (BONOBO_OBJECT (factory));     \
	bonobo_main ();                                                       \
	CORBA_exception_free (&ev);                                           \
	return 0;                                                             \
}                                                                             
</MACRO>
<MACRO>
<NAME>BONOBO_OAF_FACTORY_MULTI</NAME>
#define BONOBO_OAF_FACTORY_MULTI(oafiid, descr, version, fn, data)            \
int main (int argc, char *argv [])                                            \
{                                                                             \
	BonoboGenericFactory *factory;                                        \
	CORBA_Environment ev;                                                 \
	CORBA_ORB orb;                                                        \
                                                                              \
	CORBA_exception_init (&ev);                                           \
	gnome_init_with_popt_table (descr, version, argc, argv,               \
				    oaf_popt_options, 0, NULL);               \
        orb = oaf_init (argc, argv);                                          \
	if (!bonobo_init (orb, CORBA_OBJECT_NIL, CORBA_OBJECT_NIL))           \
		g_error (_("Could not initialize Bonobo"));                   \
	factory = bonobo_generic_factory_new_multi (oafiid, fn, data);        \
	bonobo_running_context_auto_exit_unref (BONOBO_OBJECT (factory));     \
	bonobo_main ();                                                       \
	CORBA_exception_free (&ev);                                           \
	return 0;                                                             \
}                                                                             
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_HANDLER_TYPE</NAME>
#define BONOBO_ITEM_HANDLER_TYPE        (bonobo_item_handler_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_HANDLER</NAME>
#define BONOBO_ITEM_HANDLER(o)          (GTK_CHECK_CAST ((o), BONOBO_ITEM_HANDLER_TYPE, BonoboItemHandler))
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_HANDLER_CLASS</NAME>
#define BONOBO_ITEM_HANDLER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_ITEM_HANDLER_TYPE, BonoboItemHandlerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_HANDLER</NAME>
#define BONOBO_IS_ITEM_HANDLER(o)       (GTK_CHECK_TYPE ((o), BONOBO_ITEM_HANDLER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_HANDLER_CLASS</NAME>
#define BONOBO_IS_ITEM_HANDLER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_ITEM_HANDLER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboItemHandlerPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboItemHandler</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboItemHandler</NAME>
struct BonoboItemHandler {
	BonoboXObject base;

	POA_Bonobo_ItemContainer__epv epv;

	BonoboItemHandlerEnumObjectsFn enum_objects;
	BonoboItemHandlerGetObjectFn   get_object;
	gpointer                       user_data;

	BonoboItemHandlerPrivate      *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboItemHandlerClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_ItemContainer__epv epv;
} BonoboItemHandlerClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_item_handler_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_handler_new</NAME>
<RETURNS>BonoboItemHandler    *</RETURNS>
BonoboItemHandlerEnumObjectsFn enum_objects,BonoboItemHandlerGetObjectFn   get_object,gpointer                       user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_handler_construct</NAME>
<RETURNS>BonoboItemHandler    *</RETURNS>
BonoboItemHandler             *handler,BonoboItemHandlerEnumObjectsFn enum_objects,BonoboItemHandlerGetObjectFn   get_object,gpointer                       user_data
</FUNCTION>
<TYPEDEF>
<NAME>BonoboItemOption</NAME>
typedef struct {
	char *key;
	char *value;
} BonoboItemOption;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_item_option_parse</NAME>
<RETURNS>GSList  *</RETURNS>
const char *option_string
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_options_free</NAME>
<RETURNS>void  </RETURNS>
GSList *options
</FUNCTION>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER_TYPE</NAME>
#define BONOBO_ITEM_CONTAINER_TYPE        (bonobo_item_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER</NAME>
#define BONOBO_ITEM_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_ITEM_CONTAINER_TYPE, BonoboItemContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_ITEM_CONTAINER_CLASS</NAME>
#define BONOBO_ITEM_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_ITEM_CONTAINER_TYPE, BonoboItemContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_CONTAINER</NAME>
#define BONOBO_IS_ITEM_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_ITEM_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ITEM_CONTAINER_CLASS</NAME>
#define BONOBO_IS_ITEM_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_ITEM_CONTAINER_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboClientSiteList</NAME>
typedef GList BonoboClientSiteList;
</TYPEDEF>
<STRUCT>
<NAME>BonoboItemContainerPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboItemContainer</NAME>
typedef struct {
	BonoboXObject base;

	BonoboItemContainerPrivate *priv;
} BonoboItemContainer;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboItemContainerClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_ItemContainer__epv epv;

	Bonobo_Unknown (*get_object) (BonoboItemContainer *item_container,
				      CORBA_char          *item_name,
				      CORBA_boolean        only_if_exists,
				      CORBA_Environment   *ev);
} BonoboItemContainerClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_item_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_new</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_add</NAME>
<RETURNS>void  </RETURNS>
BonoboItemContainer *container,const char          *name,BonoboObject        *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_item_container_remove_by_name</NAME>
<RETURNS>void  </RETURNS>
BonoboItemContainer *container,const char          *name
</FUNCTION>
<MACRO>
<NAME>BONOBO_LISTENER_TYPE</NAME>
#define BONOBO_LISTENER_TYPE        (bonobo_listener_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_LISTENER</NAME>
#define BONOBO_LISTENER(o)          (GTK_CHECK_CAST ((o), BONOBO_LISTENER_TYPE, BonoboListener))
</MACRO>
<MACRO>
<NAME>BONOBO_LISTENER_CLASS</NAME>
#define BONOBO_LISTENER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_LISTENER_TYPE, BonoboListenerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_LISTENER</NAME>
#define BONOBO_IS_LISTENER(o)       (GTK_CHECK_TYPE ((o), BONOBO_LISTENER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_LISTENER_CLASS</NAME>
#define BONOBO_IS_LISTENER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_LISTENER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboListenerPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboListener</NAME>
typedef struct {
        BonoboXObject          parent;

	BonoboListenerPrivate *priv;
} BonoboListener;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboListenerClass</NAME>
typedef struct {
	BonoboXObjectClass     parent_class;

	POA_Bonobo_Listener__epv epv;

	/* Signals */
	void (* event_notify) (BonoboListener    *listener, 
			       char              *event_name,
			       BonoboArg         *event_data, 
			       CORBA_Environment *ev);
} BonoboListenerClass;
</TYPEDEF>
<USER_FUNCTION>
<NAME>BonoboListenerCallbackFn</NAME>
<RETURNS>void </RETURNS>
BonoboListener    *listener,
					   char              *event_name, 
					   CORBA_any         *any,
					   CORBA_Environment *ev,
					   gpointer           user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_listener_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_listener_new</NAME>
<RETURNS>BonoboListener  *</RETURNS>
BonoboListenerCallbackFn event_callback,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_make_name</NAME>
<RETURNS>char            *</RETURNS>
const char *idl_path,const char *kind,const char *subtype
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_type</NAME>
<RETURNS>char            *</RETURNS>
const char *event_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_subtype</NAME>
<RETURNS>char            *</RETURNS>
const char *event_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_kind</NAME>
<RETURNS>char            *</RETURNS>
const char *event_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_event_idl_path</NAME>
<RETURNS>char            *</RETURNS>
const char *event_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_init</NAME>
<RETURNS>gboolean 	</RETURNS>
CORBA_ORB orb,PortableServer_POA poa,PortableServer_POAManager manager
</FUNCTION>
<FUNCTION>
<NAME>bonobo_main</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_activate</NAME>
<RETURNS>gboolean 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_setup_x_error_handler</NAME>
<RETURNS>void 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_orb</NAME>
<RETURNS>CORBA_ORB 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa</NAME>
<RETURNS>PortableServer_POA 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_poa_manager</NAME>
<RETURNS>PortableServer_POAManager  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>BonoboMonikerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_MONIKER_TYPE</NAME>
#define BONOBO_MONIKER_TYPE        (bonobo_moniker_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER</NAME>
#define BONOBO_MONIKER(o)          (GTK_CHECK_CAST ((o), BONOBO_MONIKER_TYPE, BonoboMoniker))
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_CLASS</NAME>
#define BONOBO_MONIKER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_MONIKER_TYPE, BonoboMonikerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER</NAME>
#define BONOBO_IS_MONIKER(o)       (GTK_CHECK_TYPE ((o), BONOBO_MONIKER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_CLASS</NAME>
#define BONOBO_IS_MONIKER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_MONIKER_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboMoniker</NAME>
typedef struct {
        BonoboXObject         object;
	
	BonoboMonikerPrivate *priv;
} BonoboMoniker;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboMonikerClass</NAME>
typedef struct {
	BonoboXObjectClass      parent_class;

	POA_Bonobo_Moniker__epv epv;

	/*
	 * virtual methods
	 */
	Bonobo_Moniker (*get_parent)         (BonoboMoniker               *moniker,
					      CORBA_Environment           *ev);
	void           (*set_parent)         (BonoboMoniker               *moniker,
					      const Bonobo_Moniker         parent,
					      CORBA_Environment           *ev);
	CORBA_char    *(*get_display_name)   (BonoboMoniker               *moniker,
					      CORBA_Environment           *ev);
	Bonobo_Moniker (*parse_display_name) (BonoboMoniker               *moniker,
					      Bonobo_Moniker               parent,
					      const CORBA_char            *name,
					      CORBA_Environment           *ev);
	Bonobo_Unknown (*resolve)            (BonoboMoniker               *moniker,
					      const Bonobo_ResolveOptions *options,
					      const CORBA_char            *requested_interface,
					      CORBA_Environment           *ev);
	CORBA_long     (*equal)              (BonoboMoniker               *moniker,
					      const CORBA_char            *display_name,
					      CORBA_Environment           *ev);

	void           (*set_name)           (BonoboMoniker               *moniker,
					      const char                  *unescaped_name);
	const char    *(*get_name)           (BonoboMoniker               *moniker);

	gpointer        dummy;
} BonoboMonikerClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_moniker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_construct</NAME>
<RETURNS>BonoboMoniker            *</RETURNS>
BonoboMoniker     *moniker,const char        *prefix
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_parent</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
BonoboMoniker     *moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_parent</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,Bonobo_Moniker     parent,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_name</NAME>
<RETURNS>const char               *</RETURNS>
BonoboMoniker     *moniker
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_name_full</NAME>
<RETURNS>const char               *</RETURNS>
BonoboMoniker     *moniker
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_name_escaped</NAME>
<RETURNS>char                     *</RETURNS>
BonoboMoniker     *moniker
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,const char        *unescaped_name,int                num_chars
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_prefix</NAME>
<RETURNS>const char               *</RETURNS>
BonoboMoniker     *moniker
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_set_case_sensitive</NAME>
<RETURNS>void  </RETURNS>
BonoboMoniker     *moniker,gboolean           sensitive
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_get_case_sensitive</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboMoniker     *moniker
</FUNCTION>
<MACRO>
<NAME>BONOBO_MONIKER_EXTENDER_TYPE</NAME>
#define BONOBO_MONIKER_EXTENDER_TYPE        (bonobo_moniker_extender_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_EXTENDER</NAME>
#define BONOBO_MONIKER_EXTENDER(o)          (GTK_CHECK_CAST ((o), BONOBO_MONIKER_EXTENDER_TYPE, BonoboMonikerExtender))
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_EXTENDER_CLASS</NAME>
#define BONOBO_MONIKER_EXTENDER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_MONIKER_EXTENDER_TYPE, BonoboMonikerExtenderClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_EXTENDER</NAME>
#define BONOBO_IS_MONIKER_EXTENDER(o)       (GTK_CHECK_TYPE ((o), BONOBO_MONIKER_EXTENDER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_EXTENDER_CLASS</NAME>
#define BONOBO_IS_MONIKER_EXTENDER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_MONIKER_EXTENDER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboMonikerExtender</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboMonikerExtenderFn</NAME>
<RETURNS>Bonobo_Unknown </RETURNS>
BonoboMonikerExtender       *extender,
						   const Bonobo_Moniker         parent,
						   const Bonobo_ResolveOptions *options,
						   const CORBA_char            *display_name,
						   const CORBA_char            *requested_interface,
						   CORBA_Environment           *ev
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboMonikerExtender</NAME>
struct BonoboMonikerExtender {
        BonoboXObject           object;
	BonoboMonikerExtenderFn resolve;
	gpointer                data;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboMonikerExtenderClass</NAME>
typedef struct {
	BonoboXObjectClass      parent_class;

	POA_Bonobo_MonikerExtender__epv epv;
	
	BonoboMonikerExtenderFn resolve;
} BonoboMonikerExtenderClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_moniker_extender_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_extender_new</NAME>
<RETURNS>BonoboMonikerExtender  *</RETURNS>
BonoboMonikerExtenderFn      resolve,gpointer                     data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_find_extender</NAME>
<RETURNS>Bonobo_MonikerExtender  </RETURNS>
const gchar                 *name,const gchar                 *interface,CORBA_Environment           *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_use_extender</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
const gchar                 *extender_oafiid,BonoboMoniker               *moniker,const Bonobo_ResolveOptions *options,const CORBA_char            *requested_interface,CORBA_Environment           *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_MONIKER_SIMPLE_TYPE</NAME>
#define BONOBO_MONIKER_SIMPLE_TYPE        (bonobo_moniker_simple_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_SIMPLE</NAME>
#define BONOBO_MONIKER_SIMPLE(o)          (GTK_CHECK_CAST ((o), BONOBO_MONIKER_SIMPLE_TYPE, BonoboMonikerSimple))
</MACRO>
<MACRO>
<NAME>BONOBO_MONIKER_SIMPLE_CLASS</NAME>
#define BONOBO_MONIKER_SIMPLE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_MONIKER_SIMPLE_TYPE, BonoboMonikerSimpleClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_SIMPLE</NAME>
#define BONOBO_IS_MONIKER_SIMPLE(o)       (GTK_CHECK_TYPE ((o), BONOBO_MONIKER_SIMPLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_MONIKER_SIMPLE_CLASS</NAME>
#define BONOBO_IS_MONIKER_SIMPLE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_MONIKER_SIMPLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboMonikerSimple</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboMonikerSimplePrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboMonikerSimpleResolveFn</NAME>
<RETURNS>Bonobo_Unknown </RETURNS>
BonoboMoniker               *moniker,
							const Bonobo_ResolveOptions *options,
							const CORBA_char            *requested_interface,
							CORBA_Environment           *ev
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboMonikerSimple</NAME>
struct BonoboMonikerSimple {
        BonoboMoniker                moniker;
	BonoboMonikerSimpleResolveFn resolve_fn;
	BonoboMonikerSimplePrivate  *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboMonikerSimpleClass</NAME>
typedef struct {
	BonoboMonikerClass parent_class;
} BonoboMonikerSimpleClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_moniker_simple_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_simple_construct</NAME>
<RETURNS>BonoboMoniker  *</RETURNS>
BonoboMonikerSimple         *moniker,const char                  *name,BonoboMonikerSimpleResolveFn resolve_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_simple_new</NAME>
<RETURNS>BonoboMoniker  *</RETURNS>
const char                  *name,BonoboMonikerSimpleResolveFn resolve_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_get_object</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
const CORBA_char        *name,const char              *interface_name,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_new_from_name</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
const CORBA_char        *name,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_get_name</NAME>
<RETURNS>CORBA_char          *</RETURNS>
Bonobo_Moniker     moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_resolve_default</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Moniker     moniker,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_resolve_client_default</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Moniker     moniker,const char        *interface_name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_equal</NAME>
<RETURNS>gboolean  </RETURNS>
Bonobo_Moniker     moniker,const CORBA_char  *name,CORBA_Environment *opt_ev
</FUNCTION>
<USER_FUNCTION>
<NAME>BonoboMonikerAsyncFn</NAME>
<RETURNS>void </RETURNS>
Bonobo_Unknown     object,
				      CORBA_Environment *ev,
				      gpointer           user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_get_object_async</NAME>
<RETURNS>void  </RETURNS>
const CORBA_char        *name,const char              *interface_name,CORBA_Environment       *ev,guint                    timeout_msec,BonoboMonikerAsyncFn     cb,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_client_new_from_name_async</NAME>
<RETURNS>void  </RETURNS>
const CORBA_char        *name,CORBA_Environment       *ev,guint                    timeout_msec,BonoboMonikerAsyncFn     cb,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_resolve_async</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Moniker           moniker,Bonobo_ResolveOptions   *options,const char              *interface_name,CORBA_Environment       *ev,guint                    timeout_msec,BonoboMonikerAsyncFn     cb,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_resolve_async_default</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Moniker           moniker,const char              *interface_name,CORBA_Environment       *ev,guint                    timeout_msec,BonoboMonikerAsyncFn     cb,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_new_from_name_full</NAME>
<RETURNS>Bonobo_Moniker  </RETURNS>
Bonobo_Moniker     parent,const CORBA_char  *name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_get_parent_name</NAME>
<RETURNS>CORBA_char     *</RETURNS>
Bonobo_Moniker     moniker,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_qi_return</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Unknown     object,const CORBA_char  *requested_interface,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_seek_std_separator</NAME>
<RETURNS>int  </RETURNS>
const CORBA_char  *str,int                min_idx
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_escape</NAME>
<RETURNS>char           *</RETURNS>
const char        *string,int                offset
</FUNCTION>
<FUNCTION>
<NAME>bonobo_moniker_util_unescape</NAME>
<RETURNS>char           *</RETURNS>
const char        *string,int                num_chars
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_TYPE</NAME>
#define BONOBO_OBJECT_CLIENT_TYPE        (bonobo_object_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT</NAME>
#define BONOBO_OBJECT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClient))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_OBJECT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_CLIENT_TYPE, BonoboObjectClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT</NAME>
#define BONOBO_IS_OBJECT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLIENT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_CLIENT_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboObjectClient</NAME>
typedef struct {
	BonoboObject parent;
} BonoboObjectClient;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboObjectClientClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;
} BonoboObjectClientClass;
</TYPEDEF>
<USER_FUNCTION>
<NAME>BonoboObjectClientAsyncCallback</NAME>
<RETURNS>void </RETURNS>
BonoboObjectClient             *o,
							  const char                     *error,
							  gpointer                        user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_from_corba</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
Bonobo_Unknown                  o
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_construct</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboObjectClient             *object_client,CORBA_Object                    corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
const char                     *iid,gint                            oaf_flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_async</NAME>
<RETURNS>void  </RETURNS>
const char                     *iid,gint                            oaf_flags,BonoboObjectClientAsyncCallback callback,gpointer                        user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_has_interface</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboObjectClient             *object,const char                     *interface_desc,CORBA_Environment              *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObjectClient             *object,const char                     *interface_desc,CORBA_Environment              *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObjectClient             *object_client,BonoboObject                   *opt_exception_obj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_client_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObjectClient             *object_client,BonoboObject                   *opt_exception_obj
</FUNCTION>
<STRUCT>
<NAME>ODServerInfo</NAME>
</STRUCT>
<ENUM>
<NAME>ODRegistrationResult</NAME>
typedef enum {
        OD_REG_SUCCESS,
        OD_REG_NOT_LISTED,
        OD_REG_ALREADY_ACTIVE,
        OD_REG_ERROR
} ODRegistrationResult;
</ENUM>
<FUNCTION>
<NAME>bonobo_directory_get_orb</NAME>
<RETURNS>CORBA_ORB  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_new_server_info</NAME>
<RETURNS>ODServerInfo         *</RETURNS>
const gchar       *iid,const gchar       *name,const gchar       *desc
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_info_id</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_info_name</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_info_description</NAME>
<RETURNS>const gchar          *</RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_server_info_ref</NAME>
<RETURNS>void  </RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_server_info_unref</NAME>
<RETURNS>void  </RETURNS>
ODServerInfo      *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_server_list</NAME>
<RETURNS>GList                *</RETURNS>
const gchar      **required_ids
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_free_server_list</NAME>
<RETURNS>void  </RETURNS>
GList             *list
</FUNCTION>
<FUNCTION>
<NAME>od_server_activate_with_id</NAME>
<RETURNS>CORBA_Object  </RETURNS>
const gchar       *iid,gint               flags,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_register_server</NAME>
<RETURNS>ODRegistrationResult  </RETURNS>
CORBA_Object       objref,const gchar       *iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_unregister_server</NAME>
<RETURNS>ODRegistrationResult  </RETURNS>
CORBA_Object       objref,const gchar       *iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_get_name_service</NAME>
<RETURNS>CORBA_Object  </RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_directory_find_for_file</NAME>
<RETURNS>char                 *</RETURNS>
const char  *fname,const char **required_ids,char       **error
</FUNCTION>
<ENUM>
<NAME>GnomeIOStatus</NAME>
typedef enum {
	GNOME_IO_OK,
	
	/* Generic error */
	GNOME_IOERR_GENERAL,

	/* PersistStorage interface not supported by object */
	GNOME_IOERR_PERSIST_NOT_SUPPORTED
	
} GnomeIOStatus;
</ENUM>
<FUNCTION>
<NAME>bonobo_persist_stream_save_object_iid</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Stream target,const CORBA_char *object_iid,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_load_object_iid</NAME>
<RETURNS>char            *</RETURNS>
Bonobo_Stream source
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persiststream_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
Bonobo_PersistStream pstream,Bonobo_Stream target,const char *object_iid
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_save_to_stream</NAME>
<RETURNS>GnomeIOStatus  </RETURNS>
BonoboObject *object,Bonobo_Stream stream,const char *object_iid
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_TYPE</NAME>
#define BONOBO_OBJECT_TYPE        (bonobo_object_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT</NAME>
#define BONOBO_OBJECT(o)          (GTK_CHECK_CAST ((o), BONOBO_OBJECT_TYPE, BonoboObject))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJECT_CLASS</NAME>
#define BONOBO_OBJECT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_OBJECT_TYPE, BonoboObjectClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT</NAME>
#define BONOBO_IS_OBJECT(o)       (GTK_CHECK_TYPE ((o), BONOBO_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_OBJECT_CLASS</NAME>
#define BONOBO_IS_OBJECT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_OBJREF</NAME>
#define BONOBO_OBJREF(o)          (bonobo_object_corba_objref(BONOBO_OBJECT(o)))
</MACRO>
<TYPEDEF>
<NAME>BonoboObjectServant</NAME>
typedef struct {
	POA_Bonobo_Unknown servant_placeholder;
	gpointer           bonobo_object;
} BonoboObjectServant;
</TYPEDEF>
<STRUCT>
<NAME>BonoboObjectPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboObject</NAME>
typedef struct {
	GtkObject            base;

	Bonobo_Unknown       corba_objref;
	gpointer             servant;
	BonoboObjectPrivate *priv;
} BonoboObject;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboObjectClass</NAME>
typedef struct {
	GtkObjectClass parent_class;

	/*
	 * signals.  
	 */
	void  (*query_interface) (BonoboObject *object, const char *repo_id,  CORBA_Object      *retval);
	void  (*system_exception)(BonoboObject *object, CORBA_Object cobject, CORBA_Environment *ev);
	gpointer expansion;
} BonoboObjectClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_object_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_construct</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,CORBA_Object            corba_object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_new_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_from_servant</NAME>
<RETURNS>BonoboObject             *</RETURNS>
PortableServer_Servant  servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_bind_to_servant</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_servant</NAME>
<RETURNS>PortableServer_Servant  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_servant_full</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,void                   *servant,gpointer shlib_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_activate_servant</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,void                   *servant
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_add_interface</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,BonoboObject           *newobj
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_local_interface</NAME>
<RETURNS>BonoboObject             *</RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_query_interface</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object,const char             *repo_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_corba_objref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_dup_ref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
Bonobo_Unknown          object,CORBA_Environment      *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_release_unref</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Unknown          object,CORBA_Environment      *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_idle_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_unref</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_get_epv</NAME>
<RETURNS>POA_Bonobo_Unknown__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_trace_refs</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object,const char   *fn,int           line,gboolean      ref
</FUNCTION>
<MACRO>
<NAME>bonobo_object_ref</NAME>
#	define           bonobo_object_ref(o)   G_STMT_START{bonobo_object_trace_refs((o),G_GNUC_PRETTY_FUNCTION,__LINE__,TRUE);}G_STMT_END
</MACRO>
<MACRO>
<NAME>bonobo_object_unref</NAME>
#	define           bonobo_object_unref(o) G_STMT_START{bonobo_object_trace_refs((o),G_GNUC_PRETTY_FUNCTION,__LINE__,FALSE);}G_STMT_END
</MACRO>
<FUNCTION>
<NAME>bonobo_object_dump_interfaces</NAME>
<RETURNS>void  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_check_env</NAME>
<RETURNS>void  </RETURNS>
BonoboObject           *object,CORBA_Object            corba_object,CORBA_Environment      *ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_OBJECT_CHECK</NAME>
#define BONOBO_OBJECT_CHECK(o,c,e)				\
			G_STMT_START {				\
			if ((e)->_major != CORBA_NO_EXCEPTION)	\
				bonobo_object_check_env(o,c,e);	\
			} G_STMT_END
</MACRO>
<FUNCTION>
<NAME>bonobo_unknown_ping</NAME>
<RETURNS>gboolean  </RETURNS>
Bonobo_Unknown object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_list_unref_all</NAME>
<RETURNS>void  </RETURNS>
GList        **list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_object_slist_unref_all</NAME>
<RETURNS>void  </RETURNS>
GSList       **list
</FUNCTION>
<MACRO>
<NAME>BONOBO_X_OBJECT_TYPE</NAME>
#define BONOBO_X_OBJECT_TYPE        (bonobo_x_object_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_X_OBJECT</NAME>
#define BONOBO_X_OBJECT(o)          (GTK_CHECK_CAST ((o), BONOBO_X_OBJECT_TYPE, BonoboXObject))
</MACRO>
<MACRO>
<NAME>BONOBO_X_OBJECT_CLASS</NAME>
#define BONOBO_X_OBJECT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_X_OBJECT_TYPE, BonoboXObjectClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_X_OBJECT</NAME>
#define BONOBO_IS_X_OBJECT(o)       (GTK_CHECK_TYPE ((o), BONOBO_X_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_X_OBJECT_CLASS</NAME>
#define BONOBO_IS_X_OBJECT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_X_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_X_OBJECT_HEADER_SIZE</NAME>
#define BONOBO_X_OBJECT_HEADER_SIZE (sizeof (BonoboObject))
</MACRO>
<MACRO>
<NAME>BONOBO_X_OBJECT_GET_CORBA</NAME>
#define BONOBO_X_OBJECT_GET_CORBA(o)   ((CORBA_Object)&(o)->object)
</MACRO>
<MACRO>
<NAME>BONOBO_X_OBJECT_GET_SERVANT</NAME>
#define BONOBO_X_OBJECT_GET_SERVANT(o) ((PortableServer_Servant)&(o)->servant)
</MACRO>
<MACRO>
<NAME>BONOBO_X_CORBA_GET_OBJECT</NAME>
#define BONOBO_X_CORBA_GET_OBJECT(o)   ((BonoboXObject *)((guchar *)(o)				\
					     - BONOBO_X_OBJECT_HEADER_SIZE))
</MACRO>
<MACRO>
<NAME>BONOBO_X_CORBA_GET_SERVANT</NAME>
#define BONOBO_X_CORBA_GET_SERVANT(o)  ((BonoboXObject *)((guchar *)(o)				\
					     + sizeof (struct CORBA_Object_struct)	\
					     + sizeof (gpointer) * 4))
</MACRO>
<MACRO>
<NAME>BONOBO_X_SERVANT_GET_CORBA</NAME>
#define BONOBO_X_SERVANT_GET_CORBA(o)  ((BonoboXObject *)((guchar *)(o)				\
					     - sizeof (struct CORBA_Object_struct)	\
					     - sizeof (gpointer) * 4))
</MACRO>
<MACRO>
<NAME>BONOBO_X_SERVANT_GET_OBJECT</NAME>
#define BONOBO_X_SERVANT_GET_OBJECT(o) ((BonoboXObject *)((guchar *)(o)				\
					     - BONOBO_X_OBJECT_HEADER_SIZE			\
					     - sizeof (struct CORBA_Object_struct)	\
					     - sizeof (gpointer) * 4))
</MACRO>
<STRUCT>
<NAME>BonoboXObject</NAME>
</STRUCT>
<FUNCTION>
<NAME>bonobo_x_object</NAME>
<RETURNS>BonoboXObject  *</RETURNS>
gpointer p
</FUNCTION>
<STRUCT>
<NAME>BonoboXObject</NAME>
struct BonoboXObject {
	BonoboObject               base;

	/* Start: CORBA_Object */
	struct CORBA_Object_struct object;
	gpointer                   bincompat[4]; /* expansion */
	/* End:   CORBA_Object */
	
	/* Start: BonoboObjectServant */
	BonoboObjectServant        servant;
	int                        flags;        /* discriminant */
	/* End:   BonoboObjectServant */

	gpointer                   dummy;

	/* User data ... */
};
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboXObjectPOAFn</NAME>
<RETURNS>void </RETURNS>
PortableServer_Servant servant,
				    CORBA_Environment     *ev
</USER_FUNCTION>
<TYPEDEF>
<NAME>BonoboXObjectClass</NAME>
typedef struct {
	BonoboObjectClass          parent_class;

	BonoboXObjectPOAFn         poa_init_fn;
	BonoboXObjectPOAFn         poa_fini_fn;

	POA_Bonobo_Unknown__vepv  *vepv;

	/* The offset of this class' additional epv */
	int                        epv_struct_offset;

	POA_Bonobo_Unknown__epv    epv;
} BonoboXObjectClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_x_object_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_x_type_unique</NAME>
<RETURNS>GtkType  </RETURNS>
GtkType            parent_type,BonoboXObjectPOAFn init_fn,BonoboXObjectPOAFn fini_fn,int                epv_struct_offset,const GtkTypeInfo *info
</FUNCTION>
<FUNCTION>
<NAME>bonobo_x_type_setup</NAME>
<RETURNS>gboolean  </RETURNS>
GtkType            type,BonoboXObjectPOAFn init_fn,BonoboXObjectPOAFn fini_fn,int                epv_struct_offset
</FUNCTION>
<MACRO>
<NAME>BONOBO_X_TYPE_FUNC_FULL</NAME>
#define BONOBO_X_TYPE_FUNC_FULL(class_name, corba_name, parent, prefix)     \
GtkType                                                                       \
prefix##_get_type (void)                                                      \
{                                                                             \
	GtkType ptype;                                                        \
	static GtkType type = 0;                                              \
                                                                              \
	if (type == 0) {                                                      \
		static GtkTypeInfo info = {                                   \
			#class_name,                                          \
			sizeof (class_name),                                  \
			sizeof (class_name##Class),                           \
			(GtkClassInitFunc)prefix##_class_init,                \
			(GtkObjectInitFunc)prefix##_init,                     \
			NULL, NULL, (GtkClassInitFunc) NULL                   \
		};                                                            \
		ptype = (parent);                                             \
		type = bonobo_x_type_unique (ptype,                           \
			POA_##corba_name##__init, POA_##corba_name##__fini,   \
			GTK_STRUCT_OFFSET (class_name##Class, epv),           \
			&info);                                               \
	}                                                                     \
	return type;                                                          \
}
</MACRO>
<MACRO>
<NAME>BONOBO_X_TYPE_FUNC</NAME>
#define BONOBO_X_TYPE_FUNC(class_name, parent, prefix)                      \
GtkType                                                                       \
prefix##_get_type (void)                                                      \
{                                                                             \
	GtkType ptype;                                                        \
	static GtkType type = 0;                                              \
                                                                              \
	if (type == 0) {                                                      \
		static GtkTypeInfo info = {                                   \
			#class_name,                                          \
			sizeof (class_name),                                  \
			sizeof (class_name##Class),                           \
			(GtkClassInitFunc)prefix##_class_init,                \
			(GtkObjectInitFunc)prefix##_init,                     \
			NULL, NULL, (GtkClassInitFunc) NULL                   \
		};                                                            \
		ptype = (parent);                                             \
		type = bonobo_x_type_unique (ptype, NULL, NULL, 0, &info);    \
	}                                                                     \
	return type;                                                          \
}
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_TYPE</NAME>
#define BONOBO_PERSIST_FILE_TYPE (bonobo_persist_file_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE</NAME>
#define BONOBO_PERSIST_FILE(o)   (GTK_CHECK_CAST ((o), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFile))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_FILE_CLASS</NAME>
#define BONOBO_PERSIST_FILE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_FILE_TYPE, BonoboPersistFileClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE</NAME>
#define BONOBO_IS_PERSIST_FILE(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_FILE_CLASS</NAME>
#define BONOBO_IS_PERSIST_FILE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_FILE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistFilePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistFileIOFn</NAME>
<RETURNS>int </RETURNS>
BonoboPersistFile *pf,
				      const CORBA_char  *filename,
				      CORBA_Environment *ev,
				      void              *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistFile</NAME>
struct BonoboPersistFile {
	BonoboPersist persist;

	gboolean     is_dirty;
	char *filename;

	/*
	 * For the sample routines, NULL if we use the ::save and ::load
	 * methods from the class
	 */
	BonoboPersistFileIOFn  save_fn;
	BonoboPersistFileIOFn  load_fn;
	void *closure;

	BonoboPersistFilePrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboPersistFileClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	POA_Bonobo_PersistFile__epv epv;

	/* methods */
	int   (*load)             (BonoboPersistFile *ps,
				   const CORBA_char  *filename,
				   CORBA_Environment *ev);

	int   (*save)             (BonoboPersistFile *ps,
				   const CORBA_char  *filename,
				   CORBA_Environment *ev);

	char *(*get_current_file) (BonoboPersistFile *ps,
				   CORBA_Environment *ev);

} BonoboPersistFileClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_persist_file_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistFile   *ps,gboolean             dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_new</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void                 *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_file_construct</NAME>
<RETURNS>BonoboPersistFile  *</RETURNS>
BonoboPersistFile    *ps,BonoboPersistFileIOFn load_fn,BonoboPersistFileIOFn save_fn,void                 *closure
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_TYPE</NAME>
#define BONOBO_PERSIST_STREAM_TYPE        (bonobo_persist_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM</NAME>
#define BONOBO_PERSIST_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStream))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_PERSIST_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_STREAM_TYPE, BonoboPersistStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM</NAME>
#define BONOBO_IS_PERSIST_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_STREAM_CLASS</NAME>
#define BONOBO_IS_PERSIST_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_STREAM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistStreamPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboPersistStreamIOFn</NAME>
<RETURNS>void </RETURNS>
BonoboPersistStream         *ps,
					  const Bonobo_Stream         stream,
					  Bonobo_Persist_ContentType  type,
					  void                       *closure,
					  CORBA_Environment          *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamMaxFn</NAME>
<RETURNS>CORBA_long </RETURNS>
BonoboPersistStream *ps,
						void                *closure,
						CORBA_Environment   *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPersistStreamTypesFn</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList *</RETURNS>
BonoboPersistStream *ps,
									void                *closure,
									CORBA_Environment   *ev
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPersistStream</NAME>
struct BonoboPersistStream {
	BonoboPersist persist;

	gboolean     is_dirty;

	/*
	 * For the sample routines, NULL if we use the
	 * methods from the class
	 */
	BonoboPersistStreamIOFn     save_fn;
	BonoboPersistStreamIOFn     load_fn;
	BonoboPersistStreamMaxFn    max_fn;
	BonoboPersistStreamTypesFn  types_fn;
	
	void                       *closure;

	BonoboPersistStreamPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboPersistStreamClass</NAME>
typedef struct {
	BonoboPersistClass parent_class;

	POA_Bonobo_PersistStream__epv epv;

	/* methods */
	void       (*load)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	void       (*save)         (BonoboPersistStream        *ps,
				    Bonobo_Stream              stream,
				    Bonobo_Persist_ContentType type,
				    CORBA_Environment          *ev);
	CORBA_long (*get_size_max) (BonoboPersistStream *ps,
				    CORBA_Environment   *ev);
	Bonobo_Persist_ContentTypeList * (*get_content_types) (BonoboPersistStream *ps,
							       CORBA_Environment   *ev);

} BonoboPersistStreamClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_persist_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboPersistStream       *ps,gboolean                   dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_new</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStreamIOFn    load_fn,BonoboPersistStreamIOFn    save_fn,BonoboPersistStreamMaxFn   max_fn,BonoboPersistStreamTypesFn types_fn,void                      *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_stream_construct</NAME>
<RETURNS>BonoboPersistStream  *</RETURNS>
BonoboPersistStream       *ps,BonoboPersistStreamIOFn    load_fn,BonoboPersistStreamIOFn    save_fn,BonoboPersistStreamMaxFn   max_fn,BonoboPersistStreamTypesFn types_fn,void                      *closure
</FUNCTION>
<MACRO>
<NAME>BONOBO_PERSIST_TYPE</NAME>
#define BONOBO_PERSIST_TYPE        (bonobo_persist_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST</NAME>
#define BONOBO_PERSIST(o)          (GTK_CHECK_CAST ((o), BONOBO_PERSIST_TYPE, BonoboPersist))
</MACRO>
<MACRO>
<NAME>BONOBO_PERSIST_CLASS</NAME>
#define BONOBO_PERSIST_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PERSIST_TYPE, BonoboPersistClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST</NAME>
#define BONOBO_IS_PERSIST(o)       (GTK_CHECK_TYPE ((o), BONOBO_PERSIST_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PERSIST_CLASS</NAME>
#define BONOBO_IS_PERSIST_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PERSIST_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboPersistPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboPersist</NAME>
typedef struct {
	BonoboXObject object;

	BonoboPersistPrivate *priv;
} BonoboPersist;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboPersistClass</NAME>
typedef struct {
	BonoboXObjectClass      parent_class;

	POA_Bonobo_Persist__epv epv;

	Bonobo_Persist_ContentTypeList *
	                      (*get_content_types) (BonoboPersist     *persist,
						    CORBA_Environment *ev);
} BonoboPersistClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_persist_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_persist_generate_content_types</NAME>
<RETURNS>Bonobo_Persist_ContentTypeList  *</RETURNS>
int num,...
</FUNCTION>
<MACRO>
<NAME>BONOBO_PLUG</NAME>
#define BONOBO_PLUG(obj)          GTK_CHECK_CAST (obj, bonobo_plug_get_type (), BonoboPlug)
</MACRO>
<MACRO>
<NAME>BONOBO_PLUG_CLASS</NAME>
#define BONOBO_PLUG_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, bonobo_plug_get_type (), BonoboPlugClass)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PLUG</NAME>
#define BONOBO_IS_PLUG(obj)       GTK_CHECK_TYPE (obj, bonobo_plug_get_type ())
</MACRO>
<TYPEDEF>
<NAME>BonoboPlug</NAME>
typedef struct {
	GtkWindow window;

	GdkWindow *socket_window;
	gint same_app;
} BonoboPlug;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboPlugClass</NAME>
typedef struct {
	GtkWindowClass parent_class;
} BonoboPlugClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_plug_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_plug_construct</NAME>
<RETURNS>void  </RETURNS>
BonoboPlug *plug, guint32 socket_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_plug_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
guint32 socket_id
</FUNCTION>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_TYPE</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_TYPE        (bonobo_progressive_data_sink_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK(o)          (GTK_CHECK_CAST ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSink))
</MACRO>
<MACRO>
<NAME>BONOBO_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_PROGRESSIVE_DATA_SINK_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE, BonoboProgressiveDataSinkClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS</NAME>
#define BONOBO_IS_PROGRESSIVE_DATA_SINK_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROGRESSIVE_DATA_SINK_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboProgressiveDataSinkPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkStartFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkEndFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink, void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkAddDataFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const Bonobo_ProgressiveDataSink_iobuf *buffer,
						  void *closure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboProgressiveDataSinkSetSizeFn</NAME>
<RETURNS>int </RETURNS>
BonoboProgressiveDataSink *psink,
						  const CORBA_long count, void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboProgressiveDataSink</NAME>
struct BonoboProgressiveDataSink {
	BonoboXObject object;

	/*
	 * These are the callbacks the user can set.  If we use the
	 * default class methods, then these are NULL.
	 */
	BonoboProgressiveDataSinkStartFn start_fn;
	BonoboProgressiveDataSinkEndFn end_fn;
	BonoboProgressiveDataSinkAddDataFn add_data_fn;
	BonoboProgressiveDataSinkSetSizeFn set_size_fn;

	void *closure;

	BonoboProgressiveDataSinkPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboProgressiveDataSinkClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_ProgressiveDataSink__epv epv;

	/* Methods. */
	int (*start_fn)    (BonoboProgressiveDataSink *psink);
	int (*end_fn)      (BonoboProgressiveDataSink *psink);
	int (*add_data_fn) (BonoboProgressiveDataSink *psink,
			    const Bonobo_ProgressiveDataSink_iobuf *buffer);
	int (*set_size_fn) (BonoboProgressiveDataSink *psink,
			    const CORBA_long count);
			 
} BonoboProgressiveDataSinkClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_new</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSinkStartFn   start_fn,BonoboProgressiveDataSinkEndFn     end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void                              *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_progressive_data_sink_construct</NAME>
<RETURNS>BonoboProgressiveDataSink  *</RETURNS>
BonoboProgressiveDataSink         *psink,BonoboProgressiveDataSinkStartFn   start_fn,BonoboProgressiveDataSinkEndFn     end_fn,BonoboProgressiveDataSinkAddDataFn add_data_fn,BonoboProgressiveDataSinkSetSizeFn set_size_fn,void                              *closure
</FUNCTION>
<STRUCT>
<NAME>BonoboPropertyBagPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyBag</NAME>
</STRUCT>
<ENUM>
<NAME>BonoboPropertyFlags</NAME>
typedef enum {
	BONOBO_PROPERTY_UNSTORED        = 1,
	BONOBO_PROPERTY_READABLE        = 2,
	BONOBO_PROPERTY_WRITEABLE       = 4,
	BONOBO_PROPERTY_USE_DEFAULT_OPT = 8,
	BONOBO_PROPERTY_NO_LISTENING    = 16
} BonoboPropertyFlags;
</ENUM>
<USER_FUNCTION>
<NAME>BonoboPropertyGetFn</NAME>
<RETURNS>void </RETURNS>
BonoboPropertyBag *bag,
				     BonoboArg         *arg,
				     guint              arg_id,
				     CORBA_Environment *ev,
				     gpointer           user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboPropertySetFn</NAME>
<RETURNS>void </RETURNS>
BonoboPropertyBag *bag,
				     const BonoboArg   *arg,
				     guint              arg_id,
				     CORBA_Environment *ev,
				     gpointer           user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPropertyBag</NAME>
struct BonoboPropertyBag {
	BonoboXObject             parent;
	BonoboPropertyBagPrivate *priv;
	BonoboEventSource        *es;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboPropertyBagClass</NAME>
typedef struct {
	BonoboXObjectClass        parent;

	POA_Bonobo_PropertyBag__epv epv;
} BonoboPropertyBagClass;
</TYPEDEF>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_TYPE</NAME>
#define BONOBO_PROPERTY_BAG_TYPE                (bonobo_property_bag_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG</NAME>
#define BONOBO_PROPERTY_BAG(o)		        (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_BAG_TYPE, BonoboPropertyBag))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_BAG_CLASS</NAME>
#define BONOBO_PROPERTY_BAG_CLASS(k)		(GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_BAG_TYPE, BonoboPropertyBagClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG</NAME>
#define BONOBO_IS_PROPERTY_BAG(o)		(GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_BAG_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_BAG_CLASS</NAME>
#define BONOBO_IS_PROPERTY_BAG_CLASS(k)		(GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_BAG_TYPE))
</MACRO>
<FUNCTION>
<NAME>bonobo_property_bag_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_new</NAME>
<RETURNS>BonoboPropertyBag 	 *</RETURNS>
BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_new_full</NAME>
<RETURNS>BonoboPropertyBag 	 *</RETURNS>
BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,BonoboEventSource  *event_source,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_construct</NAME>
<RETURNS>BonoboPropertyBag         *</RETURNS>
BonoboPropertyBag   *pb,BonoboPropertyGetFn  get_prop,BonoboPropertySetFn  set_prop,BonoboEventSource   *event_source,gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,const char         *name,int                 idx,BonoboArgType       type,BonoboArg          *default_value,const char         *docstring,BonoboPropertyFlags flags
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_full</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,const char         *name,int                 idx,BonoboArgType       type,BonoboArg          *default_value,const char         *docstring,BonoboPropertyFlags flags,BonoboPropertyGetFn get_prop,BonoboPropertySetFn set_prop,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_add_gtk_args</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag  *pb,GtkObject          *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_property_type</NAME>
<RETURNS>BonoboArgType  </RETURNS>
BonoboPropertyBag *pb,const char *name,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_set_value</NAME>
<RETURNS>void 	</RETURNS>
BonoboPropertyBag *pb,const char        *name,const BonoboArg   *value,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_value</NAME>
<RETURNS>BonoboArg                 *</RETURNS>
BonoboPropertyBag *pb,const char *name,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_default</NAME>
<RETURNS>BonoboArg                 *</RETURNS>
BonoboPropertyBag *pb,const char *name,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_docstring</NAME>
<RETURNS>const char 	         *</RETURNS>
BonoboPropertyBag *pb,const char *name,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_flags</NAME>
<RETURNS>const BonoboPropertyFlags  </RETURNS>
BonoboPropertyBag *pb,const char *name,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_has_property</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboPropertyBag *pb,const char *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_notify_listeners</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyBag *pb,const char        *name,const BonoboArg   *new_value,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_get_prop_list</NAME>
<RETURNS>GList                     *</RETURNS>
BonoboPropertyBag *pb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_properties</NAME>
<RETURNS>GList 			*</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_free_properties</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_names</NAME>
<RETURNS>GList 			*</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property</NAME>
<RETURNS>Bonobo_Property 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *property_name,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_persist</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,Bonobo_Stream            stream,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_depersist</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,Bonobo_Stream            stream,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_setv</NAME>
<RETURNS>char                     *</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_getv</NAME>
<RETURNS>char                     *</RETURNS>
Bonobo_PropertyBag       pb,CORBA_Environment       *ev,const char              *first_arg,va_list                  var_args
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_property_type</NAME>
<RETURNS>CORBA_TypeCode  </RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gint</NAME>
<RETURNS>gint 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_glong</NAME>
<RETURNS>glong 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_string</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_value_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gboolean</NAME>
<RETURNS>gboolean 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gint</NAME>
<RETURNS>gint 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_glong</NAME>
<RETURNS>glong 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gfloat</NAME>
<RETURNS>gfloat 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_gdouble</NAME>
<RETURNS>gdouble 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_string</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_default_any</NAME>
<RETURNS>BonoboArg 		*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gboolean</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gboolean                value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gint</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gint                     value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_glong</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,glong                    value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gfloat</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gfloat                   value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_gdouble</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,gdouble                  value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_string</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,const char              *value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_set_value_any</NAME>
<RETURNS>void 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,BonoboArg               *value,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_docstring</NAME>
<RETURNS>char 			*</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_client_get_flags</NAME>
<RETURNS>BonoboPropertyFlags 	</RETURNS>
Bonobo_PropertyBag       pb,const char              *propname,CORBA_Environment       *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_xml_encode_any</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode      *opt_parent,const CORBA_any         *any,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_bag_xml_decode_any</NAME>
<RETURNS>CORBA_any     *</RETURNS>
BonoboUINode      *node,CORBA_Environment *ev
</FUNCTION>
<STRUCT>
<NAME>BonoboPropertyControl</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboPropertyControlPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_PROPERTY_CONTROL_CHANGED</NAME>
#define BONOBO_PROPERTY_CONTROL_CHANGED "Bonobo::PropertyControl_changed"
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_CONTROL_TYPE</NAME>
#define BONOBO_PROPERTY_CONTROL_TYPE        (bonobo_property_control_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_CONTROL</NAME>
#define BONOBO_PROPERTY_CONTROL(o)          (GTK_CHECK_CAST ((o), BONOBO_PROPERTY_CONTROL_TYPE, BonoboPropertyControl))
</MACRO>
<MACRO>
<NAME>BONOBO_PROPERTY_CONTROL_CLASS</NAME>
#define BONOBO_PROPERTY_CONTROL_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PROPERTY_CONTROL_TYPE, BonoboPropertyControlClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_CONTROL</NAME>
#define BONOBO_IS_PROPERTY_CONTROL(o)       (GTK_CHECK_TYPE ((o), BONOBO_PROPERTY_CONTROL_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PROPERTY_CONTROL_CLASS</NAME>
#define BONOBO_IS_PROPERTY_CONTROL_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PROPERTY_CONTROL_TYPE))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboPropertyControlGetControlFn</NAME>
<RETURNS>BonoboControl *</RETURNS>
BonoboPropertyControl *control,
							      int page_number,
							      void *closure
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboPropertyControl</NAME>
struct BonoboPropertyControl {
        BonoboXObject		object;

	BonoboPropertyControlPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboPropertyControlClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_PropertyControl__epv epv;

	void (* action) (BonoboPropertyControl *property_control, 
			 Bonobo_PropertyControl_Action action);
} BonoboPropertyControlClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_property_control_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_control_construct</NAME>
<RETURNS>BonoboPropertyControl  *</RETURNS>
BonoboPropertyControl *property_control,BonoboEventSource     *event_source,BonoboPropertyControlGetControlFn get_fn,int                    num_pages,void                  *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_control_new_full</NAME>
<RETURNS>BonoboPropertyControl  *</RETURNS>
BonoboPropertyControlGetControlFn get_fn,int                    num_pages,BonoboEventSource     *event_source,void                  *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_control_new</NAME>
<RETURNS>BonoboPropertyControl  *</RETURNS>
BonoboPropertyControlGetControlFn get_fn,int                    num_pages,void                  *closure
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_control_changed</NAME>
<RETURNS>void  </RETURNS>
BonoboPropertyControl *property_control,CORBA_Environment     *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_property_control_get_event_source</NAME>
<RETURNS>BonoboEventSource  *</RETURNS>
BonoboPropertyControl *property_control
</FUNCTION>
<MACRO>
<NAME>BONOBO_SELECTOR</NAME>
#define BONOBO_SELECTOR(obj)		GTK_CHECK_CAST(obj, bonobo_selector_get_type (), BonoboSelector)
</MACRO>
<MACRO>
<NAME>BONOBO_SELECTOR_CLASS</NAME>
#define BONOBO_SELECTOR_CLASS(klass)	GTK_CHECK_CLASS_CAST (klass, bonobo_selector_get_type (), BonoboSelectorClass)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_SELECTOR</NAME>
#define BONOBO_IS_SELECTOR(obj)		GTK_CHECK_TYPE (obj, bonobo_selector_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboSelectorPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboSelector</NAME>
typedef struct {
	GnomeDialog dialog;

	BonoboSelectorPrivate *priv;
} BonoboSelector;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboSelectorClass</NAME>
typedef struct {
	GnomeDialogClass parent_class;
	
	void (* ok)	(BonoboSelector *sel);
	void (* cancel)	(BonoboSelector *sel);
} BonoboSelectorClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_selector_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_construct</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboSelector       *sel,const gchar          *title,BonoboSelectorWidget *selector
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_id</NAME>
<RETURNS>gchar 	  *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_name</NAME>
<RETURNS>gchar      *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_get_selected_description</NAME>
<RETURNS>gchar      *</RETURNS>
BonoboSelector *sel
</FUNCTION>
<FUNCTION>
<NAME>bonobo_selector_select_id</NAME>
<RETURNS>gchar 	  *</RETURNS>
const gchar *title,const gchar **interfaces_required
</FUNCTION>
<MACRO>
<NAME>BONOBO_SOCKET</NAME>
#define BONOBO_SOCKET(obj)          GTK_CHECK_CAST (obj, bonobo_socket_get_type (), BonoboSocket)
</MACRO>
<MACRO>
<NAME>BONOBO_SOCKET_CLASS</NAME>
#define BONOBO_SOCKET_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, bonobo_socket_get_type (), BonoboSocketClass)
</MACRO>
<MACRO>
<NAME>BONOBO_IS_SOCKET</NAME>
#define BONOBO_IS_SOCKET(obj)       GTK_CHECK_TYPE (obj, bonobo_socket_get_type ())
</MACRO>
<STRUCT>
<NAME>BonoboSocketPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboSocket</NAME>
typedef struct {
	GtkContainer container;

	BonoboSocketPrivate *priv;
} BonoboSocket;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboSocketClass</NAME>
typedef struct {
	GtkContainerClass parent_class;
} BonoboSocketClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_socket_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_socket_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_socket_set_control_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboSocket       *socket,BonoboControlFrame *frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_socket_steal</NAME>
<RETURNS>void  </RETURNS>
BonoboSocket    *socket,guint32          wid
</FUNCTION>
<MACRO>
<NAME>BONOBO_STORAGE_VERSION</NAME>
#define BONOBO_STORAGE_VERSION "1.0"
</MACRO>
<STRUCT>
<NAME>StoragePlugin</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>StoragePluginInitFn</NAME>
<RETURNS>gint </RETURNS>
StoragePlugin *plugin
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboStorageOpenFn</NAME>
<RETURNS>BonoboStorage *</RETURNS>
const char *path, 
					       gint flags, 
					       gint mode, 
					       CORBA_Environment *ev
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboStreamOpenFn</NAME>
<RETURNS>BonoboStream *</RETURNS>
const char *path, 
					       gint flags, 
					       gint mode,
					       CORBA_Environment *ev
</USER_FUNCTION>
<STRUCT>
<NAME>StoragePlugin</NAME>
struct StoragePlugin {
	/* public, read only */
	gchar               *filename;     
	gchar               *name;         /* efs, file */
	gchar               *description;
	gchar               *version;
	BonoboStorageOpenFn  storage_open;
	BonoboStreamOpenFn   stream_open;
	/* private */
	GModule             *handle;
};
</STRUCT>
<VARIABLE>
<NAME>storage_plugin_list</NAME>
extern GList *storage_plugin_list;
</VARIABLE>
<FUNCTION>
<NAME>init_storage_plugin</NAME>
<RETURNS>gint  </RETURNS>
StoragePlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_load_plugins</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_plugin_find</NAME>
<RETURNS>StoragePlugin  *</RETURNS>
const gchar *name
</FUNCTION>
<MACRO>
<NAME>BONOBO_STORAGE_TYPE</NAME>
#define BONOBO_STORAGE_TYPE        (bonobo_storage_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE</NAME>
#define BONOBO_STORAGE(o)          (GTK_CHECK_CAST ((o), BONOBO_STORAGE_TYPE, BonoboStorage))
</MACRO>
<MACRO>
<NAME>BONOBO_STORAGE_CLASS</NAME>
#define BONOBO_STORAGE_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STORAGE_TYPE, BonoboStorageClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE</NAME>
#define BONOBO_IS_STORAGE(o)       (GTK_CHECK_TYPE ((o), BONOBO_STORAGE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STORAGE_CLASS</NAME>
#define BONOBO_IS_STORAGE_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STORAGE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStoragePrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboStorage</NAME>
typedef struct {
        BonoboXObject object;

	BonoboStoragePrivate *priv;
} BonoboStorage;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboStorageClass</NAME>
typedef struct {
	BonoboXObjectClass parent_class;

	POA_Bonobo_Storage__epv epv;

	/* virtual methods */
	Bonobo_StorageInfo *(*get_info) (BonoboStorage *storage,
					 const CORBA_char *path,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void          (*set_info)       (BonoboStorage *storage,
					 const CORBA_char *path,
					 const Bonobo_StorageInfo * info,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	BonoboStream  *(*open_stream)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_Storage_OpenMode, 
					 CORBA_Environment *ev);
	BonoboStorage *(*open_storage)  (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_Storage_OpenMode, 
					 CORBA_Environment *ev);
	void         (*copy_to)         (BonoboStorage *storage, 
					 Bonobo_Storage target,
					 CORBA_Environment *ev);
	void         (*rename)          (BonoboStorage *storage,
					 const CORBA_char *path_name,
					 const CORBA_char *new_path_name,
					 CORBA_Environment *ev);
	void         (*commit)          (BonoboStorage *storage,
					 CORBA_Environment *ev);
	void         (*revert)          (BonoboStorage *storage,
					 CORBA_Environment *ev);
	Bonobo_Storage_DirectoryList *
	             (*list_contents)   (BonoboStorage *storage,
					 const CORBA_char *path,
					 Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void         (*erase)           (BonoboStorage *storage,
                                         const CORBA_char *path,
                                         CORBA_Environment *ev);
} BonoboStorageClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_storage_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_open</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *driver,const char *path,gint flags,gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_open_full</NAME>
<RETURNS>BonoboStorage    *</RETURNS>
const char *driver,const char *path,gint flags,gint mode,CORBA_Environment *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_copy_to</NAME>
<RETURNS>void  </RETURNS>
Bonobo_Storage src,Bonobo_Storage dest,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_storage_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStorage *storage,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_write_class_id</NAME>
<RETURNS>void  </RETURNS>
BonoboStream *stream,char *class_id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const void         *buffer,const size_t        size,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_read</NAME>
<RETURNS>guint8     *</RETURNS>
const Bonobo_Stream stream,const size_t        size,CORBA_long         *length_read,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_write_string</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const char         *str,const gboolean      terminate,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_printf</NAME>
<RETURNS>void  </RETURNS>
const Bonobo_Stream stream,const gboolean      terminate,CORBA_Environment  *ev,const char         *fmt, ...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_read_string</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,char              **str,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_client_get_length</NAME>
<RETURNS>CORBA_long  </RETURNS>
const Bonobo_Stream stream,CORBA_Environment  *ev
</FUNCTION>
<STRUCT>
<NAME>BonoboStreamMem</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStreamMemPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboStorageMem</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_STREAM_MEM_TYPE</NAME>
#define BONOBO_STREAM_MEM_TYPE        (bonobo_stream_mem_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_MEM</NAME>
#define BONOBO_STREAM_MEM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_MEM_TYPE, BonoboStreamMem))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_MEM_CLASS</NAME>
#define BONOBO_STREAM_MEM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_MEM_TYPE, BonoboStreamMemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_MEM</NAME>
#define BONOBO_IS_STREAM_MEM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_MEM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_MEM_CLASS</NAME>
#define BONOBO_IS_STREAM_MEM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_MEM_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboStreamMem</NAME>
struct BonoboStreamMem {
	BonoboStream  stream;

	char        *buffer;
	size_t       size;
	long         pos;
	gboolean     read_only;
	gboolean     resizable;

	BonoboStreamMemPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboStreamMemClass</NAME>
typedef struct {
	BonoboStreamClass parent_class;
	char           *(*get_buffer) (BonoboStreamMem *stream_mem);
	size_t          (*get_size)   (BonoboStreamMem *stream_mem);
} BonoboStreamMemClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_stream_mem_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_construct</NAME>
<RETURNS>BonoboStreamMem  *</RETURNS>
BonoboStreamMem  *stream_mem,Bonobo_Stream     corba_stream,const char       *buffer,size_t            size,gboolean          read_only,gboolean          resizable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_create</NAME>
<RETURNS>BonoboStream     *</RETURNS>
const char       *buffer,size_t            size,gboolean          read_only,gboolean          resizable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_get_buffer</NAME>
<RETURNS>const char       *</RETURNS>
BonoboStreamMem  *stream_mem
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_mem_get_size</NAME>
<RETURNS>size_t  </RETURNS>
BonoboStreamMem  *stream_mem
</FUNCTION>
<MACRO>
<NAME>BONOBO_IO_DRIVER_FS</NAME>
#define BONOBO_IO_DRIVER_FS  "fs"
</MACRO>
<MACRO>
<NAME>BONOBO_IO_DRIVER_EFS</NAME>
#define BONOBO_IO_DRIVER_EFS "efs"
</MACRO>
<MACRO>
<NAME>BONOBO_IO_DRIVER_VFS</NAME>
#define BONOBO_IO_DRIVER_VFS "vfs"
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_TYPE</NAME>
#define BONOBO_STREAM_TYPE        (bonobo_stream_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM</NAME>
#define BONOBO_STREAM(o)          (GTK_CHECK_CAST ((o), BONOBO_STREAM_TYPE, BonoboStream))
</MACRO>
<MACRO>
<NAME>BONOBO_STREAM_CLASS</NAME>
#define BONOBO_STREAM_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_STREAM_TYPE, BonoboStreamClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM</NAME>
#define BONOBO_IS_STREAM(o)       (GTK_CHECK_TYPE ((o), BONOBO_STREAM_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_STREAM_CLASS</NAME>
#define BONOBO_IS_STREAM_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_STREAM_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboStream</NAME>
typedef struct {
        BonoboObject object;
} BonoboStream;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboStreamClass</NAME>
typedef struct {
	BonoboObjectClass parent_class;

	/*
	 * virtual methods
	 */

	Bonobo_StorageInfo *(*get_info) (BonoboStream *stream,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void          (*set_info)       (BonoboStream *stream,
					 const Bonobo_StorageInfo *info,
					 const Bonobo_StorageInfoFields mask,
					 CORBA_Environment *ev);
	void          (*write)          (BonoboStream *stream,
					 const Bonobo_Stream_iobuf *buffer,
					 CORBA_Environment *ev);
	void          (*read)           (BonoboStream *stream, 
					 CORBA_long count,
					 Bonobo_Stream_iobuf **buffer,
					 CORBA_Environment *ev);
        CORBA_long    (*seek)           (BonoboStream *stream,
					 CORBA_long offset, 
					 Bonobo_Stream_SeekType whence,
					 CORBA_Environment *ev);
        void          (*truncate)       (BonoboStream *stream,
					 const CORBA_long new_size, 
					 CORBA_Environment *ev);
	void          (*copy_to)        (BonoboStream *stream,
					 const CORBA_char * dest,
					 const CORBA_long bytes,
					 CORBA_long *read,
					 CORBA_long *written,
					 CORBA_Environment *ev);
        void          (*commit)         (BonoboStream *stream,
					 CORBA_Environment *ev);
        void          (*revert)         (BonoboStream *stream,
					 CORBA_Environment *ev);
} BonoboStreamClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_stream_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_get_epv</NAME>
<RETURNS>POA_Bonobo_Stream__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_corba_object_create</NAME>
<RETURNS>Bonobo_Stream  </RETURNS>
BonoboObject *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_open</NAME>
<RETURNS>BonoboStream            *</RETURNS>
const char *driver,const char *path,gint flags,gint mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_stream_open_full</NAME>
<RETURNS>BonoboStream            *</RETURNS>
const char *driver,const char *path,gint flags,gint mode,CORBA_Environment *opt_ev
</FUNCTION>
<MACRO>
<NAME>BONOBO_TRANSIENT_TYPE</NAME>
#define BONOBO_TRANSIENT_TYPE        (bonobo_transient_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_TRANSIENT</NAME>
#define BONOBO_TRANSIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_TRANSIENT_TYPE, BonoboTransient))
</MACRO>
<MACRO>
<NAME>BONOBO_TRANSIENT_CLASS</NAME>
#define BONOBO_TRANSIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_TRANSIENT_TYPE, BonoboTransientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_TRANSIENT</NAME>
#define BONOBO_IS_TRANSIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_TRANSIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_TRANSIENT_CLASS</NAME>
#define BONOBO_IS_TRANSIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_TRANSIENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboTransientPriv</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboTransient</NAME>
typedef struct {
	GtkObject parent;

	BonoboTransientPriv *priv;
} BonoboTransient;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboTransientClass</NAME>
typedef struct {
	GtkObjectClass parent_class;
} BonoboTransientClass;
</TYPEDEF>
<USER_FUNCTION>
<NAME>BonoboTransientServantNew</NAME>
<RETURNS>PortableServer_Servant </RETURNS>
PortableServer_POA, BonoboTransient *, char *name, void *data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboTransientServantDestroy</NAME>
<RETURNS>void </RETURNS>
PortableServer_Servant servant, void *data
</USER_FUNCTION>
<FUNCTION>
<NAME>bonobo_transient_new</NAME>
<RETURNS>BonoboTransient  *</RETURNS>
PortableServer_POA poa,BonoboTransientServantNew     new_servant,BonoboTransientServantDestroy destroy_servant,void *data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_transient_construct</NAME>
<RETURNS>BonoboTransient  *</RETURNS>
BonoboTransient *transient,PortableServer_POA        poa,BonoboTransientServantNew new_servant,BonoboTransientServantDestroy destroy_servant,gpointer                  data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_transient_create_objref</NAME>
<RETURNS>CORBA_Object  </RETURNS>
BonoboTransient   *transient,const char        *iface_name,const char        *name,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_transient_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_COMPONENT_TYPE</NAME>
#define BONOBO_UI_COMPONENT_TYPE        (bonobo_ui_component_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_COMPONENT</NAME>
#define BONOBO_UI_COMPONENT(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_COMPONENT_TYPE, BonoboUIComponent))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_COMPONENT_CLASS</NAME>
#define BONOBO_UI_COMPONENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_COMPONENT_TYPE, BonoboUIComponentClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_COMPONENT</NAME>
#define BONOBO_IS_UI_COMPONENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_COMPONENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_COMPONENT_CLASS</NAME>
#define BONOBO_IS_UI_COMPONENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_COMPONENT_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIComponent</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIComponentPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>BonoboUIListenerFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIComponent           *component,
				    const char                  *path,
				    Bonobo_UIComponent_EventType type,
				    const char                  *state,
				    gpointer                     user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUIVerbFn</NAME>
<RETURNS>void </RETURNS>
BonoboUIComponent           *component,
				   gpointer                     user_data,
				   const char                  *cname
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUIComponent</NAME>
struct BonoboUIComponent {
	BonoboXObject             object;
	BonoboUIComponentPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboUIComponentClass</NAME>
typedef struct {
	BonoboXObjectClass          parent_class;

	POA_Bonobo_UIComponent__epv epv;

	/* Signals */
	void (*exec_verb) (BonoboUIComponent *comp,
			   const char        *cname);

	void (*ui_event)  (BonoboUIComponent *comp,
			   const char        *path,
			   Bonobo_UIComponent_EventType type,
			   const char        *state);
	/* Virtual XML Methods */
	void (*freeze)    (BonoboUIComponent *component,
			   CORBA_Environment *opt_ev);

	void (*thaw)      (BonoboUIComponent *component,
			   CORBA_Environment *opt_ev);

	void (*xml_set)   (BonoboUIComponent *component,
			   const char        *path,
			   const char        *xml,
			   CORBA_Environment *ev);

	CORBA_char *(*xml_get) (BonoboUIComponent *component,
				const char        *path,
				gboolean           recurse,
				CORBA_Environment *ev);

	void (*xml_rm)    (BonoboUIComponent *component,
			   const char        *path,
			   CORBA_Environment *ev);

	void (*set_prop)  (BonoboUIComponent *component,
			   const char        *path,
			   const char        *prop,
			   const char        *value,
			   CORBA_Environment *opt_ev);
	
	gchar *(*get_prop) (BonoboUIComponent *component,
			    const char        *path,
			    const char        *prop,
			    CORBA_Environment *opt_ev);

	gboolean (*exists) (BonoboUIComponent *component,
			    const char        *path,
			    CORBA_Environment *ev);
	

	gpointer            dummy;
} BonoboUIComponentClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_component_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_construct</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
BonoboUIComponent  *component,const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_new</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_new_default</NAME>
<RETURNS>BonoboUIComponent  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_name</NAME>
<RETURNS>const char         *</RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,Bonobo_UIContainer  container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_unset_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboUIComponent  *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname,BonoboUIVerbFn      fn,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_full</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname,BonoboUIVerbFn      fn,gpointer            user_data,GDestroyNotify      destroy_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_verb</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_verb_by_func</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerbFn      fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_verb_by_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *id,BonoboUIListenerFn  fn,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_listener_full</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *id,BonoboUIListenerFn  fn,gpointer            user_data,GDestroyNotify      destroy_fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_listener</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *cname
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_listener_by_func</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIListenerFn  fn
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_remove_listener_by_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,gpointer            user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *xml,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_translate</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *xml,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_tree</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,BonoboUINode       *node,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_rm</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_path_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get</NAME>
<RETURNS>CORBA_char         *</RETURNS>
BonoboUIComponent  *component,const char         *path,gboolean            recurse,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_tree</NAME>
<RETURNS>BonoboUINode       *</RETURNS>
BonoboUIComponent  *component,const char         *path,gboolean            recurse,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_object_set</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,Bonobo_Unknown      control,CORBA_Environment  *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_object_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboUIComponent  *component,const char         *path,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_prop</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *prop,const char         *value,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_get_prop</NAME>
<RETURNS>gchar              *</RETURNS>
BonoboUIComponent  *component,const char         *path,const char         *prop,CORBA_Environment  *opt_ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_set_status</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,const char         *text,CORBA_Environment  *opt_ev
</FUNCTION>
<TYPEDEF>
<NAME>BonoboUIVerb</NAME>
typedef struct {
	char          *cname;
	BonoboUIVerbFn cb;
	gpointer       user_data;
	gpointer       dummy;
} BonoboUIVerb;
</TYPEDEF>
<MACRO>
<NAME>BONOBO_UI_VERB</NAME>
#define BONOBO_UI_VERB(name,cb)                  { (name), (cb), NULL   }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_VERB_DATA</NAME>
#define BONOBO_UI_VERB_DATA(name,cb,data)        { (name), (cb), (data) }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_UNSAFE_VERB</NAME>
#define BONOBO_UI_UNSAFE_VERB(name,cb)           { (name), ((BonoboUIVerbFn)(cb)), NULL   }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_UNSAFE_VERB_DATA</NAME>
#define BONOBO_UI_UNSAFE_VERB_DATA(name,cb,data) { (name), ((BonoboUIVerbFn)(cb)), (data) }
</MACRO>
<MACRO>
<NAME>BONOBO_UI_VERB_END</NAME>
#define BONOBO_UI_VERB_END                       { NULL, NULL, NULL }
</MACRO>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_list</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerb       *list
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_component_add_verb_list_with_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent  *component,BonoboUIVerb       *list,gpointer            user_data
</FUNCTION>
<MACRO>
<NAME>BONOBO_UI_CONTAINER_TYPE</NAME>
#define BONOBO_UI_CONTAINER_TYPE        (bonobo_ui_container_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_CONTAINER</NAME>
#define BONOBO_UI_CONTAINER(o)          (GTK_CHECK_CAST ((o), BONOBO_UI_CONTAINER_TYPE, BonoboUIContainer))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_CONTAINER_CLASS</NAME>
#define BONOBO_UI_CONTAINER_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_UI_CONTAINER_TYPE, BonoboUIContainerClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_CONTAINER</NAME>
#define BONOBO_IS_UI_CONTAINER(o)       (GTK_CHECK_TYPE ((o), BONOBO_UI_CONTAINER_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_CONTAINER_CLASS</NAME>
#define BONOBO_IS_UI_CONTAINER_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_UI_CONTAINER_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboUIContainerPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboUIContainer</NAME>
typedef struct {
	BonoboXObject base;

	BonoboUIContainerPrivate *priv;

	/* For backwards compatibility, strongly deprecated */
	BonoboWindow *win;
} BonoboUIContainer;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboUIContainerClass</NAME>
typedef struct {
	BonoboXObjectClass parent;

	POA_Bonobo_UIContainer__epv epv;
} BonoboUIContainerClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_container_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_construct</NAME>
<RETURNS>BonoboUIContainer            *</RETURNS>
BonoboUIContainer  *container,Bonobo_UIContainer  corba_container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_new</NAME>
<RETURNS>BonoboUIContainer            *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_set_engine</NAME>
<RETURNS>void  </RETURNS>
BonoboUIContainer  *container,BonoboUIEngine     *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_get_engine</NAME>
<RETURNS>BonoboUIEngine               *</RETURNS>
BonoboUIContainer  *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_set_win</NAME>
<RETURNS>void  </RETURNS>
BonoboUIContainer  *container,BonoboWindow       *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_container_get_win</NAME>
<RETURNS>BonoboWindow                 *</RETURNS>
BonoboUIContainer  *container
</FUNCTION>
<STRUCT>
<NAME>BonoboUIEngine</NAME>
</STRUCT>
<ENUM>
<NAME>BonoboUIError</NAME>
typedef enum {
	BONOBO_UI_ERROR_OK = 0,
	BONOBO_UI_ERROR_BAD_PARAM,
	BONOBO_UI_ERROR_INVALID_PATH,
	BONOBO_UI_ERROR_INVALID_XML
} BonoboUIError;
</ENUM>
<MACRO>
<NAME>BONOBO_TYPE_UI_ENGINE</NAME>
#define BONOBO_TYPE_UI_ENGINE            (bonobo_ui_engine_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_ENGINE</NAME>
#define BONOBO_UI_ENGINE(obj)            (GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_ENGINE, BonoboUIEngine))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_ENGINE_CLASS</NAME>
#define BONOBO_UI_ENGINE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_ENGINE, BonoboUIEngineClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_ENGINE</NAME>
#define BONOBO_IS_UI_ENGINE(obj)         (GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_ENGINE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_ENGINE_CLASS</NAME>
#define BONOBO_IS_UI_ENGINE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_ENGINE))
</MACRO>
<STRUCT>
<NAME>BonoboUIEnginePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUIEngine</NAME>
struct BonoboUIEngine {
	GtkObject parent;

	BonoboUIEnginePrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboUIEngineClass</NAME>
typedef struct {
	GtkObjectClass parent_class;

	/* Signals */
	void (*add_hint)      (BonoboUIEngine *engine,
			       const char     *str);
	void (*remove_hint)   (BonoboUIEngine *engine);

	void (*emit_verb_on)  (BonoboUIEngine *engine,
			       BonoboUINode   *node);

	void (*emit_event_on) (BonoboUIEngine *engine,
			       BonoboUINode   *node,
			       const char     *state);
} BonoboUIEngineClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_engine_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_construct</NAME>
<RETURNS>BonoboUIEngine  *</RETURNS>
BonoboUIEngine   *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_new</NAME>
<RETURNS>BonoboUIEngine  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_config_set_path</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine,const char     *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_config_get_path</NAME>
<RETURNS>const char    *</RETURNS>
BonoboUIEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_add_sync</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUISync     *sync
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_remove_sync</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUISync     *sync
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_get_syncs</NAME>
<RETURNS>GSList        *</RETURNS>
BonoboUIEngine   *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_update</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_update_node</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_queue_update</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,GtkWidget        *widget,BonoboUINode     *node,BonoboUINode     *cmd_node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_build_control</NAME>
<RETURNS>GtkWidget     *</RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_widget_get_node</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
GtkWidget        *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_widget_set_node</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,GtkWidget        *widget,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_prune_widget_info</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node,gboolean          save_custom
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_get_path</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUIEngine   *engine,const char       *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_dirty_tree</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_clean_tree</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_dump</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,FILE             *out,const char       *msg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_node_get_object</NAME>
<RETURNS>CORBA_Object  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_node_is_dirty</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_node_get_widget</NAME>
<RETURNS>GtkWidget     *</RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_node_get_id</NAME>
<RETURNS>const char    *</RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_get_cmd_node</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *from_node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_node_set_dirty</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node,gboolean          dirty
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_stamp_custom</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine,BonoboUINode   *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_stamp_root</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine,BonoboUINode   *node,GtkWidget      *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_add_hint</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,const char       *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_remove_hint</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_emit_verb_on</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_emit_event_on</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,BonoboUINode     *node,const char       *state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_emit_verb_on_w</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,GtkWidget        *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_emit_event_on_w</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine   *engine,GtkWidget        *widget,const char       *state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_get_attr</NAME>
<RETURNS>char          *</RETURNS>
BonoboUINode     *node,BonoboUINode     *cmd_node,const char       *attr
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_widget_attach_node</NAME>
<RETURNS>void  </RETURNS>
GtkWidget        *widget,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_deregister_dead_components</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_deregister_component_by_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine,Bonobo_Unknown  ref
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_deregister_component</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine,const char     *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_register_component</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine *engine,const char     *name,Bonobo_Unknown  component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_get_component_names</NAME>
<RETURNS>GList          *</RETURNS>
BonoboUIEngine *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_get_component</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboUIEngine *engine,const char     *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_xml_get</NAME>
<RETURNS>CORBA_char       *</RETURNS>
BonoboUIEngine   *engine,const char       *path,gboolean          node_only
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_xml_node_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIEngine   *engine,const char       *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_xml_merge_tree</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboUIEngine    *engine,const char        *path,BonoboUINode      *tree,const char        *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_xml_rm</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboUIEngine    *engine,const char        *path,const char        *by_component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_object_set</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboUIEngine   *engine,const char       *path,Bonobo_Unknown    object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_object_get</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboUIEngine    *engine,const char        *path,Bonobo_Unknown    *object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_set_ui_container</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine    *engine,BonoboObject      *ui_container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine    *engine
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_engine_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboUIEngine    *engine
</FUNCTION>
<STRUCT>
<NAME>BonoboUINode</NAME>
</STRUCT>
<FUNCTION>
<NAME>bonobo_ui_node_new</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_new_child</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *parent,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_copy</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node,gboolean      recursive
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_free</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_set_data</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,gpointer      data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_data</NAME>
<RETURNS>gpointer  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_set_attr</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,const char   *name,const char   *value
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_attr</NAME>
<RETURNS>char  *</RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_has_attr</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_remove_attr</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_add_child</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *parent,BonoboUINode *child
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_insert_before</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *sibling,BonoboUINode *prev_sibling
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_unlink</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_replace</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *old_node,BonoboUINode *new_node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_set_content</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *node,const char   *content
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_content</NAME>
<RETURNS>char          *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_next</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_prev</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_children</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_parent</NAME>
<RETURNS>BonoboUINode  *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_get_name</NAME>
<RETURNS>const char    *</RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_has_name</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUINode *node,const char   *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_transparent</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUINode *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_copy_attrs</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode *src,BonoboUINode *dest
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_free_string</NAME>
<RETURNS>void  </RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_strip</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode **node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_to_string</NAME>
<RETURNS>char  *</RETURNS>
BonoboUINode *node,gboolean      recurse
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_from_string</NAME>
<RETURNS>BonoboUINode *</RETURNS>
const char *str
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_node_from_file</NAME>
<RETURNS>BonoboUINode *</RETURNS>
const char *filename
</FUNCTION>
<STRUCT>
<NAME>BonoboUISync</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_TYPE_UI_SYNC</NAME>
#define BONOBO_TYPE_UI_SYNC            (bonobo_ui_sync_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_SYNC</NAME>
#define BONOBO_UI_SYNC(obj)            (GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_SYNC, BonoboUISync))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_SYNC_CLASS</NAME>
#define BONOBO_UI_SYNC_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_SYNC, BonoboUISyncClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_SYNC</NAME>
#define BONOBO_IS_UI_SYNC(obj)         (GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_SYNC))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_SYNC_CLASS</NAME>
#define BONOBO_IS_UI_SYNC_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_SYNC))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboUISyncStateFn</NAME>
<RETURNS>void </RETURNS>
BonoboUISync     *sync,
					     BonoboUINode     *node,
					     BonoboUINode     *cmd_node,
					     GtkWidget        *widget,
					     GtkWidget        *parent
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>BonoboUISyncBuildFn</NAME>
<RETURNS>GtkWidget *</RETURNS>
BonoboUISync     *sync,
					     BonoboUINode     *node,
					     BonoboUINode     *cmd_node,
					     int              *pos,
					     GtkWidget        *parent
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboUISyncPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboUISync</NAME>
struct BonoboUISync {
	GtkObject parent;

	BonoboUIEngine *engine;
	gboolean        is_recursive;
	gboolean        has_widgets;

	BonoboUISyncPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboUISyncClass</NAME>
typedef struct {
	GtkObjectClass parent_class;

	BonoboUISyncStateFn sync_state;
	BonoboUISyncStateFn sync_state_placeholder;
	BonoboUISyncBuildFn build;
	BonoboUISyncBuildFn build_placeholder;

	void          (*update_root)     (BonoboUISync     *sync,
					  BonoboUINode     *root);

	void          (*remove_root)     (BonoboUISync     *sync,
					  BonoboUINode     *root);

	GList        *(*get_widgets)     (BonoboUISync     *sync,
					  BonoboUINode     *node);

	void          (*state_update)    (BonoboUISync     *sync,
					  GtkWidget        *widget,
					  const char       *new_state);
	
	gboolean      (*ignore_widget)   (BonoboUISync     *sync,
					  GtkWidget        *widget);
	
	gboolean      (*can_handle)      (BonoboUISync     *sync,
					  BonoboUINode     *node);
	
        void          (*stamp_root)      (BonoboUISync     *sync);

	GtkWidget    *(*get_attached)    (BonoboUISync     *sync,
					  GtkWidget        *widget,
					  BonoboUINode     *node);
} BonoboUISyncClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_sync_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_construct</NAME>
<RETURNS>BonoboUISync  *</RETURNS>
BonoboUISync     *sync,BonoboUIEngine   *engine,gboolean          is_recursive,gboolean          has_widgets
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_is_recursive</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUISync     *sync
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_has_widgets</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUISync     *sync
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_remove_root</NAME>
<RETURNS>void  </RETURNS>
BonoboUISync     *sync,BonoboUINode     *root
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_update_root</NAME>
<RETURNS>void  </RETURNS>
BonoboUISync     *sync,BonoboUINode     *root
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUISync     *sync,BonoboUINode     *node,BonoboUINode     *cmd_node,GtkWidget        *widget,GtkWidget        *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_state_placeholder</NAME>
<RETURNS>void  </RETURNS>
BonoboUISync     *sync,BonoboUINode     *node,BonoboUINode     *cmd_node,GtkWidget        *widget,GtkWidget        *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_build</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboUISync     *sync,BonoboUINode     *node,BonoboUINode     *cmd_node,int              *pos,GtkWidget        *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_build_placeholder</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboUISync     *sync,BonoboUINode     *node,BonoboUINode     *cmd_node,int              *pos,GtkWidget        *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_ignore_widget</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUISync     *sync,GtkWidget        *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_get_widgets</NAME>
<RETURNS>GList      *</RETURNS>
BonoboUISync     *sync,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_stamp_root</NAME>
<RETURNS>void  </RETURNS>
BonoboUISync     *sync
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_can_handle</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUISync     *sync,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_get_attached</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboUISync     *sync,GtkWidget        *widget,BonoboUINode     *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_state_update</NAME>
<RETURNS>void  </RETURNS>
BonoboUISync     *sync,GtkWidget        *widget,const char       *new_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_do_show_hide</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUISync     *sync,BonoboUINode     *node,BonoboUINode     *cmd_node,GtkWidget        *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_keys_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_menu_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_status_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_sync_toolbar_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM		(bonobo_ui_toolbar_button_item_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_BUTTON_ITEM</NAME>
#define BONOBO_UI_TOOLBAR_BUTTON_ITEM(obj)		(GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM, BonoboUIToolbarButtonItem))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_BUTTON_ITEM_CLASS(klass)	(GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM, BonoboUIToolbarButtonItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM</NAME>
#define BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM(obj)		(GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_BUTTON_ITEM_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_BUTTON_ITEM))
</MACRO>
<STRUCT>
<NAME>BonoboUIToolbarButtonItemPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboUIToolbarButtonItem</NAME>
typedef struct {
	BonoboUIToolbarItem parent;

	BonoboUIToolbarButtonItemPrivate *priv;
} BonoboUIToolbarButtonItem;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboUIToolbarButtonItemClass</NAME>
typedef struct {
	BonoboUIToolbarItemClass parent_class;

	/* Virtual methods */
	void (* set_icon)       (BonoboUIToolbarButtonItem *button_item,
				 GdkPixbuf                 *icon);
	void (* set_label)      (BonoboUIToolbarButtonItem *button_item,
				 const char                *label);

	/* Signals.  */
	void (* clicked)	(BonoboUIToolbarButtonItem *toolbar_button_item);
	void (* set_want_label) (BonoboUIToolbarButtonItem *toolbar_button_item);
} BonoboUIToolbarButtonItemClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_construct</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarButtonItem *item,GtkButton                 *button_widget,GdkPixbuf                 *icon,const char                *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf                 *icon,const char                *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_set_icon</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarButtonItem *button_item,GdkPixbuf                 *icon
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_set_label</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarButtonItem *button_item,const char                *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_button_item_get_button_widget</NAME>
<RETURNS>GtkButton  *</RETURNS>
BonoboUIToolbarButtonItem *button_item
</FUNCTION>
<ENUM>
<NAME>BonoboUIToolbarIconDrawMode</NAME>
typedef enum {
        /* update struct when adding enum values */
	BONOBO_UI_TOOLBAR_ICON_SIMPLE, /* No alpha blending */
	BONOBO_UI_TOOLBAR_ICON_COLOR   /* */
} BonoboUIToolbarIconDrawMode;
</ENUM>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_ICON</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_ICON            (bonobo_ui_toolbar_icon_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ICON</NAME>
#define BONOBO_UI_TOOLBAR_ICON(obj)            (GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_ICON, BonoboUIToolbarIcon))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ICON_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_ICON_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_ICON, BonoboUIToolbarIconClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ICON</NAME>
#define BONOBO_IS_UI_TOOLBAR_ICON(obj)         (GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_ICON))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ICON_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_ICON_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), BONOBO_TYPE_UI_TOOLBAR_ICON))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ICON_GET_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_ICON_GET_CLASS(obj)  (GTK_CHECK_GET_CLASS ((obj), BONOBO_TYPE_UI_TOOLBAR_ICON, BonoboUIToolbarIconClass))
</MACRO>
<TYPEDEF>
<NAME>BonoboUIToolbarIcon</NAME>
typedef struct {
	GtkMisc misc;

        /* NOTE. In the old BonoboUIToolbarIcon, _lots_ of people were using BonoboUIToolbarIcon to
	 * load images, sucking out the pixmap field, and then not using the
	 * BonoboUIToolbarIcon as a widget at all. IF YOU DO THIS I WILL PERSONALLY
	 * KICK YOUR ASS. Use gdk_pixbuf_new_from_file(). Thank you.
	 * These are PRIVATE FIELDS which I will gratuitously change just to
	 * break your broken code.
	 *                          -  hp + jrb + quartic + Jesse Ventura + GW Bush 
	 */

	GdkPixbuf *provided_image;

        struct {
                GdkPixbuf *pixbuf;
                GdkBitmap *mask;
		gfloat saturation;
		gboolean pixelate;
        } provided[5]; /* the five states */

	GdkPixbuf *generated_scaled_image;
	GdkBitmap *generated_scaled_mask;
        
        struct {
                GdkPixbuf *pixbuf;
                GdkBitmap *mask;
        } generated[5]; /* the five states */
        
	gint width, height;
	gint alpha_threshold;

	BonoboUIToolbarIconDrawMode mode : 2;
} BonoboUIToolbarIcon;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboUIToolbarIconClass</NAME>
typedef struct {
	GtkMiscClass parent_class;
} BonoboUIToolbarIconClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_file</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar  *filename
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_file_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar  *filename,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_xpm_d</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar **xpm_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_xpm_d_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar **xpm_data,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_pixbuf</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf    *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_new_from_pixbuf_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf    *pixbuf,gint          width,gint          height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_pixbuf_size</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,gint                 width,gint                 height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_pixbuf_size</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,gint                *width,gint                *height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GdkPixbuf           *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
BonoboUIToolbarIcon *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_pixbuf_at_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GtkStateType         state,GdkPixbuf           *pixbuf,GdkBitmap           *mask
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_state_pixbufs</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GdkPixbuf           *pixbufs[5],GdkBitmap           *masks[5]
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_draw_vals</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GtkStateType         state,gfloat               saturation,gboolean             pixelate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_draw_vals</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,GtkStateType         state,gfloat              *saturation,gboolean            *pixelate
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_draw_mode</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon          *gpixmap,BonoboUIToolbarIconDrawMode   mode
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_draw_mode</NAME>
<RETURNS>BonoboUIToolbarIconDrawMode  </RETURNS>
BonoboUIToolbarIcon          *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_clear</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_set_alpha_threshold</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarIcon *gpixmap,gint                 alpha_threshold
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_icon_get_alpha_threshold</NAME>
<RETURNS>gint  </RETURNS>
BonoboUIToolbarIcon *gpixmap
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_ITEM</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_ITEM			(bonobo_ui_toolbar_item_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ITEM</NAME>
#define BONOBO_UI_TOOLBAR_ITEM(obj)			(GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_ITEM, BonoboUIToolbarItem))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_ITEM_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_ITEM_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_ITEM, BonoboUIToolbarItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ITEM</NAME>
#define BONOBO_IS_UI_TOOLBAR_ITEM(obj)			(GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_ITEM))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_ITEM_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_ITEM_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_ITEM))
</MACRO>
<ENUM>
<NAME>BonoboUIToolbarItemStyle</NAME>
typedef enum {
	BONOBO_UI_TOOLBAR_ITEM_STYLE_ICON_AND_TEXT_VERTICAL,
	BONOBO_UI_TOOLBAR_ITEM_STYLE_ICON_AND_TEXT_HORIZONTAL,
	BONOBO_UI_TOOLBAR_ITEM_STYLE_ICON_ONLY,
	BONOBO_UI_TOOLBAR_ITEM_STYLE_TEXT_ONLY
} BonoboUIToolbarItemStyle;
</ENUM>
<STRUCT>
<NAME>BonoboUIToolbarItemPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboUIToolbarItem</NAME>
typedef struct {
	GtkBin parent;

	BonoboUIToolbarItemPrivate *priv;
} BonoboUIToolbarItem;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboUIToolbarItemClass</NAME>
typedef struct {
	GtkBinClass parent_class;

	/* Virtual method */
	void (* set_state)       (BonoboUIToolbarItem     *item,
				  const char              *new_state);
	void (* set_tooltip)     (BonoboUIToolbarItem     *item,
				  GtkTooltips             *tooltips,
				  const char              *tooltip);

	/* Signals */
	void (* set_orientation) (BonoboUIToolbarItem     *item,
				  GtkOrientation           orientation);
	void (* set_style)       (BonoboUIToolbarItem     *item,
				  BonoboUIToolbarItemStyle style);
	void (* set_want_label)  (BonoboUIToolbarItem     *item,
				  gboolean                 want_label);
	void (* activate)        (BonoboUIToolbarItem     *item);
} BonoboUIToolbarItemClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_new</NAME>
<RETURNS>GtkWidget                 *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_tooltip</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,GtkTooltips              *tooltips,const char               *tooltip
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,const char               *new_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_orientation</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,GtkOrientation            orientation
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
BonoboUIToolbarItem      *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_style</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *item,BonoboUIToolbarItemStyle  style
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_style</NAME>
<RETURNS>BonoboUIToolbarItemStyle  </RETURNS>
BonoboUIToolbarItem      *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_minimum_width</NAME>
<RETURNS>void 	</RETURNS>
BonoboUIToolbarItem *item,int minimum_width
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_tooltip</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,GtkTooltips             *tooltips,const char              *tooltip
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_state</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,const char              *new_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_orientation</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,GtkOrientation           orientation
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
BonoboUIToolbarItem     *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_style</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item,BonoboUIToolbarItemStyle style
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_style</NAME>
<RETURNS>BonoboUIToolbarItemStyle  </RETURNS>
BonoboUIToolbarItem     *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_want_label</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *button_item,gboolean                  prefer_text
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_want_label</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarItem      *button_item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_expandable</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *button_item,gboolean                  expandable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_expandable</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarItem      *button_item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_set_pack_end</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem      *button_item,gboolean                  expandable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_get_pack_end</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarItem      *button_item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_item_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarItem     *item
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM</NAME>
#define BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM             (bonobo_ui_toolbar_toggle_button_item_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM</NAME>
#define BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM(obj)             (GTK_CHECK_CAST ((obj), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM, BonoboUIToolbarToggleButtonItem))
</MACRO>
<MACRO>
<NAME>BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS(klass)     (GTK_CHECK_CLASS_CAST ((klass), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM, BonoboUIToolbarToggleButtonItemClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM</NAME>
#define BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM(obj)          (GTK_CHECK_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS</NAME>
#define BONOBO_IS_UI_TOOLBAR_TOGGLE_BUTTON_ITEM_CLASS(klass)  (GTK_CHECK_CLASS_TYPE ((obj), BONOBO_TYPE_UI_TOOLBAR_TOGGLE_BUTTON_ITEM))
</MACRO>
<STRUCT>
<NAME>BonoboUIToolbarToggleButtonItemPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboUIToolbarToggleButtonItem</NAME>
typedef struct {
	BonoboUIToolbarButtonItem parent;
} BonoboUIToolbarToggleButtonItem;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboUIToolbarToggleButtonItemClass</NAME>
typedef struct {
	BonoboUIToolbarButtonItemClass parent_class;

	void (* toggled) (BonoboUIToolbarToggleButtonItem *toggle_button_item);
} BonoboUIToolbarToggleButtonItemClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_construct</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarToggleButtonItem *toggle_button_item,GdkPixbuf                     *icon,const char                    *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkPixbuf                     *icon,const char                    *label
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_set_active</NAME>
<RETURNS>void  </RETURNS>
BonoboUIToolbarToggleButtonItem *item,gboolean                       active
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_toolbar_toggle_button_item_get_active</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboUIToolbarToggleButtonItem *item
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_pixbuf_to_xml</NAME>
<RETURNS>char       *</RETURNS>
GdkPixbuf    *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_to_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
const char *xml
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_get_icon_pixbuf</NAME>
<RETURNS>GdkPixbuf  *</RETURNS>
BonoboUINode *node, gboolean prepend_menu
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_get_icon_pixmap_widget</NAME>
<RETURNS>GtkWidget  *</RETURNS>
BonoboUINode *node, gboolean prepend_menu
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,GdkPixbuf     *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_xpm</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char   **xpm
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_stock</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_xml_set_pix_fname</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode  *node,const char    *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_help_menu</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *listener,const char        *app_prefix,const char        *app_name,BonoboUINode      *parent
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_build_accel</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
guint              accelerator_key,GdkModifierType    accelerator_mods,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_menu</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
gboolean           submenu,const char        *name,const char        *label,const char        *tip,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_placeholder</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,gboolean           top,gboolean           bottom
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_radiogroup</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode           *node,const char        *group_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_toggle</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode           *node,const char        *id,const char        *init_state
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_std_toolbar</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,const char        *label,const char        *tip,const char        *verb
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_toggle_toolbar</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
const char        *name,const char        *label,const char        *tip,const char        *id
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_get_ui_fname</NAME>
<RETURNS>char       *</RETURNS>
const char        *component_prefix,const char        *file_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_translate_ui</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode      *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_fixup_help</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,BonoboUINode      *node,const char        *app_prefix,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_fixup_icons</NAME>
<RETURNS>void  </RETURNS>
BonoboUINode      *node
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_new_ui</NAME>
<RETURNS>BonoboUINode    *</RETURNS>
BonoboUIComponent *component,const char        *fname,const char        *app_prefix,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_ui</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,const char        *app_prefix,const char        *file_name,const char        *app_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_set_pixbuf</NAME>
<RETURNS>void  </RETURNS>
BonoboUIComponent *component,const char        *path,GdkPixbuf         *pixbuf
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_accel_name</NAME>
<RETURNS>gchar           *</RETURNS>
guint              accelerator_key,GdkModifierType    accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_accel_parse</NAME>
<RETURNS>void  </RETURNS>
char              *name,guint             *accelerator_key,GdkModifierType   *accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_decode_str</NAME>
<RETURNS>char            *</RETURNS>
const char *str, gboolean *err
</FUNCTION>
<FUNCTION>
<NAME>bonobo_ui_util_encode_str</NAME>
<RETURNS>char            *</RETURNS>
const char *str
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_FRAME_TYPE</NAME>
#define BONOBO_VIEW_FRAME_TYPE        (bonobo_view_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_FRAME</NAME>
#define BONOBO_VIEW_FRAME(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_FRAME_TYPE, BonoboViewFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_FRAME_CLASS</NAME>
#define BONOBO_VIEW_FRAME_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_FRAME_TYPE, BonoboViewFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_FRAME</NAME>
#define BONOBO_IS_VIEW_FRAME(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_FRAME_CLASS</NAME>
#define BONOBO_IS_VIEW_FRAME_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboViewFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrameClass</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFramePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrame</NAME>
struct BonoboViewFrame {
	BonoboControlFrame	 base;
	BonoboViewFramePrivate	*priv;
};
</STRUCT>
<STRUCT>
<NAME>BonoboViewFrameClass</NAME>
struct BonoboViewFrameClass {
	BonoboControlFrameClass parent_class;

	POA_Bonobo_ViewFrame__epv epv;

	/* Signals. */
	void (*user_activate)       (BonoboViewFrame *view_frame);
	void (*user_context)        (BonoboViewFrame *view_frame);
};
</STRUCT>
<FUNCTION>
<NAME>bonobo_view_frame_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_construct</NAME>
<RETURNS>BonoboViewFrame            *</RETURNS>
BonoboViewFrame   *view_frame,BonoboClientSite  *client_site,Bonobo_UIContainer uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_new</NAME>
<RETURNS>BonoboViewFrame            *</RETURNS>
BonoboClientSite *client_site,Bonobo_Unknown    uih
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_bind_to_view</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,Bonobo_View       view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_view</NAME>
<RETURNS>Bonobo_View  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_client_site</NAME>
<RETURNS>BonoboClientSite           *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_wrapper</NAME>
<RETURNS>GtkWidget                  *</RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_set_covered</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,gboolean          covered
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_get_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboViewFrame *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_activate</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_view_deactivate</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_frame_set_zoom_factor</NAME>
<RETURNS>void  </RETURNS>
BonoboViewFrame  *view_frame,double            zoom
</FUNCTION>
<MACRO>
<NAME>BONOBO_VIEW_TYPE</NAME>
#define BONOBO_VIEW_TYPE        (bonobo_view_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW</NAME>
#define BONOBO_VIEW(o)          (GTK_CHECK_CAST ((o), BONOBO_VIEW_TYPE, BonoboView))
</MACRO>
<MACRO>
<NAME>BONOBO_VIEW_CLASS</NAME>
#define BONOBO_VIEW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_VIEW_TYPE, BonoboViewClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW</NAME>
#define BONOBO_IS_VIEW(o)       (GTK_CHECK_TYPE ((o), BONOBO_VIEW_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_VIEW_CLASS</NAME>
#define BONOBO_IS_VIEW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_VIEW_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboView</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboViewPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>BONOBO_VIEW_VERB_FUNC</NAME>
#define BONOBO_VIEW_VERB_FUNC(fn) ((BonoboViewVerbFunc)(fn))
</MACRO>
<USER_FUNCTION>
<NAME>BonoboViewVerbFunc</NAME>
<RETURNS>void </RETURNS>
BonoboView *view, const char *verb_name, void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>BonoboView</NAME>
struct BonoboView {
	BonoboControl base;

	BonoboEmbeddable  *embeddable;
	Bonobo_ViewFrame   view_frame;
	BonoboViewPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboViewClass</NAME>
typedef struct {
	BonoboControlClass       parent_class;

	POA_Bonobo_View__epv     epv;

	/* Signals */
	void (*do_verb)         (BonoboView *view,
				 const CORBA_char *verb_name);
	void (*set_zoom_factor) (BonoboView *view, double zoom);

} BonoboViewClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_view_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_construct</NAME>
<RETURNS>BonoboView            *</RETURNS>
BonoboView         *view,GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_new</NAME>
<RETURNS>BonoboView            *</RETURNS>
GtkWidget          *widget
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_embeddable</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,BonoboEmbeddable   *embeddable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_embeddable</NAME>
<RETURNS>BonoboEmbeddable      *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_set_view_frame</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,Bonobo_ViewFrame    view_frame
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_view_frame</NAME>
<RETURNS>Bonobo_ViewFrame  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_remote_ui_container</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_get_ui_component</NAME>
<RETURNS>BonoboUIComponent     *</RETURNS>
BonoboView         *view
</FUNCTION>
<FUNCTION>
<NAME>bonobo_view_activate_notify</NAME>
<RETURNS>void  </RETURNS>
BonoboView         *view,gboolean            activated
</FUNCTION>
<MACRO>
<NAME>BONOBO_WIDGET_TYPE</NAME>
#define BONOBO_WIDGET_TYPE        (bonobo_widget_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET</NAME>
#define BONOBO_WIDGET(o)          (GTK_CHECK_CAST ((o), BONOBO_WIDGET_TYPE, BonoboWidget))
</MACRO>
<MACRO>
<NAME>BONOBO_WIDGET_CLASS</NAME>
#define BONOBO_WIDGET_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_WIDGET_TYPE, BonoboWidgetClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET</NAME>
#define BONOBO_IS_WIDGET(o)       (GTK_CHECK_TYPE ((o), BONOBO_WIDGET_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WIDGET_CLASS</NAME>
#define BONOBO_IS_WIDGET_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_WIDGET_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidgetPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>BonoboWidget</NAME>
struct BonoboWidget {
	GtkBin		          bin;

	BonoboWidgetPrivate *priv;
};
</STRUCT>
<TYPEDEF>
<NAME>BonoboWidgetClass</NAME>
typedef struct {
	GtkBinClass	 bin_class;
} BonoboWidgetClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_widget_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_server</NAME>
<RETURNS>BonoboObjectClient  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_objref</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control</NAME>
<RETURNS>GtkWidget           *</RETURNS>
const char        *moniker,Bonobo_UIContainer uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_control_from_objref</NAME>
<RETURNS>GtkWidget           *</RETURNS>
Bonobo_Control     control,Bonobo_UIContainer uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_control_frame</NAME>
<RETURNS>BonoboControlFrame  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_construct_control_from_objref</NAME>
<RETURNS>BonoboWidget        *</RETURNS>
BonoboWidget      *bw,Bonobo_Control     control,Bonobo_UIContainer uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_construct_control</NAME>
<RETURNS>BonoboWidget        *</RETURNS>
BonoboWidget      *bw,const char        *moniker,Bonobo_UIContainer uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_new_subdoc</NAME>
<RETURNS>GtkWidget            *</RETURNS>
const char        *moniker,Bonobo_UIContainer uic
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_container</NAME>
<RETURNS>BonoboItemContainer  *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_client_site</NAME>
<RETURNS>BonoboClientSite     *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_view_frame</NAME>
<RETURNS>BonoboViewFrame      *</RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_uih</NAME>
<RETURNS>Bonobo_UIContainer  </RETURNS>
BonoboWidget      *bw
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_set_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget       *control,const char         *first_prop,...
</FUNCTION>
<FUNCTION>
<NAME>bonobo_widget_get_property</NAME>
<RETURNS>void  </RETURNS>
BonoboWidget       *control,const char         *first_prop,...
</FUNCTION>
<MACRO>
<NAME>BONOBO_TYPE_WINDOW</NAME>
#define BONOBO_TYPE_WINDOW        (bonobo_window_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WINDOW</NAME>
#define BONOBO_WINDOW(o)          (GTK_CHECK_CAST ((o), BONOBO_TYPE_WINDOW, BonoboWindow))
</MACRO>
<MACRO>
<NAME>BONOBO_WINDOW_CLASS</NAME>
#define BONOBO_WINDOW_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_TYPE_WINDOW, BonoboWindowClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WINDOW</NAME>
#define BONOBO_IS_WINDOW(o)       (GTK_CHECK_TYPE ((o), BONOBO_TYPE_WINDOW))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WINDOW_CLASS</NAME>
#define BONOBO_IS_WINDOW_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_TYPE_WINDOW))
</MACRO>
<STRUCT>
<NAME>BonoboWindowPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboWindow</NAME>
typedef struct {
	GtkWindow          parent;
	
	BonoboWindowPrivate  *priv;
} BonoboWindow;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboWindowClass</NAME>
typedef struct {
	GtkWindowClass    parent_class;
} BonoboWindowClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_window_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_construct</NAME>
<RETURNS>GtkWidget            *</RETURNS>
BonoboWindow      *win,const char        *win_name,const char        *title
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_new</NAME>
<RETURNS>GtkWidget            *</RETURNS>
const char        *win_name,const char        *title
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_set_contents</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,GtkWidget         *contents
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_contents</NAME>
<RETURNS>GtkWidget            *</RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_ui_engine</NAME>
<RETURNS>BonoboUIEngine       *</RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_set_name</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,const char        *win_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_name</NAME>
<RETURNS>char                 *</RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_get_accel_group</NAME>
<RETURNS>GtkAccelGroup        *</RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_freeze</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_thaw</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_merge</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboWindow      *win,const char        *path,const char        *xml,const char        *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_merge_tree</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboWindow      *win,const char        *path,BonoboUINode      *tree,const char        *component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_get</NAME>
<RETURNS>char                 *</RETURNS>
BonoboWindow      *win,const char        *path,gboolean           node_only
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_node_exists</NAME>
<RETURNS>gboolean  </RETURNS>
BonoboWindow      *win,const char        *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_xml_rm</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboWindow      *win,const char        *path,const char        *by_component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_object_set</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboWindow      *win,const char        *path,Bonobo_Unknown     object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_object_get</NAME>
<RETURNS>BonoboUIError  </RETURNS>
BonoboWindow      *win,const char        *path,Bonobo_Unknown    *object,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_dump</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,const char        *msg
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_register_component</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,const char        *name,Bonobo_Unknown     component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_deregister_component</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,const char        *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_deregister_component_by_ref</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,Bonobo_Unknown     component
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_deregister_dead_components</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_deregister_get_component_names</NAME>
<RETURNS>GList                *</RETURNS>
BonoboWindow      *win
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_component_get</NAME>
<RETURNS>Bonobo_Unknown  </RETURNS>
BonoboWindow      *win,const char        *name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_add_popup</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,GtkMenu           *popup,const char        *path
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_set_ui_container</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,BonoboObject      *container
</FUNCTION>
<FUNCTION>
<NAME>bonobo_window_remove_popup</NAME>
<RETURNS>void  </RETURNS>
BonoboWindow      *win,const char        *path
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_WRAPPER</NAME>
#define GNOME_TYPE_WRAPPER            (bonobo_wrapper_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_WRAPPER</NAME>
#define BONOBO_WRAPPER(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_WRAPPER, BonoboWrapper))
</MACRO>
<MACRO>
<NAME>BONOBO_WRAPPER_CLASS</NAME>
#define BONOBO_WRAPPER_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_WRAPPER, BonoboWrapperClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WRAPPER</NAME>
#define BONOBO_IS_WRAPPER(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_WRAPPER))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_WRAPPER_CLASS</NAME>
#define BONOBO_IS_WRAPPER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_WRAPPER))
</MACRO>
<STRUCT>
<NAME>BonoboWrapperPrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboWrapper</NAME>
typedef struct {
	GtkBin bin;

	/* Private data. */
	BonoboWrapperPrivate *priv;
} BonoboWrapper;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboWrapperClass</NAME>
typedef struct {
	GtkBinClass parent_class;
} BonoboWrapperClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_wrapper_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_new</NAME>
<RETURNS>GtkWidget 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_set_covered</NAME>
<RETURNS>void 	</RETURNS>
BonoboWrapper *wrapper, gboolean covered
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_is_covered</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboWrapper *wrapper
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_get_visibility</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboWrapper *wrapper
</FUNCTION>
<FUNCTION>
<NAME>bonobo_wrapper_set_visibility</NAME>
<RETURNS>void 	</RETURNS>
BonoboWrapper *wrapper, gboolean visible
</FUNCTION>
<MACRO>
<NAME>BONOBO_ZOOMABLE_TYPE</NAME>
#define BONOBO_ZOOMABLE_TYPE		(bonobo_zoomable_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE</NAME>
#define BONOBO_ZOOMABLE(o)		(GTK_CHECK_CAST ((o), BONOBO_ZOOMABLE_TYPE, BonoboZoomable))
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE_CLASS</NAME>
#define BONOBO_ZOOMABLE_CLASS(k)	(GTK_CHECK_CLASS_CAST((k), BONOBO_ZOOMABLE_TYPE, BonoboZoomableClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE</NAME>
#define BONOBO_IS_ZOOMABLE(o)		(GTK_CHECK_TYPE ((o), BONOBO_ZOOMABLE_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE_CLASS</NAME>
#define BONOBO_IS_ZOOMABLE_CLASS(k)	(GTK_CHECK_CLASS_TYPE ((k), BONOBO_ZOOMABLE_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboZoomablePrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboZoomable</NAME>
typedef struct {
        BonoboObject		object;

	BonoboZoomablePrivate	*priv;
} BonoboZoomable;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboZoomableClass</NAME>
typedef struct {
	BonoboObjectClass	parent;

	void (*set_frame)	(BonoboZoomable *zoomable);
	void (*set_zoom_level)	(BonoboZoomable *zoomable,
				 float zoom_level);

	void (*zoom_in)		(BonoboZoomable *zoomable);
	void (*zoom_out)	(BonoboZoomable *zoomable);
	void (*zoom_to_fit)	(BonoboZoomable *zoomable);
	void (*zoom_to_default)	(BonoboZoomable *zoomable);
} BonoboZoomableClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_zoomable_get_epv</NAME>
<RETURNS>POA_Bonobo_Zoomable__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_corba_object_create</NAME>
<RETURNS>Bonobo_Zoomable 	</RETURNS>
BonoboObject   *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_new</NAME>
<RETURNS>BonoboZoomable 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_construct</NAME>
<RETURNS>BonoboZoomable 	*</RETURNS>
BonoboZoomable	*zoomable,Bonobo_Zoomable corba_zoomable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_set_parameters</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable,float           zoom_level,float		 min_zoom_level,float		 max_zoom_level,gboolean	 has_min_zoom_level,gboolean	 has_max_zoom_level
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_set_parameters_full</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable,float           zoom_level,float		 min_zoom_level,float		 max_zoom_level,gboolean	 has_min_zoom_level,gboolean	 has_max_zoom_level,gboolean	 is_continuous,float          *preferred_zoom_levels,const gchar   **preferred_zoom_level_names,gint		 num_preferred_zoom_levels
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_add_preferred_zoom_level</NAME>
<RETURNS>void  </RETURNS>
BonoboZoomable *zoomable,float zoom_level,const gchar *zoom_level_name
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_report_zoom_level_changed</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable,float		 new_zoom_level
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_report_zoom_parameters_changed</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomable	*zoomable
</FUNCTION>
<MACRO>
<NAME>BONOBO_ZOOMABLE_FRAME_TYPE</NAME>
#define BONOBO_ZOOMABLE_FRAME_TYPE		(bonobo_zoomable_frame_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE_FRAME</NAME>
#define BONOBO_ZOOMABLE_FRAME(o)		(GTK_CHECK_CAST ((o), BONOBO_ZOOMABLE_FRAME_TYPE, BonoboZoomableFrame))
</MACRO>
<MACRO>
<NAME>BONOBO_ZOOMABLE_FRAME_CLASS</NAME>
#define BONOBO_ZOOMABLE_FRAME_CLASS(k)		(GTK_CHECK_CLASS_CAST((k), BONOBO_ZOOMABLE_FRAME_TYPE, BonoboZoomableFrameClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE_FRAME</NAME>
#define BONOBO_IS_ZOOMABLE_FRAME(o)		(GTK_CHECK_TYPE ((o), BONOBO_ZOOMABLE_FRAME_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_ZOOMABLE_FRAME_CLASS</NAME>
#define BONOBO_IS_ZOOMABLE_FRAME_CLASS(k)	(GTK_CHECK_CLASS_TYPE ((k), BONOBO_ZOOMABLE_FRAME_TYPE))
</MACRO>
<STRUCT>
<NAME>BonoboZoomableFramePrivate</NAME>
</STRUCT>
<TYPEDEF>
<NAME>BonoboZoomableFrame</NAME>
typedef struct {
        BonoboObject			object;

	BonoboZoomableFramePrivate	*priv;
} BonoboZoomableFrame;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboZoomableFrameClass</NAME>
typedef struct {
	BonoboObjectClass		parent;

	void (*zoom_level_changed)	(BonoboZoomableFrame *zframe,
					 float zoom_level);
	void (*zoom_parameters_changed)	(BonoboZoomableFrame *zframe);
} BonoboZoomableFrameClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_epv</NAME>
<RETURNS>POA_Bonobo_ZoomableFrame__epv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_corba_object_create</NAME>
<RETURNS>Bonobo_ZoomableFrame 	</RETURNS>
BonoboObject		*object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_new</NAME>
<RETURNS>BonoboZoomableFrame 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_construct</NAME>
<RETURNS>BonoboZoomableFrame 	*</RETURNS>
BonoboZoomableFrame	*zframe,Bonobo_ZoomableFrame	 corba_zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_zoom_level</NAME>
<RETURNS>float 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_min_zoom_level</NAME>
<RETURNS>float 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_max_zoom_level</NAME>
<RETURNS>float 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_has_min_zoom_level</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_has_max_zoom_level</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_is_continuous</NAME>
<RETURNS>gboolean 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_preferred_zoom_levels</NAME>
<RETURNS>GList 		*</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_preferred_zoom_level_names</NAME>
<RETURNS>GList 		*</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_set_zoom_level</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe,float			 zoom_level
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_in</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_out</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_to_fit</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_zoom_to_default</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_bind_to_zoomable</NAME>
<RETURNS>void 	</RETURNS>
BonoboZoomableFrame	*zframe,Bonobo_Zoomable	 zoomable
</FUNCTION>
<FUNCTION>
<NAME>bonobo_zoomable_frame_get_zoomable</NAME>
<RETURNS>Bonobo_Zoomable 	</RETURNS>
BonoboZoomableFrame	*zframe
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_TYPE</NAME>
#define BONOBO_PRINT_TYPE        (bonobo_print_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT</NAME>
#define BONOBO_PRINT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_TYPE, BonoboPrint))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLASS</NAME>
#define BONOBO_PRINT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_TYPE, BonoboPrintClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT</NAME>
#define BONOBO_IS_PRINT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboPrint</NAME>
typedef struct {
        BonoboXObject        object;

	BonoboPrintRenderFn *render;
	gpointer             user_data;
} BonoboPrint;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboPrintClass</NAME>
typedef struct {
	BonoboXObjectClass   parent;

	POA_Bonobo_Print__epv epv;

	BonoboPrintRenderFn *render;
} BonoboPrintClass;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_print_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_construct</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrint         *p,BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_new</NAME>
<RETURNS>BonoboPrint     *</RETURNS>
BonoboPrintRenderFn *render,gpointer             user_data
</FUNCTION>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_TYPE</NAME>
#define BONOBO_PRINT_CLIENT_TYPE        (bonobo_print_client_get_type ())
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT</NAME>
#define BONOBO_PRINT_CLIENT(o)          (GTK_CHECK_CAST ((o), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClient))
</MACRO>
<MACRO>
<NAME>BONOBO_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_PRINT_CLIENT_CLASS(k)    (GTK_CHECK_CLASS_CAST((k), BONOBO_PRINT_CLIENT_TYPE, BonoboPrintClientClass))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT</NAME>
#define BONOBO_IS_PRINT_CLIENT(o)       (GTK_CHECK_TYPE ((o), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<MACRO>
<NAME>BONOBO_IS_PRINT_CLIENT_CLASS</NAME>
#define BONOBO_IS_PRINT_CLIENT_CLASS(k) (GTK_CHECK_CLASS_TYPE ((k), BONOBO_PRINT_CLIENT_TYPE))
</MACRO>
<TYPEDEF>
<NAME>BonoboPrintClient</NAME>
typedef struct {
	GtkObject    parent;
	Bonobo_Print corba_print;
} BonoboPrintClient;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboPrintClientClass</NAME>
typedef struct {
	GtkObjectClass			parent;
} BonoboPrintClientClass;
</TYPEDEF>
<TYPEDEF>
<NAME>BonoboPrintData</NAME>
typedef struct {
	double width;
	double height;
	
	double width_first_page;
	double width_per_page;
	double height_first_page;
	double height_per_page;

	GnomePrintMeta *meta_data;
} BonoboPrintData;
</TYPEDEF>
<FUNCTION>
<NAME>bonobo_print_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_new</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
Bonobo_Print         corba_print
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_get</NAME>
<RETURNS>BonoboPrintClient   *</RETURNS>
BonoboObjectClient  *object
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_client_render</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintClient   *client,BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_new_full</NAME>
<RETURNS>BonoboPrintData     *</RETURNS>
double               width,double               height,double               width_first_page,double               width_per_page,double               height_first_page,double               height_per_page
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_free</NAME>
<RETURNS>void  </RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_get_meta</NAME>
<RETURNS>GnomePrintMeta      *</RETURNS>
BonoboPrintData     *pd
</FUNCTION>
<FUNCTION>
<NAME>bonobo_print_data_render</NAME>
<RETURNS>void  </RETURNS>
GnomePrintContext   *pc,double               x,double               y,BonoboPrintData     *pd,double               meta_x,double               meta_y
</FUNCTION>
