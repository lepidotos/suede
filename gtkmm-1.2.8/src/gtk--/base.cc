// -*- c++ -*-
//  Generated by gtkmmproc from ./../base.gen_h -- DO NOT MODIFY!
#include <gtk--/base.h>
#include <gtk--/private/base_p.h>
#include <map>
namespace Gtk
{

//using statements for standard library names. 
GTKMM_USING_STD_MAP;

GQuark quark_ = 0;

/********************************************************************/

typedef map<string,Wrap_Func> Wrap_Table;
Wrap_Table* wrap_table=0;

// Registers a new type with wrap map
void wrap_register(const string& name, Wrap_Func f)
{
  if (!wrap_table) wrap_table=new Wrap_Table();
  (*wrap_table)[name]=f;
}

// This is to be a factory function that takes any type to
// its C++ function by looking it up in map.
Object* wrap_auto(_GtkObject* o)
{
  // screen out NULL
  if (!o) 
    return 0;

  // Look up current wrapper
  Object* p=static_cast<Object *>(gtk_object_get_data_by_id(GTK_OBJECT(o),quark_));
  if (p) 
    return p;

  // Generate a new one
  if (!wrap_table)
    {
      g_warning("Gtk-- wrapper table not yet filled.\n");
      return 0;
    }
  Wrap_Func func;
  GtkType type=GTK_OBJECT_TYPE(o);
  while (type)
    {
      func=(*wrap_table)[gtk_type_name(type)];
      if (func)
         return (func)(o);
      type=gtk_type_parent(type);
    }
  g_warning("Failed to wrap type of %s.\n",gtk_type_name(GTK_OBJECT_TYPE(o)));
  return 0;
}

/********************************************************************/

Base::~Base() 
{}

nstring::nstring ()
  : string(), null_(false)
{}

nstring::nstring(string str)
  : string(str), null_(false)
{}

// lets not use "NULL" in gtk--. 0 is much more portable in c++.
nstring::nstring(const char *s)
  : string(), null_(s==0)
{
  if (!null_) 
    string::operator=(s);
}

nstring::~nstring() {};

// this function should be used in place of c_str
// if NULL is a valid value.
const char * nstring::gc_str() const
{
  if (null_) return (char*)0;
  return c_str();
}

/********************************************************************/

#ifndef GTKMM_MSC

#else
void SArray::a_alloc(size_t size)
{
  data_=new cstring[size+1];
  data_[size]=0;
  owned_=1;
}

SArray::SArray(const SArray& c)
  :owned_(0), data_(c.data_), size_(c.size_)
{}

SArray::SArray(const char** data)
  :owned_(0), data_(data), size_(0)
{
  for (const char **iter=data; *iter != 0; ++iter, ++size_);
}

SArray::~SArray()
{
  if (owned_) delete [] data_;
}

#endif

} /* namespace Gtk */

/********************************************************************/

gpointer gtkmm_null_pointer=0;

GList* G_ListWrap::insert(GList* pos,gpointer data)
{
  if (pos==list_)
    {
      list_=g_list_prepend(list_,data);
      return g_list_first(list_);
    }
  if (!pos)
    {
      GList* l=g_list_last(list_);
      g_list_append(l,data);
      return g_list_next(l);
    }
  g_list_insert(pos,data,0);
  return g_list_previous(pos);
}

GList* G_ListWrap::erase(GList* pos)
{
  if (!pos) return 0;
  GList* next=g_list_next(pos);
  list_=g_list_remove_link(list_,pos);
  return next;
}


GList* G_ListImpl::insert(GList* pos,gpointer data)
{
  if (pos==list_)
    {
      list_=g_list_prepend(list_,data);
      return g_list_first(list_);
    }
  if (!pos)
    {
      GList* l=g_list_last(list_);
      g_list_append(l,data);
      return g_list_next(l);
    }
  g_list_insert(pos,data,0);
  return g_list_previous(pos);
}

GList* G_ListImpl::erase(GList* pos)
{
  if (!pos) return 0;
  GList* next=g_list_next(pos);
  list_=g_list_remove_link(list_,pos);
  return next;
}



