dnl $Id: stage1.m4,v 1.81 2001/02/15 09:42:47 kenelson Exp $
divert(-1)
include(convert.m4)
# ---------------- Little useful macro -----------------------
#
#
# Add a coma before the arg if any, do nothing otherwise
# _COMA_(a) -> ,a
# _COMA_() -> `'
#
define(`_COMA_', `ifelse(eval(len(`$*') >= 1), 1, `,$*')')dnl

#
#  _UPPER_(string)
#    uppercase a string
define(`_UPPER_',`translit(`$*',`abcdefghijklmnopqrstuvwxyz',`ABCDEFGHIJKLMNOPQRSTUVWXYZ')')

#
#  _LOWER_(string)
#    lower a string
define(`_LOWER_',`translit(`$*',`ABCDEFGHIJKLMNOPQRSTUVWXYZ',`abcdefghijklmnopqrstuvwxyz')')

# 
#  _QUOTE_(macro)  
#    If a macro generates an output with commas we need to protect it
#    from being broken down and interpreted
define(`_QUOTE_',``$*'')

#
#  _NUM_(arglist)   
#    count number of arguments
define(`_NUM_',`ifelse(len(`$*'),0,0,`$#')')

#
#  _IF_(cond,string1,string2)
#    places string1 if cond is empty 
define(`_IF_',`ifelse(len(_QUOTE_(translit(`$1',` '))),0,`$3',`$2')')

#
#  _ARG_LIST_(`args') 
#    takes `int,char' => p0,p1
define(`_C_ARG_LIST_',`dnl
define(`XX',eval(XX+1))dnl
ifelse(`$*',,,`,$1 p`'XX`'_C_ARG_LIST_(shift($*))')dnl
')

define(`ARG_LIST',`dnl
define(`XX',1)dnl
ifelse(`$*',,,`$1 p`'XX`'_C_ARG_LIST_(shift($*))')dnl
')


#
#  _ARG_NAMES_(`args') 
#    takes `int,char' => int p0,char p1
define(`_C_ARG_NAMES_',`dnl
define(`XX',eval(XX+1))dnl
ifelse(`$*',,,`,p`'XX`'C_ARG_NAMES(shift($*))')dnl
')

define(`_ARG_NAMES_',`dnl
define(`XX',1)dnl
ifelse(`$*',,,`p`'XX`'C_ARG_NAMES(shift($*))')dnl
')

#
# For handling of included macro files.
#
define(`__PUSHDIV__',`pushdef(`__DIV__',divnum)divert(-1)dnl`'')
define(`__POPDIV__',`divert(__DIV__)popdef(`__DIV__')dnl`'')
define(`__BEGIN__',`__PUSHDIV__(-1)')
define(`__END__',`__POPDIV__()')


changequote([,])
define([__BQ__],[changequote(,)`changequote(`,')])
changequote(`,')

changecom

dnl
dnl ----------------------- Main Headers -------------------------
dnl

define(`__SEC_PROXY',1)
define(`__SEC_SIMPL',2)
define(`__SEC_CINIT',3)
define(`__SEC_PINIT',4)
define(`__SEC_SNAME',5)
define(`__SEC_HEADER',6)
define(`__SEC_CLASS',7)
define(`__SEC_PHEADER',8)
define(`__SEC_PRIVATE',9)
define(`__SEC_IMPL',10)
define(`__SEC_DOC',12)
define(`__SEC_SRC',13)
define(`__SEC_METHOD',14)
define(`__SEC_SIGNAL',15)
define(`__SEC_MEMBER',16)
define(`__SEC_CHECK',17)
define(`__SEC_TYPES',18)
define(`__SEC_USR',20)

define(`GTKMM_SECTION',`divert(__SEC_$1)dnl')
define(`GTKMM_IMPORT',`undivert(__SEC_$1)dnl')   

define(`GLINE',`#L __auto__')        

define(`GTKMM_CHECK',`dnl
__PUSHDIV__
GTKMM_SECTION(CHECK)
    $*
__POPDIV__
')

# Include firewall
#
# GTKMM_START(CONSTANT, original_filename)
# GTKMM_START(GTKMM_BUTTON, button.gen_h)
define(`GTKMM_START',`dnl
define(`__source__',patsubst($2,`^.*\/',`'))dnl
GTKMM_SECTION(IMPL)
// -*- c++ -*-
//  Generated by gtkmmproc from $2 -- DO NOT MODIFY!
GTKMM_SECTION(PHEADER)
// -*- c++ -*-
//  Generated by gtkmmproc from $2 -- DO NOT MODIFY!
#ifndef _`'_UPPER_(translit(`$1', `-', `_'))`'_P_H
#define _`'_UPPER_(translit(`$1', `-', `_'))`'_P_H
GTKMM_SECTION(HEADER)
// -*- c++ -*-
//  Generated by gtkmmproc from $2 -- DO NOT MODIFY!
#ifndef _`'_UPPER_(translit(`$1', `-', `_'))`'_H
#define _`'_UPPER_(translit(`$1', `-', `_'))`'_H
')

# This does all the work of assembling the final output
#
# GTKMM_END()
#
define(`GTKMM_END',`dnl
divert(0)dnl
#S 0
GTKMM_IMPORT(HEADER)
namespace __NAMESPACE__
{
GTKMM_IMPORT(CLASS)
}

GTKMM_IMPORT(DOC)
#endif
#S 1
GTKMM_IMPORT(PHEADER)
GLINE
namespace __NAMESPACE__
{
GTKMM_IMPORT(PRIVATE)
}
#endif
#S 2
GTKMM_IMPORT(IMPL)
GLINE
GTKMM_IMPORT(SRC)
')

define(`GTKMM_NAMESPACE',`dnl
define(`__NAMESPACE__',$1)dnl
ifelse($1,Gtk,`define(`__GTK__',$`'1)',`define(`__GTK__',Gtk::$`'1)')dnl
')

#
# GTKMM_CLASS_START(Gtk--Type, Gtk--ParentType, GtkType, GtkParentType, 
#                 GTK_CAST, type)
# e.g. :
# GTKMM_CLASS_START(Button, Bin, GtkButton, GtkBin, 
#                 GTK_BUTTON, button)
#

define(`GTKMM_CLASS_START', `
dnl
dnl  Define the args for later macros
define(`__CPPNAME__',`$1')dnl
define(`__CNAME__',`$2')dnl
define(`__CCAST__',`$3')dnl
define(`__CCHECK__',`$4')dnl
define(`__BASE__',`$5')dnl
define(`__CPPPARENT__',`$6')dnl
define(`__CPARENT__',`$7')dnl
define(`__PCAST__',`($7*)')dnl
dnl
dnl clear counters 
define(`__NO_SIGNALS__')dnl
dnl
dnl
GTKMM_SECTION(HEADER)
GLINE()
namespace __NAMESPACE__ { 
class __CPPNAME__; 
class __CPPNAME__`'_Class; 
}
namespace Gtk { __NAMESPACE__::__CPPNAME__ *wrap (__CNAME__ *o); }
dnl
dnl
GTKMM_SECTION(PRIVATE)
class __CPPNAME__`'_Class
{
public:

  typedef __CPPNAME__           CppObjectType;
  typedef __CNAME__           BaseObjectType;
  typedef __CNAME__`'Class      BaseClassType;
  typedef __CPPPARENT__`'_Class     CppClassParent;
  typedef __CPARENT__`'Class      BaseClassParent;


  static void class_init_function(BaseClassType *p);
  static void object_init_function(BaseObjectType *o);
  GtkType get_type();

  // Hook for translating API
  static Gtk::Object* wrap_new(GtkObject*);

  // Callbacks here...

dnl
dnl
GTKMM_SECTION(CLASS)
GLINE()
public:
  typedef __CPPNAME__          CppObjectType;
  typedef __CPPNAME__`'_Class    CppClassType;
  typedef __CNAME__           BaseObjectType;
  typedef __CNAME__`'Class      BaseClassType;

private:
  friend class __CPPNAME__`'_Class;
  static CppClassType __BASE__`'_class; 

  __CPPNAME__`'(const __CPPNAME__&);
  __CPPNAME__& operator=(const __CPPNAME__&); // not implemented

protected:
  void   initialize_class();
  explicit __CPPNAME__`'(__CNAME__ *castitem);

public:
  static GtkType get_type();
  __CNAME__* gtkobj()             { return (__CNAME__*)`'(gtkobject); }
  const __CNAME__* gtkobj() const { return (__CNAME__*)`'(gtkobject); }
  static bool isA(__GTK__(Object) *checkcast);

  // Hook for proxies
  static const char* const signal_names[];

  virtual ~__CPPNAME__`'();

private:
')dnl


dnl
dnl GTKMM_CLASS_END
dnl
define(`GTKMM_CLASS_END',`
dnl
dnl
GTKMM_SECTION(PRIVATE)
  // Data 
  GtkType type;
};

GTKMM_SECTION(SRC)
namespace Gtk {
__NAMESPACE__::__CPPNAME__ *wrap (__CNAME__ *o)
  {
    return static_cast<__NAMESPACE__::__CPPNAME__ *> (Gtk::wrap_auto ((GtkObject *) (o)));
  }
}

namespace __NAMESPACE__ {
__CPPNAME__`'_Class __CPPNAME__::__BASE__`'_class = {0};

__GTK__(Object*) __CPPNAME__`'_Class::wrap_new(GtkObject* o)
  {
    __GTK__(Object*) cpp=manage(new __CPPNAME__`'((__CNAME__*)`'(o)));
    return cpp; 
  }

bool __CPPNAME__::isA(__GTK__ Object *checkcast)
  {
    return __CCHECK__`'(checkcast->gtkobj());
  }

GtkType __CPPNAME__::get_type()
  { 
    return __BASE__`'_class.get_type(); 
  }

GtkType __CPPNAME__`'_Class::get_type() 
  {
    if (!type) 
      {
        CppClassParent::CppObjectType::get_type();
        GtkTypeInfo info = 
          {
            "__NAMESPACE__`'__`'__CPPNAME__", 
            sizeof(BaseObjectType), 
            sizeof(BaseClassType),
            (GtkClassInitFunc) class_init_function,
            (GtkObjectInitFunc) object_init_function,
            /* reserved_1 */ NULL,
            /* reserved_2 */ NULL,
            /*base_class_init_func */ (GtkClassInitFunc) NULL
          };
        type=gtk_type_unique(_LOWER_(__CCAST__)_get_type(), &info);
      }
    return type;
  }

const char* const __CPPNAME__::signal_names[]={
GTKMM_IMPORT(SNAME)
   0};

void __CPPNAME__::initialize_class()
  {
ifdef(`__NO_SIGNALS__',,`
dnl #ifndef GTKMM_CXX_GAUB
     __BASE__`'_self=this;
dnl #else
dnl GTKMM_IMPORT(PINIT)
dnl #endif
')
  }

void __CPPNAME__`'_Class::class_init_function(__CNAME__`'Class *klass)
  {
    CppClassParent::class_init_function((BaseClassParent*)klass);
GTKMM_IMPORT(CINIT)
  }

void __CPPNAME__`'_Class::object_init_function(__CNAME__ *) 
  {}

}

GTKMM_IMPORT(METHOD)
GTKMM_IMPORT(SIGNAL)
GTKMM_IMPORT(MEMBER)

dnl
dnl
GTKMM_SECTION(CLASS)
GLINE()

public:
ifdef(`__NO_SIGNALS__',,`
GTKMM_IMPORT(TYPES)
dnl#ifndef GTKMM_CXX_GAUB
  union
    {
dnl#endif
      CppObjectType * __BASE__`'_self;
GTKMM_IMPORT(PROXY)
dnl#ifndef GTKMM_CXX_GAUB
    };
dnl#endif
')dnl

protected:
  // impl functions
GTKMM_IMPORT(SIMPL)
undefine(`__NO_SIGNALS__')dnl
')



#
# --------------------------- Signal Decl----------------------------
#

define(`GTKMM_PROXY_NAME',`dnl
undefine(`__NO_SIGNALS__')dnl
GTKMM_SECTION(SNAME)
   "$1",
GTKMM_SECTION(CLASS)')

define(`GTKMM_PROXY_SIGNAL',`dnl
dnl GTKMM_SECTION(PINIT)
dnl     $2.obj=this;
dnl GTKMM_SECTION(CLASS)')
')


define(__M_HASH,`dnl
ifelse(`$1',gboolean,BOOL,
`$1',gint,INT,
`$1',guint,INT,
patsubst(`$1',`^.*\*',`*'),*,POINTER,
INT)`'dnl
')
define(__M_LHASH,`ifelse(`$*',,,`_`'__M_HASH($1)`'__M_LHASH(shift($*))')')
define(GTKMM_MARSHAL,`dnl
GTKMM_SECTION(CINIT)
    gtkmm_signal_set_marshal(gtk_signal_lookup("$1",__CPPNAME__::get_type()),&gtkmm_marshal_`'__M_HASH($2)_`'ifelse(`$3',,_NONE,__M_LHASH($3)));
GTKMM_SECTION(CLASS)')

# Proxy2<void,   int,int,     Gtk_Foo, GtkFoo, 1, gtk_foo_sig1> sig1;
#      ^            ^          ^        ^     ^       ^
#      |            |        Gtk--     gtk+   name   gtk+
#    Rettype    Arguments    type      type  index  function
#
# GTKMM_PROXY_SIGDEF(return_type,func_name,`<args>',index,gtksignal)
#
define(`GTKMM_PROXY_SIGNAL_EMIT',`dnl
GTKMM_SECTION(PROXY)
      Gtk::EmitProxySignal`'_NUM_($3)<$1`'_COMA_(`$3'),CppObjectType,BaseObjectType,$4,&$5> $2;
GTKMM_SECTION(CLASS)')

#
# Same as above, without emit
#
define(`GTKMM_PROXY_SIGNAL_NOEMIT',`dnl
GTKMM_SECTION(PROXY)
      Gtk::ProxySignal`'_NUM_($3)<$1`'_COMA_(`$3'),CppObjectType,BaseObjectType,$4> $2;
GTKMM_SECTION(CLASS)')


#
# Same as above, with translation
#
define(`GTKMM_PROXY_SIGNAL_TRANSLATE_EMIT_DECL',`dnl
GTKMM_SECTION(TYPES)
    class Proxy_$1
      : public Gtk::EmitProxySignal`'_NUM_($6)<$4`'_COMA_(`$6'),CppObjectType,BaseObjectType,$7,&$2>
      {
          typedef Gtk::EmitProxySignal`'_NUM_($6)<$4`'_COMA_(`$6'),CppObjectType,BaseObjectType,$7,&$2> BaseType;
        public:
          $3 operator ()($5);
          $3 emit($5);
          Connection connect(const SigC::Slot`'_NUM_($5)<$3`'_COMA_(`$5')> &s);
GTKMM_IMPORT(USR)
      };
GTKMM_SECTION(PROXY)
      Proxy_$1 $1;
GTKMM_SECTION(CLASS)')

define(`GTKMM_PROXY_SIGNAL_TRANSLATE_EMIT_IMPL',`dnl
GTKMM_SECTION(SIGNAL)
$2 __NAMESPACE__::__CPPNAME__::Proxy_$1::operator()($4)
  {
    ifelse($2,void,,return) BaseType::__REV_CONVERT($3,$2,`emit($5)');
  }

$2 __NAMESPACE__::__CPPNAME__::Proxy_$1::emit($4)
  {
    ifelse($2,void,,return) BaseType::__REV_CONVERT($3,$2,`emit($5)');
  }

GTKMM_SECTION(CLASS)')


#
# Same as above, with translation no emit
#
define(`GTKMM_PROXY_SIGNAL_TRANSLATE_NOEMIT_DECL',`dnl
GTKMM_SECTION(TYPES)
    class Proxy_$1
      : public ProxySignal`'_NUM_($6)<$4`'_COMA_(`$6'),CppObjectType,BaseObjectType,$7>
      {
          typedef ProxySignal`'_NUM_($6)<$4`'_COMA_(`$6'),CppObjectType,BaseObjectType,$7> BaseType;
        public:
          Connection connect(const SigC::Slot`'_NUM_($5)<$3`'_COMA_(`$5')> &s);
GTKMM_IMPORT(USR)
      };
GTKMM_SECTION(PROXY)
      Proxy_$1 $1;
GTKMM_SECTION(CLASS)')

define(`GTKMM_PROXY_SIGNAL_TRANSLATE_IMPL',`dnl
GTKMM_SECTION(SIGNAL)
namespace {
static $4 $1_convert_func(SigC::Callback`'_NUM_($5)<$3`'_COMA_($5)> *s`'_COMA_($6))
  {
    ifelse($4,void,,return) __FWD_CONVERT($4,$3,`s->call($7)');
  }

}

SigC::Connection
__NAMESPACE__::__CPPNAME__::Proxy_$1::connect(const SigC::Slot`'_NUM_($5)<$3`'_COMA_(`$5')> &s)
   {
    return BaseType::connect(SigC::convert(s,&$1_convert_func));
   }

GTKMM_SECTION(CLASS)')




#
# GTKMM_PROXY_CALLBACK(cppname,gtkname,cpprettype,crettype,
#                  `<cargs and names>',`<cnames>',`<cpparg names>',firstarg)
#   
define(`GTKMM_PROXY_CALLBACK',`dnl
GTKMM_SECTION(CINIT)
    klass->$2=$2_callback;
GTKMM_SECTION(PRIVATE)
  static $4 $2_callback($5);
GTKMM_SECTION(SIGNAL)
$4 __NAMESPACE__::__CPPNAME__`'_Class::$2_callback($5)
  {
    CppObjectType *obj=
dnl Do not change the line below, both casts are necessary
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)$8,Gtk::quark_)));

GTKMM_IMPORT(CHECK)
ifelse($4,void,`dnl
    if (obj) 
      obj->$1_impl($7);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)$8)->klass->type));
        if (base->$2)
          (base->$2)($6);
      }
',`dnl
    if (obj) 
      return __FWD_CONVERT($4,$3,`obj->$1_impl`'($7)');
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)$8)->klass->type));
        if (base->$2)
          return (base->$2)($6);
        gtkmm_set_ignore();
      }
    return 0;
')
  }

GTKMM_SECTION(CLASS)')


#                    $1      $2       $3     $4       $5          $6
# GTKMM_PROXY_IMPL(signame,gtkname,rettype,crettype,`<cppargs>',`<cargs>')
#   
define(`GTKMM_PROXY_IMPL',`dnl
GTKMM_SECTION(SIMPL)
    virtual $3 $1_impl($5);
GTKMM_SECTION(SIGNAL)
$3 __NAMESPACE__::__CPPNAME__::$1_impl($5)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->$2)
ifelse($3,void,`dnl
      (base->$2)(gtkobj()`'$6);
',`dnl
      return __REV_CONVERT($4,$3,(base->$2)(gtkobj()`'$6));
    gtkmm_set_ignore();
    return 0;
')
  }

GTKMM_SECTION(CLASS)')


#
#
#
define(`GTKMM_GTK_EMIT',`dnl
GTKMM_SECTION(HEADER)
extern "C" $1 $2(__CNAME__*_COMA_(`$3'));
GTKMM_SECTION(METHOD)
$1 $2(__CNAME__* __BASE__`'_COMA_(`$3'))
  {
    static guint signum=gtk_signal_lookup("$5",__GPREFIX__`'_`'__BASE__`'_get_type());
ifelse($1,void,`dnl
    g_return_if_fail (__BASE__ != NULL);
    g_return_if_fail (__CCAST__ (__BASE__));

    gtk_signal_emit(GTK_OBJECT`'(__BASE__),signum`'_COMA_(`$4'));
',`dnl
    $1 rc;
    g_return_val_if_fail (__BASE__ != NULL, 0 );
    g_return_val_if_fail (__CCAST__ (__BASE__), 0 );
    
    gtk_signal_emit(GTK_OBJECT`'(__BASE__),signum`'_COMA_(`$4'),&rc);
    return rc;
')dnl
  }

GTKMM_SECTION(CLASS)')



#
# --------------------------- Methods ----------------------------
#

###
### method 
###               $1      $2    $3         $4       $5       $6      $7    $8
###  GTKMM_METHOD(cppname,cname,cpprettype,crettype,varglist,arglist,cargs,const)
define(`GTKMM_METHOD',`dnl
  $3 $1`'($5)ifelse(`$8',1,` const');
GTKMM_SECTION(METHOD)
$3 __NAMESPACE__::__CPPNAME__::$1`'($6)ifelse(`$8',1,` const')
  {
    ifelse(`$3',void,,`return ')__REV_CONVERT(`$4',`$3',`$2`'(ifelse(`$8',1,const_cast<__CNAME__*>(gtkobj()),gtkobj())`'$7)');
  }

GTKMM_SECTION(CLASS)')

###
### static method
###                         $1       $2     $3         $4      $5     $6   
###  GTKMM_STATIC_METHOD(cppname,cname,cpprettype,crettype,arglist,cargs)
define(`GTKMM_STATIC_METHOD',`dnl
  static $3 $1($5);
GTKMM_SECTION(METHOD)
$3 __NAMESPACE__::__CPPNAME__::$1($5)
  {
    ifelse($3,void,,`return ')__REV_CONVERT($4,$3,`$2($6)');
  }

GTKMM_SECTION(CLASS)')



#
# --------------------------- Accessors ----------------------------
#

define(`GTKMM_MEMBER_VALUE',`dnl
  $3 get_$1() const;
GTKMM_SECTION(MEMBER)
$3 __NAMESPACE__::__CPPNAME__::get_$1() const
  { return __REV_CONVERT($4,$3,`gtkobj()->$2'); }

GTKMM_SECTION(CLASS)')

define(`GTKMM_MEMBER_REF',`dnl
GLINE()
  $3 get_$1();
  const $3 get_$1() const;
GTKMM_SECTION(MEMBER)
$3 __NAMESPACE__::__CPPNAME__::get_$1()
  { return __REV_CONVERT($4,$3,`gtkobj()->$2'); }
const $3 __NAMESPACE__::__CPPNAME__::get_$1() const
  { return __REV_CONVERT($4,$3,`gtkobj()->$2'); }
GTKMM_SECTION(CLASS)')


define(`GTKMM_MEMBER_VALUE_INLINE',`dnl
GLINE()
  $3 get_$1() const
    { return __REV_CONVERT($4,$3,`gtkobj()->$2'); }
')

define(`GTKMM_MEMBER_REF_INLINE',`dnl
GLINE()
  $3 get_$1()
    { return __REV_CONVERT($4,$3,`gtkobj()->$2'); }
  const $3 get_$1() const
    { return __REV_CONVERT($4,$3,`gtkobj()->$2'); }
')


###
### ----------------------- Constructors -------------------------
###

define(`GTKMM_CTOR_CAST',`dnl
GTKMM_SECTION(METHOD)
__NAMESPACE__::__CPPNAME__::__CPPNAME__`'(__CNAME__ *castitem)
  :     __CPPPARENT__`'(__PCAST__`'(castitem))
  {
    initialize_class();
  }

GTKMM_SECTION(CLASS)')

define(`GTKMM_DTOR',`dnl
GTKMM_SECTION(METHOD)
__NAMESPACE__::__CPPNAME__::~__CPPNAME__`'() { destroy_(); }

GTKMM_SECTION(CLASS)')

define(`GTKMM_CTOR_DEFAULT',`dnl
  __CPPNAME__`'();
GTKMM_SECTION(METHOD)
__NAMESPACE__::__CPPNAME__::__CPPNAME__`'()
  :     __CPPPARENT__`'(__PCAST__`'(gtk_object_new(get_type(),0)))
  {
    initialize_class();
  }

GTKMM_SECTION(CLASS)')



define(`GTK_METHOD_PASS',`$2')

divert(0)dnl
