// -*- c++ -*-
//  Generated by gtkmmproc from ./applet.gen_h -- DO NOT MODIFY!
#include "applet.h"
#include "private/applet_p.h"
#include <panel--/private/applet_p.h>

/* applet.cc
 *
 * Copyright (C) 1999-2001 Gergõ ÉRDI <cactus@cactus.rulez.org>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

namespace Gnome {
    using namespace SigC;

Applet::Applet(const Gtk::string& goad_id):
    Plug(GTK_PLUG(gtk_object_new(get_type(),0)))
{
    initialize_class();

    applet_widget_construct(gtkobj(), goad_id.c_str());
}

void Applet::add_menuitem(const Gtk::string &name,
			  const Gtk::string &caption,
			  Slot0<void>        callback)
{
    SlotData* slotdata = callback.data();
    applet_widget_register_callback(gtkobj(),
				    strdup(name.c_str()),
				    strdup(caption.c_str()),
				    &Applet::_fw_signal,
				    (gpointer)slotdata);
    slotdata->connect();
    ScopeNode* node = slotdata->receiver();
    register_data(node);
}

void Applet::add_menuitem_stock(const Gtk::string &name,
				const Gtk::string &stock_type,
				const Gtk::string &caption,
				Slot0<void>        callback)
{
    SlotData* slotdata = callback.data();
    applet_widget_register_stock_callback(gtkobj(),
					  strdup(name.c_str()),
					  strdup(stock_type.c_str()),
					  strdup(caption.c_str()),
					  &Applet::_fw_signal,
					  (gpointer)slotdata);
    slotdata->connect();
    ScopeNode* node = slotdata->receiver();
    register_data(node);
}

void Applet::_fw_signal(AppletWidget*,
			gpointer data)
{
    Slot0<void> slot((SlotData*)data);
    slot.call();
}
}

namespace Gtk {
Gnome::Applet *wrap (AppletWidget *o)
  {
    return static_cast<Gnome::Applet *> (Gtk::wrap_auto ((GtkObject *) (o)));
  }
}

namespace Gnome {
Applet_Class Applet::applet_class = {0};

Gtk::Object* Applet_Class::wrap_new(GtkObject* o)
  {
    Gtk::Object* cpp=manage(new Applet((AppletWidget*)(o)));
    return cpp;
  }

bool Applet::isA(Gtk:: Object *checkcast)
  {
    return IS_APPLET_WIDGET(checkcast->gtkobj());
  }

GtkType Applet::get_type()
  {
    return applet_class.get_type();
  }

GtkType Applet_Class::get_type()
  {
    if (!type)
      {
        CppClassParent::CppObjectType::get_type();
        GtkTypeInfo info =
          {
            "Gnome__Applet",
            sizeof(BaseObjectType),
            sizeof(BaseClassType),
            (GtkClassInitFunc) class_init_function,
            (GtkObjectInitFunc) object_init_function,
            /* reserved_1 */ NULL,
            /* reserved_2 */ NULL,
            /*base_class_init_func */ (GtkClassInitFunc) NULL
          };
        type=gtk_type_unique(applet_widget_get_type(), &info);
      }
    return type;
  }

const char* const Applet::signal_names[]={
   "change_orient",
   "change_pixel_size",
   "change_position",
   "save_session",
   "back_change",
   "tooltip_state",
   "do_draw",
   0};

void Applet::initialize_class()
  {

     applet_self=this;

  }

void Applet_Class::class_init_function(AppletWidgetClass *klass)
  {
    CppClassParent::class_init_function((BaseClassParent*)klass);
    klass->change_orient=change_orient_callback;
    klass->change_pixel_size=change_pixel_size_callback;
    klass->change_position=change_position_callback;
    klass->save_session=save_session_callback;
    klass->back_change=back_change_callback;
    klass->tooltip_state=tooltip_state_callback;
    klass->do_draw=do_draw_callback;
  }

void Applet_Class::object_init_function(AppletWidget *)
  {}

}

Gnome::Applet::Applet(AppletWidget *castitem)
  :     Gtk::Plug((GtkPlug*)(castitem))
  {
    initialize_class();
  }

Gnome::Applet::~Applet() { destroy_(); }

void Gnome::Applet::set_tooltip(const Gtk::nstring& text)
  {
    applet_widget_set_tooltip(gtkobj(),text.gc_str());
  }

void Gnome::Applet::set_widget_tooltip(Gtk::Widget& widget,const Gtk::nstring& text)
  {
    applet_widget_set_widget_tooltip(gtkobj(),widget.gtkobj(),text.gc_str());
  }

void Gnome::Applet::add(Gtk::Widget& widget)
  {
    applet_widget_add(gtkobj(),widget.gtkobj());
  }

void Gnome::Applet::remove()
  {
    applet_widget_remove(gtkobj());
  }

void Gnome::Applet::sync_config()
  {
    applet_widget_sync_config(gtkobj());
  }

void Gnome::Applet::abort_load()
  {
    applet_widget_abort_load(gtkobj());
  }

void Gnome::Applet::remove_menuitem(const Gtk::string& name)
  {
    applet_widget_unregister_callback(gtkobj(),name.c_str());
  }

void Gnome::Applet::set_menu_sensitive(const Gtk::string& name,bool sensitive)
  {
    applet_widget_callback_set_sensitive(gtkobj(),name.c_str(),(int)sensitive);
  }

void Gnome::Applet::add_submenu(const Gtk::string& name,const Gtk::string& caption)
  {
    applet_widget_register_callback_dir(gtkobj(),name.c_str(),caption.c_str());
  }

void Gnome::Applet::add_submenu_stock(const Gtk::string& name,const Gtk::string& stock_type,const Gtk::string& caption)
  {
    applet_widget_register_stock_callback_dir(gtkobj(),name.c_str(),stock_type.c_str(),caption.c_str());
  }

void Gnome::Applet::remove_submenu(const Gtk::string& name)
  {
    applet_widget_unregister_callback_dir(gtkobj(),name.c_str());
  }

GNOME_Panel_OrientType Gnome::Applet::get_panel_orient()
  {
    return applet_widget_get_panel_orient(gtkobj());
  }

int Gnome::Applet::get_panel_pixel_size()
  {
    return applet_widget_get_panel_pixel_size(gtkobj());
  }

void Gnome::Applet::get_rgb_bg(guchar** rgb,int& w,int& h,int& rowstride)
  {
    applet_widget_get_rgb_bg(gtkobj(),rgb,&w,&h,&rowstride);
  }

void Gnome::Applet::send_position(bool enable)
  {
    applet_widget_send_position(gtkobj(),(int)enable);
  }

void Gnome::Applet::send_draw(bool enable)
  {
    applet_widget_send_draw(gtkobj(),(int)enable);
  }

void Gnome::Applet_Class::change_orient_callback(AppletWidget* o_,GNOME_Panel_OrientType p0)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      obj->change_orient_impl(p0);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->change_orient)
          (base->change_orient)(o_,p0);
      }

  }

void Gnome::Applet::change_orient_impl(GNOME_Panel_OrientType p0)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->change_orient)
      (base->change_orient)(gtkobj(),p0);

  }

void Gnome::Applet_Class::change_pixel_size_callback(AppletWidget* o_,int p0)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      obj->change_pixel_size_impl(p0);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->change_pixel_size)
          (base->change_pixel_size)(o_,p0);
      }

  }

void Gnome::Applet::change_pixel_size_impl(int p0)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->change_pixel_size)
      (base->change_pixel_size)(gtkobj(),p0);

  }

void Gnome::Applet_Class::change_position_callback(AppletWidget* o_,int p0,int p1)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      obj->change_position_impl(p0,p1);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->change_position)
          (base->change_position)(o_,p0,p1);
      }

  }

void Gnome::Applet::change_position_impl(int p0,int p1)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->change_position)
      (base->change_position)(gtkobj(),p0,p1);

  }

int Gnome::Applet_Class::save_session_callback(AppletWidget* o_,char* p0,char* p1)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      return obj->save_session_impl(p0,p1);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->save_session)
          return (base->save_session)(o_,p0,p1);
        gtkmm_set_ignore();
      }
    return 0;

  }

int Gnome::Applet::save_session_impl(char* p0,char* p1)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->save_session)
      return (base->save_session)(gtkobj(),p0,p1);
    gtkmm_set_ignore();
    return 0;

  }

void Gnome::Applet_Class::back_change_callback(AppletWidget* o_,GNOME_Panel_BackType p0,char* p1,GdkColor* p2)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      obj->back_change_impl(p0,p1,p2);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->back_change)
          (base->back_change)(o_,p0,p1,p2);
      }

  }

void Gnome::Applet::back_change_impl(GNOME_Panel_BackType p0,char* p1,GdkColor* p2)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->back_change)
      (base->back_change)(gtkobj(),p0,p1,p2);

  }

void Gnome::Applet_Class::tooltip_state_callback(AppletWidget* o_,int p0)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      obj->tooltip_state_impl(p0);
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->tooltip_state)
          (base->tooltip_state)(o_,p0);
      }

  }

void Gnome::Applet::tooltip_state_impl(int p0)
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->tooltip_state)
      (base->tooltip_state)(gtkobj(),p0);

  }

void Gnome::Applet_Class::do_draw_callback(AppletWidget* o_)
  {
    CppObjectType *obj=
      static_cast<CppObjectType *>(static_cast<Gtk::Object *>(
        gtk_object_get_data_by_id((GtkObject*)o_,Gtk::quark_)));

    if (obj)
      obj->do_draw_impl();
    else
      {
        BaseClassType* base=
          static_cast<BaseClassType*>(
            gtk_type_parent_class(((GtkObject*)o_)->klass->type));
        if (base->do_draw)
          (base->do_draw)(o_);
      }

  }

void Gnome::Applet::do_draw_impl()
  {
    BaseClassType* base=
      static_cast<BaseClassType*>(
        gtk_type_parent_class(gtkobject->klass->type));
    if (base->do_draw)
      (base->do_draw)(gtkobj());

  }
