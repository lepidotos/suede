<MACRO>
<NAME>HAVE_ALLOCA</NAME>
#define HAVE_ALLOCA 1
</MACRO>
<MACRO>
<NAME>HAVE_ALLOCA_H</NAME>
#define HAVE_ALLOCA_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MMAP</NAME>
#define HAVE_MMAP 1
</MACRO>
<MACRO>
<NAME>STDC_HEADERS</NAME>
#define STDC_HEADERS 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "GConf"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "1.0.6"
</MACRO>
<MACRO>
<NAME>HAVE_GETTEXT</NAME>
#define HAVE_GETTEXT 1
</MACRO>
<MACRO>
<NAME>HAVE_LC_MESSAGES</NAME>
#define HAVE_LC_MESSAGES 1
</MACRO>
<MACRO>
<NAME>HAVE_STPCPY</NAME>
#define HAVE_STPCPY 1
</MACRO>
<MACRO>
<NAME>ENABLE_NLS</NAME>
#define ENABLE_NLS 1
</MACRO>
<MACRO>
<NAME>GETTEXT_PACKAGE</NAME>
#define GETTEXT_PACKAGE "gconf1"
</MACRO>
<MACRO>
<NAME>HAVE_DB3_DB_H</NAME>
#define HAVE_DB3_DB_H 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_COUNT</NAME>
#define HAVE___ARGZ_COUNT 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_NEXT</NAME>
#define HAVE___ARGZ_NEXT 1
</MACRO>
<MACRO>
<NAME>HAVE___ARGZ_STRINGIFY</NAME>
#define HAVE___ARGZ_STRINGIFY 1
</MACRO>
<MACRO>
<NAME>HAVE_DCGETTEXT</NAME>
#define HAVE_DCGETTEXT 1
</MACRO>
<MACRO>
<NAME>HAVE_FLOCKFILE</NAME>
#define HAVE_FLOCKFILE 1
</MACRO>
<MACRO>
<NAME>HAVE_GETCWD</NAME>
#define HAVE_GETCWD 1
</MACRO>
<MACRO>
<NAME>HAVE_GETPAGESIZE</NAME>
#define HAVE_GETPAGESIZE 1
</MACRO>
<MACRO>
<NAME>HAVE_MUNMAP</NAME>
#define HAVE_MUNMAP 1
</MACRO>
<MACRO>
<NAME>HAVE_NANOSLEEP</NAME>
#define HAVE_NANOSLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_PUTENV</NAME>
#define HAVE_PUTENV 1
</MACRO>
<MACRO>
<NAME>HAVE_SETENV</NAME>
#define HAVE_SETENV 1
</MACRO>
<MACRO>
<NAME>HAVE_SETLOCALE</NAME>
#define HAVE_SETLOCALE 1
</MACRO>
<MACRO>
<NAME>HAVE_STPCPY</NAME>
#define HAVE_STPCPY 1
</MACRO>
<MACRO>
<NAME>HAVE_STRCASECMP</NAME>
#define HAVE_STRCASECMP 1
</MACRO>
<MACRO>
<NAME>HAVE_STRCHR</NAME>
#define HAVE_STRCHR 1
</MACRO>
<MACRO>
<NAME>HAVE_STRDUP</NAME>
#define HAVE_STRDUP 1
</MACRO>
<MACRO>
<NAME>HAVE_USLEEP</NAME>
#define HAVE_USLEEP 1
</MACRO>
<MACRO>
<NAME>HAVE_ARGZ_H</NAME>
#define HAVE_ARGZ_H 1
</MACRO>
<MACRO>
<NAME>HAVE_DB3_DB_H</NAME>
#define HAVE_DB3_DB_H 1
</MACRO>
<MACRO>
<NAME>HAVE_DLFCN_H</NAME>
#define HAVE_DLFCN_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LIMITS_H</NAME>
#define HAVE_LIMITS_H 1
</MACRO>
<MACRO>
<NAME>HAVE_LOCALE_H</NAME>
#define HAVE_LOCALE_H 1
</MACRO>
<MACRO>
<NAME>HAVE_MALLOC_H</NAME>
#define HAVE_MALLOC_H 1
</MACRO>
<MACRO>
<NAME>HAVE_NL_TYPES_H</NAME>
#define HAVE_NL_TYPES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STDLIB_H</NAME>
#define HAVE_STDLIB_H 1
</MACRO>
<MACRO>
<NAME>HAVE_STRING_H</NAME>
#define HAVE_STRING_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_PARAM_H</NAME>
#define HAVE_SYS_PARAM_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_STAT_H</NAME>
#define HAVE_SYS_STAT_H 1
</MACRO>
<MACRO>
<NAME>HAVE_SYS_TYPES_H</NAME>
#define HAVE_SYS_TYPES_H 1
</MACRO>
<MACRO>
<NAME>HAVE_UNISTD_H</NAME>
#define HAVE_UNISTD_H 1
</MACRO>
<MACRO>
<NAME>PACKAGE</NAME>
#define PACKAGE "GConf"
</MACRO>
<MACRO>
<NAME>VERSION</NAME>
#define VERSION "1.0.6"
</MACRO>
<MACRO>
<NAME>HAVE_LC_MESSAGES</NAME>
#define HAVE_LC_MESSAGES 1
</MACRO>
<MACRO>
<NAME>DBD_DIR</NAME>
#define	DBD_DIR	"dir.db"
</MACRO>
<MACRO>
<NAME>DBD_HIERARCHY</NAME>
#define	DBD_HIERARCHY	"hierarchy.db"
</MACRO>
<MACRO>
<NAME>DBD_KEY</NAME>
#define	DBD_KEY	"key.db"
</MACRO>
<MACRO>
<NAME>DBD_VALUE</NAME>
#define	DBD_VALUE	"value.db"
</MACRO>
<MACRO>
<NAME>DBD_SCHEMA</NAME>
#define	DBD_SCHEMA	"schema.db"
</MACRO>
<MACRO>
<NAME>DBD_SCHKEY</NAME>
#define	DBD_SCHKEY	"schkey.db"
</MACRO>
<FUNCTION>
<NAME>bdb_create</NAME>
<RETURNS>int  </RETURNS>
BDB_Store * bdb, const char *dbname
</FUNCTION>
<FUNCTION>
<NAME>bdb_new</NAME>
<RETURNS>BDB_Store  *</RETURNS>
const char *dir, int flags
</FUNCTION>
<MACRO>
<NAME>CLEAR_STRUCT</NAME>
#define CLEAR_STRUCT(x) (memset(&x, 0, sizeof(x)))
</MACRO>
<FUNCTION>
<NAME>temp_string_key</NAME>
<RETURNS>DBT  *</RETURNS>
const char *key
</FUNCTION>
<FUNCTION>
<NAME>temp_int_key</NAME>
<RETURNS>DBT  *</RETURNS>
int akey
</FUNCTION>
<FUNCTION>
<NAME>get_dir_id</NAME>
<RETURNS>guint32  </RETURNS>
BDB_Store * bdb, const char *dir
</FUNCTION>
<FUNCTION>
<NAME>add_key</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *dir, const char *keypath
</FUNCTION>
<FUNCTION>
<NAME>bdb_set_sysname</NAME>
<RETURNS>void  </RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>get_or_create_dir</NAME>
<RETURNS>guint32  </RETURNS>
BDB_Store * bdb, const char *dir
</FUNCTION>
<FUNCTION>
<NAME>bdb_create</NAME>
<RETURNS>int  </RETURNS>
BDB_Store * bdb, const char *dir
</FUNCTION>
<FUNCTION>
<NAME>bdb_open</NAME>
<RETURNS>int  </RETURNS>
BDB_Store * bdb, const char *dir, int flags
</FUNCTION>
<FUNCTION>
<NAME>bdb_close</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb
</FUNCTION>
<FUNCTION>
<NAME>bdb_query_value</NAME>
<RETURNS>GConfValue  *</RETURNS>
BDB_Store * bdb, const char *key,char **schema_name, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_all_dirs</NAME>
<RETURNS>GSList  *</RETURNS>
BDB_Store * bdb, const char *dirname,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_all_entries</NAME>
<RETURNS>GSList  *</RETURNS>
BDB_Store * bdb, const char *dirpath,GSList * inlist, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_put_value</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *key, GConfValue * val,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_all_subdirs</NAME>
<RETURNS>GSList  *</RETURNS>
BDB_Store * bdb, const char *dirname,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_unset_value</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *keypath,const char *locale, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_remove_dir</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *dirname,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_set_schema</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *key,const char *schema_key, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_is_localised</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar * key
</FUNCTION>
<MACRO>
<NAME>struct_dup</NAME>
#define struct_dup(x) g_memdup(&x, sizeof(x))
</MACRO>
<STRUCT>
<NAME>GThreadPool</NAME>
</STRUCT>
<FUNCTION>
<NAME>bdb_serialize_value</NAME>
<RETURNS>char  *</RETURNS>
GConfValue * val, size_t * lenp
</FUNCTION>
<FUNCTION>
<NAME>bdb_restore_value</NAME>
<RETURNS>GConfValue  *</RETURNS>
const char *srz
</FUNCTION>
<STRUCT>
<NAME>Cache</NAME>
</STRUCT>
<FUNCTION>
<NAME>cache_new</NAME>
<RETURNS>Cache *</RETURNS>
const gchar  *root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>cache_destroy</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache
</FUNCTION>
<FUNCTION>
<NAME>cache_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Cache        *cache,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_clean</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,GTime         older_than
</FUNCTION>
<FUNCTION>
<NAME>cache_delete_dir</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_lookup</NAME>
<RETURNS>Dir *</RETURNS>
Cache        *cache,const gchar  *key,gboolean create_if_missing,GError  **err
</FUNCTION>
<STRUCT>
<NAME>Dir</NAME>
</STRUCT>
<FUNCTION>
<NAME>dir_new</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *keyname,const gchar  *xml_root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>dir_load</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *key,const gchar  *xml_root_dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_destroy</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_clear_cache</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_ensure_exists</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_set_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Dir          *d,const gchar  *relative_key,const gchar **locales,gchar       **schema_name,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Dir          *d,const gchar  *relative_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_unset_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_subdirs</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_set_schema</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_last_access</NAME>
<RETURNS>GTime  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_sync_pending</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_mark_deleted</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_is_deleted</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>mode_t_to_mode</NAME>
<RETURNS>guint  </RETURNS>
mode_t orig
</FUNCTION>
<STRUCT>
<NAME>Entry</NAME>
</STRUCT>
<FUNCTION>
<NAME>entry_new</NAME>
<RETURNS>Entry *</RETURNS>
const gchar  *relative_name
</FUNCTION>
<FUNCTION>
<NAME>entry_destroy</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,xmlNodePtr    node
</FUNCTION>
<FUNCTION>
<NAME>entry_get_node</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_fill_from_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_sync_to_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Entry        *entry,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>entry_set_value</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GConfValue   *value
</FUNCTION>
<FUNCTION>
<NAME>entry_unset_value</NAME>
<RETURNS>gboolean  </RETURNS>
Entry        *entry,const gchar  *locale
</FUNCTION>
<FUNCTION>
<NAME>entry_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GTime         mod_time
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *user
</FUNCTION>
<FUNCTION>
<NAME>entry_get_schema_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *e
</FUNCTION>
<FUNCTION>
<NAME>entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>my_xmlSetProp</NAME>
<RETURNS>void  </RETURNS>
xmlNodePtr node,const gchar* name,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>my_xmlGetProp</NAME>
<RETURNS>char *</RETURNS>
xmlNodePtr node,const gchar* name
</FUNCTION>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
struct GConfBackendVTable {
  void                (* shutdown)        (GError** err);

  GConfSource*        (* resolve_address) (const gchar* address,
                                           GError** err);

  /* Thread locks. If the backend is thread-safe, then these
   * can be NULL. If per-source locks are needed, then these
   * calls should lock a mutex stored in the GConfSource.
   * If a per-backend lock is needed, then the calls can ignore
   * their source argument and lock the whole backend.
   */
  void                (* lock)            (GConfSource* source,
                                           GError** err);

  void                (* unlock)          (GConfSource* source,
                                           GError** err);

  /* Report whether a given key (and its subkeys) can be read/written.
   * Sources may not permit reading/writing from/to /foo but forbid
   * writing to /foo/bar; if a key can be read or written then its
   * subkeys may also be read/written.
   *
   * This field allows backends to be configured so that they only
   * store certain kinds of data in certain sections of the GConf
   * namespace.
   *
   * If these functions return an error, they MUST return FALSE as
   * well.
   */

  gboolean           (* readable)         (GConfSource* source,
                                           const gchar* key,
                                           GError** err);

  gboolean           (* writable)        (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  /* schema_name filled if NULL or GCONF_VALUE_IGNORE_SUBSEQUENT returned.
     if schema_name is NULL, it isn't filled */
  GConfValue*         (* query_value)     (GConfSource* source, 
                                           const gchar* key,
                                           const gchar** locales,
                                           gchar** schema_name,
                                           GError** err);
  
  GConfMetaInfo*      (* query_metainfo)  (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  void                (* set_value)       (GConfSource* source, 
                                           const gchar* key, 
                                           GConfValue* value,
                                           GError** err);

  /* Returns list of GConfEntry with key set to a relative
   * pathname. In the public client-side API the key
   * is always absolute though.
   */
  GSList*             (* all_entries)     (GConfSource* source,
                                           const gchar* dir,
                                           const gchar** locales,
                                           GError** err);

  /* Returns list of allocated strings, relative names */
  GSList*             (* all_subdirs)     (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);

  void                (* unset_value)     (GConfSource* source,
                                           const gchar* key,
                                           const gchar* locale,
                                           GError** err);

  gboolean            (* dir_exists)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
        
  void                (* remove_dir)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
  
  void                (* set_schema)      (GConfSource* source,
                                           const gchar* key,
                                           const gchar* schema_key,
                                           GError** err);

  gboolean            (* sync_all)        (GConfSource* source,
                                           GError** err);

  void                (* destroy_source)  (GConfSource* source);

  /* This is basically used by the test suite */
  void                (* clear_cache)     (GConfSource* source);
};
</STRUCT>
<STRUCT>
<NAME>GConfBackend</NAME>
struct GConfBackend {
  const gchar* name;
  guint refcount;
  GConfBackendVTable* vtable;
  GModule* module;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_address_backend</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_resource</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_flags</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_file</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_backend</NAME>
<RETURNS>GConfBackend *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_ref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_unref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
GConfBackend* backend,const gchar* address,GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfChangeSet</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfChangeSetForeachFunc</NAME>
<RETURNS>void </RETURNS>
GConfChangeSet* cs,
                                            const gchar* key,
                                            GConfValue* value,
                                            gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_engine_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine* conf,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GError** err,const gchar* first_key,...
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_new</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_ref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_clear</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_size</NAME>
<RETURNS>guint  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_remove</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_foreach</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,GConfChangeSetForeachFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_check_value</NAME>
<RETURNS>gboolean  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue** value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unset</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gdouble val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gint val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,const gchar* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gboolean val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfSchema* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType list_type,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_pair</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_user_data</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet *cs,gpointer        data,GDestroyNotify  dnotify
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_get_user_data</NAME>
<RETURNS>gpointer  </RETURNS>
GConfChangeSet *cs
</FUNCTION>
<STRUCT>
<NAME>GConfDatabase</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfDatabase</NAME>
struct GConfDatabase
{
  /* "inherit" from the servant,
     must be first in struct */
  POA_ConfigDatabase2 servant;

  ConfigDatabase objref;
  
  GConfListeners* listeners;
  GConfSources* sources;

  GTime last_access;
  guint sync_idle;
  guint sync_timeout;

  gchar *persistent_name;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_database_new</NAME>
<RETURNS>GConfDatabase *</RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_free</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_drop_dead_listeners</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_add_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
GConfDatabase       *db,ConfigListener       who,const gchar         *where
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_remove_listener</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase       *db,CORBA_unsigned_long  cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_readd_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
GConfDatabase       *db,ConfigListener       who,const gchar         *where
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_notify_listeners</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase       *db,const gchar         *key,const ConfigValue   *value,gboolean             is_default,gboolean             is_writable
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_query_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfDatabase  *db,const gchar    *key,const gchar   **locales,gboolean        use_schema_default,gchar         **schema_name,gboolean       *value_is_default,gboolean       *value_is_writable,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_query_default_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfDatabase  *db,const gchar    *key,const gchar   **locales,gboolean       *is_writable,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_set</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase      *db,const gchar        *key,GConfValue         *value,const ConfigValue  *cvalue,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_unset</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase      *db,const gchar        *key,const gchar        *locale,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfDatabase  *db,const gchar    *dir,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,const gchar    *dir,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfDatabase  *db,const gchar    *dir,const gchar   **locales,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfDatabase  *db,const gchar    *dir,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,const gchar    *key,const gchar    *schema_key,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_sync</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_synchronous_sync</NAME>
<RETURNS>gboolean  </RETURNS>
GConfDatabase  *db,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconfd_locale_cache_expire</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconfd_locale_cache_drop</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_get_persistent_name</NAME>
<RETURNS>const gchar *</RETURNS>
GConfDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_log_listeners_to_string</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase *db,gboolean is_default,GString *str
</FUNCTION>
<STRUCT>
<NAME>GConfEngine</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_engine_get_default</NAME>
<RETURNS>GConfEngine *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_for_address</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_unref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_ref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_local</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_user_data</NAME>
<RETURNS>void  </RETURNS>
GConfEngine   *engine,gpointer       data,GDestroyNotify dnotify
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_user_data</NAME>
<RETURNS>gpointer  </RETURNS>
GConfEngine   *engine
</FUNCTION>
<MACRO>
<NAME>GCONF_ERROR</NAME>
#define GCONF_ERROR gconf_error_quark ()
</MACRO>
<ENUM>
<NAME>GConfError</NAME>
typedef enum {
  GCONF_ERROR_SUCCESS = 0,
  GCONF_ERROR_FAILED = 1,        /* Something didn't work, don't know why, probably unrecoverable
                                    so there's no point having a more specific errno */

  GCONF_ERROR_NO_SERVER = 2,     /* Server can't be launched/contacted */
  GCONF_ERROR_NO_PERMISSION = 3, /* don't have permission for that */
  GCONF_ERROR_BAD_ADDRESS = 4,   /* Address couldn't be resolved */
  GCONF_ERROR_BAD_KEY = 5,       /* directory or key isn't valid (contains bad
                                    characters, or malformed slash arrangement) */
  GCONF_ERROR_PARSE_ERROR = 6,   /* Syntax error when parsing */
  GCONF_ERROR_CORRUPT = 7,       /* Fatal error parsing/loading information inside the backend */
  GCONF_ERROR_TYPE_MISMATCH = 8, /* Type requested doesn't match type found */
  GCONF_ERROR_IS_DIR = 9,        /* Requested key operation on a dir */
  GCONF_ERROR_IS_KEY = 10,       /* Requested dir operation on a key */
  GCONF_ERROR_OVERRIDDEN = 11,   /* Read-only source at front of path has set the value */
  GCONF_ERROR_OAF_ERROR = 12,    /* liboaf error */
  GCONF_ERROR_LOCAL_ENGINE = 13, /* Tried to use remote operations on a local engine */
  GCONF_ERROR_LOCK_FAILED = 14,  /* Failed to get a lockfile */
  GCONF_ERROR_NO_WRITABLE_DATABASE = 15, /* nowhere to write a value */
  GCONF_ERROR_IN_SHUTDOWN = 16   /* server is shutting down */
} GConfError;
</ENUM>
<FUNCTION>
<NAME>gconf_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GError</NAME>
</STRUCT>
<STRUCT>
<NAME>GError</NAME>
struct GError
{
  GQuark       domain;
  gint         code;
  gchar       *message;
};
</STRUCT>
<FUNCTION>
<NAME>g_error_new</NAME>
<RETURNS>GError *</RETURNS>
GQuark         domain,gint           code,const gchar   *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_error_new_literal</NAME>
<RETURNS>GError *</RETURNS>
GQuark         domain,gint           code,const gchar   *message
</FUNCTION>
<FUNCTION>
<NAME>g_error_free</NAME>
<RETURNS>void  </RETURNS>
GError        *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_copy</NAME>
<RETURNS>GError *</RETURNS>
const GError  *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_matches</NAME>
<RETURNS>gboolean  </RETURNS>
const GError  *error,GQuark         domain,gint           code
</FUNCTION>
<FUNCTION>
<NAME>g_set_error</NAME>
<RETURNS>void  </RETURNS>
GError       **err,GQuark         domain,gint           code,const gchar   *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_clear_error</NAME>
<RETURNS>void  </RETURNS>
GError       **err
</FUNCTION>
<FUNCTION>
<NAME>g_propagate_error</NAME>
<RETURNS>void  </RETURNS>
GError       **dest,GError        *src
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_directory</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_key</NAME>
<RETURNS>const gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_test</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename, int test
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_exists</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_from_corba_value</NAME>
<RETURNS>GConfValue *</RETURNS>
const ConfigValue *value
</FUNCTION>
<FUNCTION>
<NAME>corba_value_from_gconf_value</NAME>
<RETURNS>ConfigValue *</RETURNS>
GConfValue        *value
</FUNCTION>
<FUNCTION>
<NAME>fill_corba_value_from_gconf_value</NAME>
<RETURNS>void  </RETURNS>
GConfValue        *value,ConfigValue       *dest
</FUNCTION>
<FUNCTION>
<NAME>invalid_corba_value</NAME>
<RETURNS>ConfigValue *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_object_to_string</NAME>
<RETURNS>gchar *</RETURNS>
CORBA_Object obj,GError **err
</FUNCTION>
<FUNCTION>
<NAME>fill_corba_schema_from_gconf_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSchema        *sc,ConfigSchema       *dest
</FUNCTION>
<FUNCTION>
<NAME>corba_schema_from_gconf_schema</NAME>
<RETURNS>ConfigSchema *</RETURNS>
GConfSchema        *sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_from_corba_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
const ConfigSchema *cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_from_string</NAME>
<RETURNS>GConfValueType  </RETURNS>
const gchar    *str
</FUNCTION>
<FUNCTION>
<NAME>gconf_load_source_path</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* filename, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_shutdown_daemon</NAME>
<RETURNS>void  </RETURNS>
GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_ping_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_spawn_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_gulong</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_double</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *str,gdouble     *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_double_to_string</NAME>
<RETURNS>gchar *</RETURNS>
gdouble      val
</FUNCTION>
<FUNCTION>
<NAME>gconf_current_locale</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GConfLogPriority</NAME>
typedef enum {
  GCL_EMERG,
  GCL_ALERT,
  GCL_CRIT,
  GCL_ERR,
  GCL_WARNING,
  GCL_NOTICE,
  GCL_INFO,
  GCL_DEBUG
} GConfLogPriority;
</ENUM>
<FUNCTION>
<NAME>gconf_log</NAME>
<RETURNS>void  </RETURNS>
GConfLogPriority pri, const gchar* format, ...
</FUNCTION>
<VARIABLE>
<NAME>gconf_log_debug_messages</NAME>
extern gboolean gconf_log_debug_messages;
</VARIABLE>
<FUNCTION>
<NAME>gconf_key_check</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type,const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_list_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType list_type,const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_pair_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType car_type,GConfValueType cdr_type,const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *str
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *str,const gchar **end,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string_inplace</NAME>
<RETURNS>void  </RETURNS>
gchar        *str,gchar       **end,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_decode</NAME>
<RETURNS>GConfValue *</RETURNS>
const gchar *encoded
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_encode</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_percents</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_from_primitive_list</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType  list_type,GSList         *list,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_from_primitive_pair</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType  car_type,GConfValueType  cdr_type,gconstpointer   address_of_car,gconstpointer   address_of_cdr,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_to_primitive_list_destructive</NAME>
<RETURNS>GSList *</RETURNS>
GConfValue      *val,GConfValueType   list_type,GError         **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_to_primitive_pair_destructive</NAME>
<RETURNS>gboolean  </RETURNS>
GConfValue      *val,GConfValueType   car_type,GConfValueType   cdr_type,gpointer         car_retloc,gpointer         cdr_retloc,GError         **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_mode</NAME>
<RETURNS>void  </RETURNS>
gboolean     setting
</FUNCTION>
<FUNCTION>
<NAME>gconf_in_daemon_mode</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_ior</NAME>
<RETURNS>void  </RETURNS>
const gchar *ior
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_daemon_ior</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_handle_oaf_exception</NAME>
<RETURNS>gboolean  </RETURNS>
CORBA_Environment* ev, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_nanosleep</NAME>
<RETURNS>void  </RETURNS>
gulong useconds
</FUNCTION>
<STRUCT>
<NAME>GConfLock</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_get_lock</NAME>
<RETURNS>GConfLock *</RETURNS>
const gchar  *lock_directory,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_release_lock</NAME>
<RETURNS>gboolean  </RETURNS>
GConfLock    *lock,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_lock_or_current_holder</NAME>
<RETURNS>GConfLock *</RETURNS>
const gchar  *lock_directory,ConfigServer *current_server,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_current_lock_holder</NAME>
<RETURNS>ConfigServer  </RETURNS>
const gchar *lock_directory
</FUNCTION>
<FUNCTION>
<NAME>gconf_error_new</NAME>
<RETURNS>GError *</RETURNS>
GConfError en,const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_error</NAME>
<RETURNS>void  </RETURNS>
GError** err,GConfError en,const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>gconf_compose_errors</NAME>
<RETURNS>GError *</RETURNS>
GError* err1, GError* err2
</FUNCTION>
<FUNCTION>
<NAME>gconf_orb_get</NAME>
<RETURNS>CORBA_ORB  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_activate_server</NAME>
<RETURNS>ConfigServer  </RETURNS>
gboolean  start_if_not_found,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_lock_dir</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_daemon_dir</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_validate</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSchema *sc,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_validate</NAME>
<RETURNS>gboolean  </RETURNS>
GConfValue *value,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_validate</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *str,gssize        max_len,const gchar **end
</FUNCTION>
<MACRO>
<NAME>_</NAME>
#    define _(String) dgettext (GETTEXT_PACKAGE, String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#        define N_(String) gettext_noop (String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#        define N_(String) (String)
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
#    define textdomain(String) (String)
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
#    define bindtextdomain(Domain,Directory) (Domain)
</MACRO>
<MACRO>
<NAME>_</NAME>
#    define _(String) (String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#    define N_(String) (String)
</MACRO>
<STRUCT>
<NAME>GConfListeners</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfListenersCallback</NAME>
<RETURNS>void </RETURNS>
GConfListeners* listeners,
                                       const gchar*    all_above_key,
                                       guint           cnxn_id,
                                       gpointer        listener_data,
                                       gpointer        user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfListenersForeach</NAME>
<RETURNS>void </RETURNS>
const gchar* location,
                                       guint        cnxn_id,
                                       gpointer     listener_data,
                                       gpointer     user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfListenersPredicate</NAME>
<RETURNS>gboolean </RETURNS>
const gchar* location,
                                             guint        cnxn_id,
                                             gpointer     listener_data,
                                             gpointer     user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_new</NAME>
<RETURNS>GConfListeners *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_free</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_add</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners* listeners,const gchar* listen_point,gpointer listener_data,GFreeFunc destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_remove</NAME>
<RETURNS>void  </RETURNS>
GConfListeners          *listeners,guint                    cnxn_id
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_notify</NAME>
<RETURNS>void  </RETURNS>
GConfListeners          *listeners,const gchar             *all_above,GConfListenersCallback   callback,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_count</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners          *listeners
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_foreach</NAME>
<RETURNS>void  </RETURNS>
GConfListeners          *listeners,GConfListenersForeach    callback,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_get_data</NAME>
<RETURNS>gboolean  </RETURNS>
GConfListeners          *listeners,guint                    cnxn_id,gpointer                *listener_data_p,const gchar            **location_p
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_remove_if</NAME>
<RETURNS>void  </RETURNS>
GConfListeners         *listeners,GConfListenersPredicate predicate,gpointer                user_data
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleCache</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_cache_new</NAME>
<RETURNS>GConfLocaleCache *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_free</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_expire</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache,guint max_age_exclusive_in_seconds
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleList</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfLocaleList</NAME>
struct GConfLocaleList {
  const gchar** list;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_list_ref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_list_unref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_get_list</NAME>
<RETURNS>GConfLocaleList *</RETURNS>
GConfLocaleCache* cache,const gchar* locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_split_locale</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* locale
</FUNCTION>
<STRUCT>
<NAME>GConfSchema</NAME>
struct GConfSchema {
  GConfValueType type; /* Type of the described entry */
  GConfValueType list_type; /* List type of the described entry */
  GConfValueType car_type; /* Pair car type of the described entry */
  GConfValueType cdr_type; /* Pair cdr type of the described entry */
  gchar* locale;       /* Schema locale */
  gchar* owner;        /* Name of creating application */
  gchar* short_desc;   /* 40 char or less description, no newlines */
  gchar* long_desc;    /* could be a paragraph or so */
  GConfValue* default_value; /* Default value of the key */
};
</STRUCT>
<FUNCTION>
<NAME>gconf_schema_new</NAME>
<RETURNS>GConfSchema *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_free</NAME>
<RETURNS>void  </RETURNS>
GConfSchema *sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_copy</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfSchema *sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_list_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_car_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_cdr_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_locale</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_short_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_long_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_owner</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *owner
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValue     *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValue     *val
</FUNCTION>
<MACRO>
<NAME>gconf_schema_get_type</NAME>
#define       gconf_schema_get_type(x)          (x->type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_list_type</NAME>
#define       gconf_schema_get_list_type(x)     (x->list_type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_car_type</NAME>
#define       gconf_schema_get_car_type(x)      (x->car_type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_cdr_type</NAME>
#define       gconf_schema_get_cdr_type(x)      (x->cdr_type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_locale</NAME>
#define       gconf_schema_get_locale(x)        ((const gchar*)(x)->locale)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_short_desc</NAME>
#define       gconf_schema_get_short_desc(x)    ((const gchar*)(x)->short_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_long_desc</NAME>
#define       gconf_schema_get_long_desc(x)     ((const gchar*)(x)->long_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_owner</NAME>
#define       gconf_schema_get_owner(x)         ((const gchar*)(x)->owner)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_default_value</NAME>
#define       gconf_schema_get_default_value(x) ((x)->default_value)
</MACRO>
<STRUCT>
<NAME>GConfBackend</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
struct GConfSource {
  guint flags;
  gchar* address;
  GConfBackend* backend;
};
</STRUCT>
<ENUM>
<NAME>GConfSourceFlags</NAME>
typedef enum {
  /* These are an optimization to avoid calls to
   * the writable/readable methods in the backend
   * vtable
   */
  GCONF_SOURCE_ALL_WRITEABLE = 1 << 0,
  GCONF_SOURCE_ALL_READABLE = 1 << 1,
  GCONF_SOURCE_NEVER_WRITEABLE = 1 << 2, 
  GCONF_SOURCE_ALL_FLAGS = ((1 << 0) | (1 << 1))
} GConfSourceFlags;
</ENUM>
<FUNCTION>
<NAME>gconf_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
const gchar* address,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_source_free</NAME>
<RETURNS>void  </RETURNS>
GConfSource* source
</FUNCTION>
<STRUCT>
<NAME>GConfSources</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSources</NAME>
struct GConfSources {
  GList* sources;
  
};
</STRUCT>
<FUNCTION>
<NAME>gconf_sources_new_from_addresses</NAME>
<RETURNS>GConfSources *</RETURNS>
const gchar **addresses,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_new_from_source</NAME>
<RETURNS>GConfSources *</RETURNS>
GConfSource   *source
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_free</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources  *sources,const gchar   *key,const gchar  **locales,gboolean       use_schema_default,gboolean      *value_is_default,gboolean      *value_is_writable,gchar        **schema_name,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,GConfValue    *value,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_unset_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *locale,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,const gchar  **locales,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *schema_key,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_sync_all</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
GConfSources* sources,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_default_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources* sources,const gchar* key,const gchar** locales,gboolean* is_writable,GError** err
</FUNCTION>
<ENUM>
<NAME>GConfValueType</NAME>
typedef enum {
  GCONF_VALUE_INVALID,
  GCONF_VALUE_STRING,
  GCONF_VALUE_INT,
  GCONF_VALUE_FLOAT,
  GCONF_VALUE_BOOL,
  GCONF_VALUE_SCHEMA,

  /* unfortunately these aren't really types; we want list_of_string,
     list_of_int, etc.  but it's just too complicated to implement.
     instead we'll complain in various places if you do something
     moronic like mix types in a list or treat pair<string,int> and
     pair<float,bool> as the same type. */
  GCONF_VALUE_LIST,
  GCONF_VALUE_PAIR
  
} GConfValueType;
</ENUM>
<MACRO>
<NAME>GCONF_VALUE_TYPE_VALID</NAME>
#define GCONF_VALUE_TYPE_VALID(x) (((x) > GCONF_VALUE_INVALID) && ((x) <= GCONF_VALUE_PAIR))
</MACRO>
<STRUCT>
<NAME>GConfSchema</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
struct GConfValue {
  GConfValueType type;
  union {
    gchar* string_data;
    gint int_data;
    gboolean bool_data;
    gdouble float_data;
    GConfSchema* schema_data;
    struct {
      GConfValueType type;
      GSList* list;
    } list_data;
    struct {
      GConfValue* car;
      GConfValue* cdr;
    } pair_data;
  } d;
};
</STRUCT>
<MACRO>
<NAME>gconf_value_get_string</NAME>
#define gconf_value_get_string(x)    ((const gchar*)((x)->d.string_data))
</MACRO>
<MACRO>
<NAME>gconf_value_get_int</NAME>
#define gconf_value_get_int(x)       ((x)->d.int_data)
</MACRO>
<MACRO>
<NAME>gconf_value_get_float</NAME>
#define gconf_value_get_float(x)     ((x)->d.float_data)
</MACRO>
<MACRO>
<NAME>gconf_value_get_list_type</NAME>
#define gconf_value_get_list_type(x) ((x)->d.list_data.type)
</MACRO>
<MACRO>
<NAME>gconf_value_get_list</NAME>
#define gconf_value_get_list(x)      ((x)->d.list_data.list)
</MACRO>
<MACRO>
<NAME>gconf_value_get_car</NAME>
#define gconf_value_get_car(x)       ((x)->d.pair_data.car)
</MACRO>
<MACRO>
<NAME>gconf_value_get_cdr</NAME>
#define gconf_value_get_cdr(x)       ((x)->d.pair_data.cdr)
</MACRO>
<MACRO>
<NAME>gconf_value_get_bool</NAME>
#define gconf_value_get_bool(x)      ((x)->d.bool_data)
</MACRO>
<MACRO>
<NAME>gconf_value_get_schema</NAME>
#define gconf_value_get_schema(x)    ((x)->d.schema_data)
</MACRO>
<FUNCTION>
<NAME>gconf_value_new</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_copy</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValue* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_free</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gint the_int
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,const gchar* the_str
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gdouble the_float
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gboolean the_bool
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_type</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_to_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue* value
</FUNCTION>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
struct GConfMetaInfo {
  gchar* schema;
  gchar* mod_user; /* user owning the daemon that made the last modification */
  GTime  mod_time; /* time of the modification */
};
</STRUCT>
<MACRO>
<NAME>gconf_meta_info_get_schema</NAME>
#define gconf_meta_info_get_schema(x)    ((const gchar*)(x)->schema)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_get_mod_user</NAME>
#define gconf_meta_info_get_mod_user(x)  ((x)->mod_user)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_mod_time</NAME>
#define gconf_meta_info_mod_time(x)  ((x)->mod_time)
</MACRO>
<FUNCTION>
<NAME>gconf_meta_info_new</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_free</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* schema_name
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* mod_user
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,GTime mod_time
</FUNCTION>
<STRUCT>
<NAME>GConfEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEntry</NAME>
struct GConfEntry {
  gchar* key;
  GConfValue* value;
  gchar* schema_name;
  guint is_default : 1;
  guint is_writable : 1;
};
</STRUCT>
<MACRO>
<NAME>gconf_entry_get_key</NAME>
#define     gconf_entry_get_key(x)         ((const gchar*)(x)->key)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_value</NAME>
#define     gconf_entry_get_value(x)       ((x)->value)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_schema_name</NAME>
#define     gconf_entry_get_schema_name(x) ((const gchar*)(x)->schema_name)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_is_default</NAME>
#define     gconf_entry_get_is_default(x)  ((x)->is_default)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_is_writable</NAME>
#define     gconf_entry_get_is_writable(x) ((x)->is_writable)
</MACRO>
<FUNCTION>
<NAME>gconf_entry_new</NAME>
<RETURNS>GConfEntry *</RETURNS>
const gchar *key,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_new_nocopy</NAME>
<RETURNS>GConfEntry *</RETURNS>
gchar       *key,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_free</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_steal_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_value</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_is_default</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,gboolean     is_default
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_is_writable</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,gboolean     is_writable
</FUNCTION>
<FUNCTION>
<NAME>gconf_is_initialized</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GConfNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfEngine* conf,
                                 guint cnxn_id,
                                 GConfEntry *entry,
                                 gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_engine_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfEngine      *conf,const gchar      *namespace_section,GConfNotifyFunc   func,gpointer          user_data,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfEngine      *conf,guint             cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_entry</NAME>
<RETURNS>GConfEntry *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,gboolean      use_schema_default,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_with_locale</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_associate_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine  *conf,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf,const gchar* dir,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_key_is_writable</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine *conf,const gchar *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_valid_key</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *key,gchar       **why_invalid
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_is_below</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *above,const gchar  *below
</FUNCTION>
<FUNCTION>
<NAME>gconf_concat_dir_and_key</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *dir,const gchar  *key
</FUNCTION>
<FUNCTION>
<NAME>gconf_unique_key</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gpointer         car_retloc,gpointer         cdr_retloc,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gdouble          val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gint             val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,const gchar     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gboolean         val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfSchema     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GSList          *list,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gconstpointer    address_of_car,gconstpointer    address_of_cdr,GError     **err
</FUNCTION>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
struct GConfEnumStringPair {
  gint enum_value;
  const gchar* str;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_string_to_enum</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEnumStringPair  lookup_table[],const gchar         *str,gint                *enum_value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_enum_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfEnumStringPair  lookup_table[],gint                 enum_value
</FUNCTION>
<FUNCTION>
<NAME>gconf_init</NAME>
<RETURNS>gboolean  </RETURNS>
int argc, char **argv, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_preinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<FUNCTION>
<NAME>gconf_postinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<FUNCTION>
<NAME>gconf_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_full</NAME>
<RETURNS>GConfValue  *</RETURNS>
GConfEngine *conf,const gchar *key,const gchar *locale,gboolean use_schema_default,gboolean *is_default_p,gboolean *is_writable_p,GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_poa</NAME>
<RETURNS>PortableServer_POA  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>gconf_set_exception</NAME>
<RETURNS>gboolean  </RETURNS>
GError** err, CORBA_Environment* ev
</FUNCTION>
<FUNCTION>
<NAME>gconfd_logfile_change_listener</NAME>
<RETURNS>gboolean  </RETURNS>
GConfDatabase *db,gboolean add,guint connection_id,ConfigListener listener,const gchar *where,GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconfd_check_in_shutdown</NAME>
<RETURNS>gboolean  </RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>gconfd_need_log_cleanup</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ORBIT_IDL_SERIAL</NAME>
#define ORBIT_IDL_SERIAL 9
</MACRO>
<MACRO>
<NAME>GConf_H</NAME>
#define GConf_H 1
</MACRO>
<ENUM>
<NAME>ConfigBasicValueType</NAME>
   typedef enum
   {
      BInvalidVal,
      BIntVal,
      BStringVal,
      BFloatVal,
      BBoolVal,
      BSchemaVal
   }
   ConfigBasicValueType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_0</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_1</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_2</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_3</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValueType_4</NAME>
#define TC_IMPL_TC_ConfigBasicValueType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigBasicValueType</NAME>
#define TC_ConfigBasicValueType ((CORBA_TypeCode)&TC_ConfigBasicValueType_struct)
</MACRO>
<ENUM>
<NAME>ConfigValueType</NAME>
   typedef enum
   {
      InvalidVal,
      IntVal,
      StringVal,
      FloatVal,
      BoolVal,
      SchemaVal,
      ListVal,
      PairVal
   }
   ConfigValueType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_0</NAME>
#define TC_IMPL_TC_ConfigValueType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_1</NAME>
#define TC_IMPL_TC_ConfigValueType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_2</NAME>
#define TC_IMPL_TC_ConfigValueType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_3</NAME>
#define TC_IMPL_TC_ConfigValueType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValueType_4</NAME>
#define TC_IMPL_TC_ConfigValueType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigValueType</NAME>
#define TC_ConfigValueType ((CORBA_TypeCode)&TC_ConfigValueType_struct)
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_0</NAME>
#define TC_IMPL_TC_ConfigSchema_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_1</NAME>
#define TC_IMPL_TC_ConfigSchema_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_2</NAME>
#define TC_IMPL_TC_ConfigSchema_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_3</NAME>
#define TC_IMPL_TC_ConfigSchema_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigSchema_4</NAME>
#define TC_IMPL_TC_ConfigSchema_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigSchema</NAME>
#define TC_ConfigSchema ((CORBA_TypeCode)&TC_ConfigSchema_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigSchema__alloc</NAME>
<RETURNS>ConfigSchema  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigSchema__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_0</NAME>
#define TC_IMPL_TC_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_1</NAME>
#define TC_IMPL_TC_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_2</NAME>
#define TC_IMPL_TC_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_3</NAME>
#define TC_IMPL_TC_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigBasicValue_4</NAME>
#define TC_IMPL_TC_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigBasicValue</NAME>
#define TC_ConfigBasicValue ((CORBA_TypeCode)&TC_ConfigBasicValue_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigBasicValue__alloc</NAME>
<RETURNS>ConfigBasicValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigBasicValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_ConfigBasicValue</NAME>
#define ORBIT_DECL_CORBA_sequence_ConfigBasicValue 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigBasicValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_ConfigBasicValue</NAME>
#define TC_CORBA_sequence_ConfigBasicValue ((CORBA_TypeCode)&TC_CORBA_sequence_ConfigBasicValue_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigBasicValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>BasicValueList</NAME>
   typedef CORBA_sequence_ConfigBasicValue BasicValueList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_0</NAME>
#define TC_IMPL_TC_BasicValueList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_1</NAME>
#define TC_IMPL_TC_BasicValueList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_2</NAME>
#define TC_IMPL_TC_BasicValueList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_3</NAME>
#define TC_IMPL_TC_BasicValueList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_BasicValueList_4</NAME>
#define TC_IMPL_TC_BasicValueList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_BasicValueList</NAME>
#define TC_BasicValueList ((CORBA_TypeCode)&TC_BasicValueList_struct)
</MACRO>
<FUNCTION>
<NAME>BasicValueList__alloc</NAME>
<RETURNS>BasicValueList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>BasicValueList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_0</NAME>
#define TC_IMPL_TC_ConfigList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_1</NAME>
#define TC_IMPL_TC_ConfigList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_2</NAME>
#define TC_IMPL_TC_ConfigList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_3</NAME>
#define TC_IMPL_TC_ConfigList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigList_4</NAME>
#define TC_IMPL_TC_ConfigList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigList</NAME>
#define TC_ConfigList ((CORBA_TypeCode)&TC_ConfigList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigList__alloc</NAME>
<RETURNS>ConfigList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_0</NAME>
#define TC_IMPL_TC_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_1</NAME>
#define TC_IMPL_TC_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_2</NAME>
#define TC_IMPL_TC_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_3</NAME>
#define TC_IMPL_TC_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigValue_4</NAME>
#define TC_IMPL_TC_ConfigValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigValue</NAME>
#define TC_ConfigValue ((CORBA_TypeCode)&TC_ConfigValue_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigValue__alloc</NAME>
<RETURNS>ConfigValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigDatabase</NAME>
#define ORBIT_DECL_ConfigDatabase 1
</MACRO>
<MACRO>
<NAME>ConfigDatabase__free</NAME>
#define ConfigDatabase__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigDatabase</NAME>
   typedef CORBA_Object ConfigDatabase;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigDatabase__classid</NAME>
   extern CORBA_unsigned_long ConfigDatabase__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_0</NAME>
#define TC_IMPL_TC_ConfigDatabase_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_1</NAME>
#define TC_IMPL_TC_ConfigDatabase_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_2</NAME>
#define TC_IMPL_TC_ConfigDatabase_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_3</NAME>
#define TC_IMPL_TC_ConfigDatabase_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_4</NAME>
#define TC_IMPL_TC_ConfigDatabase_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase</NAME>
#define TC_ConfigDatabase ((CORBA_TypeCode)&TC_ConfigDatabase_struct)
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_ConfigListener</NAME>
#define ORBIT_DECL_ConfigListener 1
</MACRO>
<MACRO>
<NAME>ConfigListener__free</NAME>
#define ConfigListener__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigListener</NAME>
   typedef CORBA_Object ConfigListener;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigListener__classid</NAME>
   extern CORBA_unsigned_long ConfigListener__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_0</NAME>
#define TC_IMPL_TC_ConfigListener_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_1</NAME>
#define TC_IMPL_TC_ConfigListener_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_2</NAME>
#define TC_IMPL_TC_ConfigListener_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_3</NAME>
#define TC_IMPL_TC_ConfigListener_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_4</NAME>
#define TC_IMPL_TC_ConfigListener_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigListener</NAME>
#define TC_ConfigListener ((CORBA_TypeCode)&TC_ConfigListener_struct)
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_string</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_string 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string_allocbuf</NAME>
<RETURNS>CORBA_char  **</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_string</NAME>
#define TC_CORBA_sequence_CORBA_string ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigListener_KeyList</NAME>
   typedef CORBA_sequence_CORBA_string ConfigListener_KeyList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_KeyList_0</NAME>
#define TC_IMPL_TC_ConfigListener_KeyList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_KeyList_1</NAME>
#define TC_IMPL_TC_ConfigListener_KeyList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_KeyList_2</NAME>
#define TC_IMPL_TC_ConfigListener_KeyList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_KeyList_3</NAME>
#define TC_IMPL_TC_ConfigListener_KeyList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigListener_KeyList_4</NAME>
#define TC_IMPL_TC_ConfigListener_KeyList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigListener_KeyList</NAME>
#define TC_ConfigListener_KeyList ((CORBA_TypeCode)&TC_ConfigListener_KeyList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigListener_KeyList__alloc</NAME>
<RETURNS>ConfigListener_KeyList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_KeyList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<ENUM>
<NAME>ConfigErrorType</NAME>
   typedef enum
   {
      ConfigFailed,
      ConfigNoPermission,
      ConfigBadAddress,
      ConfigBadKey,
      ConfigParseError,
      ConfigCorrupt,
      ConfigTypeMismatch,
      ConfigIsDir,
      ConfigIsKey,
      ConfigOverridden,
      ConfigLockFailed,
      ConfigNoWritableDatabase,
      ConfigInShutdown
   }
   ConfigErrorType;
</ENUM>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_0</NAME>
#define TC_IMPL_TC_ConfigErrorType_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_1</NAME>
#define TC_IMPL_TC_ConfigErrorType_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_2</NAME>
#define TC_IMPL_TC_ConfigErrorType_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_3</NAME>
#define TC_IMPL_TC_ConfigErrorType_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigErrorType_4</NAME>
#define TC_IMPL_TC_ConfigErrorType_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigErrorType</NAME>
#define TC_ConfigErrorType ((CORBA_TypeCode)&TC_ConfigErrorType_struct)
</MACRO>
<MACRO>
<NAME>ex_ConfigException</NAME>
#define ex_ConfigException "IDL:ConfigException:1.0"
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_0</NAME>
#define TC_IMPL_TC_ConfigException_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_1</NAME>
#define TC_IMPL_TC_ConfigException_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_2</NAME>
#define TC_IMPL_TC_ConfigException_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_3</NAME>
#define TC_IMPL_TC_ConfigException_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigException_4</NAME>
#define TC_IMPL_TC_ConfigException_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigException</NAME>
#define TC_ConfigException ((CORBA_TypeCode)&TC_ConfigException_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigException__alloc</NAME>
<RETURNS>ConfigException  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigException__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigDatabase</NAME>
#define ORBIT_DECL_ConfigDatabase 1
</MACRO>
<MACRO>
<NAME>ConfigDatabase__free</NAME>
#define ConfigDatabase__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigDatabase</NAME>
   typedef CORBA_Object ConfigDatabase;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigDatabase__classid</NAME>
   extern CORBA_unsigned_long ConfigDatabase__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_0</NAME>
#define TC_IMPL_TC_ConfigDatabase_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_1</NAME>
#define TC_IMPL_TC_ConfigDatabase_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_2</NAME>
#define TC_IMPL_TC_ConfigDatabase_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_3</NAME>
#define TC_IMPL_TC_ConfigDatabase_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_4</NAME>
#define TC_IMPL_TC_ConfigDatabase_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase</NAME>
#define TC_ConfigDatabase ((CORBA_TypeCode)&TC_ConfigDatabase_struct)
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_string</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_string 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string_allocbuf</NAME>
<RETURNS>CORBA_char  **</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_string</NAME>
#define TC_CORBA_sequence_CORBA_string ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigDatabase_KeyList</NAME>
   typedef CORBA_sequence_CORBA_string ConfigDatabase_KeyList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_KeyList_0</NAME>
#define TC_IMPL_TC_ConfigDatabase_KeyList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_KeyList_1</NAME>
#define TC_IMPL_TC_ConfigDatabase_KeyList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_KeyList_2</NAME>
#define TC_IMPL_TC_ConfigDatabase_KeyList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_KeyList_3</NAME>
#define TC_IMPL_TC_ConfigDatabase_KeyList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_KeyList_4</NAME>
#define TC_IMPL_TC_ConfigDatabase_KeyList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase_KeyList</NAME>
#define TC_ConfigDatabase_KeyList ((CORBA_TypeCode)&TC_ConfigDatabase_KeyList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigDatabase_KeyList__alloc</NAME>
<RETURNS>ConfigDatabase_KeyList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_KeyList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_ConfigValue</NAME>
#define ORBIT_DECL_CORBA_sequence_ConfigValue 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_ConfigValue_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_ConfigValue_4 'f'
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue_allocbuf</NAME>
<RETURNS>ConfigValue  *</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_ConfigValue_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_ConfigValue_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_ConfigValue</NAME>
#define TC_CORBA_sequence_ConfigValue ((CORBA_TypeCode)&TC_CORBA_sequence_ConfigValue_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue__alloc</NAME>
<RETURNS>CORBA_sequence_ConfigValue  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CORBA_sequence_ConfigValue__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigDatabase_ValueList</NAME>
   typedef CORBA_sequence_ConfigValue ConfigDatabase_ValueList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_ValueList_0</NAME>
#define TC_IMPL_TC_ConfigDatabase_ValueList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_ValueList_1</NAME>
#define TC_IMPL_TC_ConfigDatabase_ValueList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_ValueList_2</NAME>
#define TC_IMPL_TC_ConfigDatabase_ValueList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_ValueList_3</NAME>
#define TC_IMPL_TC_ConfigDatabase_ValueList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_ValueList_4</NAME>
#define TC_IMPL_TC_ConfigDatabase_ValueList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase_ValueList</NAME>
#define TC_ConfigDatabase_ValueList ((CORBA_TypeCode)&TC_ConfigDatabase_ValueList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigDatabase_ValueList__alloc</NAME>
<RETURNS>ConfigDatabase_ValueList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_ValueList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_boolean</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_boolean 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean_allocbuf</NAME>
<RETURNS>CORBA_boolean  *</RETURNS>
CORBA_unsigned_longlen
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_boolean</NAME>
#define TC_CORBA_sequence_CORBA_boolean ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_boolean_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigDatabase_IsDefaultList</NAME>
   typedef CORBA_sequence_CORBA_boolean ConfigDatabase_IsDefaultList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsDefaultList_0</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsDefaultList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsDefaultList_1</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsDefaultList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsDefaultList_2</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsDefaultList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsDefaultList_3</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsDefaultList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsDefaultList_4</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsDefaultList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase_IsDefaultList</NAME>
#define TC_ConfigDatabase_IsDefaultList ((CORBA_TypeCode)&TC_ConfigDatabase_IsDefaultList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigDatabase_IsDefaultList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_boolean</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_boolean 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean_allocbuf</NAME>
<RETURNS>CORBA_boolean  *</RETURNS>
CORBA_unsigned_longlen
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_boolean_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_boolean</NAME>
#define TC_CORBA_sequence_CORBA_boolean ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_boolean_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_boolean__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigDatabase_IsWritableList</NAME>
   typedef CORBA_sequence_CORBA_boolean ConfigDatabase_IsWritableList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsWritableList_0</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsWritableList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsWritableList_1</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsWritableList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsWritableList_2</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsWritableList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsWritableList_3</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsWritableList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase_IsWritableList_4</NAME>
#define TC_IMPL_TC_ConfigDatabase_IsWritableList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase_IsWritableList</NAME>
#define TC_ConfigDatabase_IsWritableList ((CORBA_TypeCode)&TC_ConfigDatabase_IsWritableList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigDatabase_IsWritableList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigDatabase2</NAME>
#define ORBIT_DECL_ConfigDatabase2 1
</MACRO>
<MACRO>
<NAME>ConfigDatabase2__free</NAME>
#define ConfigDatabase2__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigDatabase2</NAME>
   typedef CORBA_Object ConfigDatabase2;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigDatabase2__classid</NAME>
   extern CORBA_unsigned_long ConfigDatabase2__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_0</NAME>
#define TC_IMPL_TC_ConfigDatabase2_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_1</NAME>
#define TC_IMPL_TC_ConfigDatabase2_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_2</NAME>
#define TC_IMPL_TC_ConfigDatabase2_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_3</NAME>
#define TC_IMPL_TC_ConfigDatabase2_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_4</NAME>
#define TC_IMPL_TC_ConfigDatabase2_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase2</NAME>
#define TC_ConfigDatabase2 ((CORBA_TypeCode)&TC_ConfigDatabase2_struct)
</MACRO>
<MACRO>
<NAME>ORBIT_DECL_CORBA_sequence_CORBA_string</NAME>
#define ORBIT_DECL_CORBA_sequence_CORBA_string 1
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_0</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_1</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_2</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_3</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>ORBIT_IMPL_CORBA_sequence_CORBA_string_4</NAME>
#define ORBIT_IMPL_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string_allocbuf</NAME>
<RETURNS>CORBA_char  **</RETURNS>
CORBA_unsigned_long len
</FUNCTION>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_0</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_1</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_2</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_3</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_CORBA_sequence_CORBA_string_4</NAME>
#define TC_IMPL_TC_CORBA_sequence_CORBA_string_4 'f'
</MACRO>
<MACRO>
<NAME>TC_CORBA_sequence_CORBA_string</NAME>
#define TC_CORBA_sequence_CORBA_string ((CORBA_TypeCode)&TC_CORBA_sequence_CORBA_string_struct)
</MACRO>
<FUNCTION>
<NAME>CORBA_sequence_CORBA_string__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<TYPEDEF>
<NAME>ConfigDatabase2_SchemaNameList</NAME>
   typedef CORBA_sequence_CORBA_string ConfigDatabase2_SchemaNameList;
</TYPEDEF>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_SchemaNameList_0</NAME>
#define TC_IMPL_TC_ConfigDatabase2_SchemaNameList_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_SchemaNameList_1</NAME>
#define TC_IMPL_TC_ConfigDatabase2_SchemaNameList_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_SchemaNameList_2</NAME>
#define TC_IMPL_TC_ConfigDatabase2_SchemaNameList_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_SchemaNameList_3</NAME>
#define TC_IMPL_TC_ConfigDatabase2_SchemaNameList_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigDatabase2_SchemaNameList_4</NAME>
#define TC_IMPL_TC_ConfigDatabase2_SchemaNameList_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigDatabase2_SchemaNameList</NAME>
#define TC_ConfigDatabase2_SchemaNameList ((CORBA_TypeCode)&TC_ConfigDatabase2_SchemaNameList_struct)
</MACRO>
<FUNCTION>
<NAME>ConfigDatabase2_SchemaNameList__free</NAME>
<RETURNS>gpointer  </RETURNS>
gpointer mem, gpointer dat, CORBA_boolean free_strings
</FUNCTION>
<MACRO>
<NAME>ORBIT_DECL_ConfigServer</NAME>
#define ORBIT_DECL_ConfigServer 1
</MACRO>
<MACRO>
<NAME>ConfigServer__free</NAME>
#define ConfigServer__free CORBA_Object__free
</MACRO>
<TYPEDEF>
<NAME>ConfigServer</NAME>
   typedef CORBA_Object ConfigServer;
</TYPEDEF>
<VARIABLE>
<NAME>ConfigServer__classid</NAME>
   extern CORBA_unsigned_long ConfigServer__classid;
</VARIABLE>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_0</NAME>
#define TC_IMPL_TC_ConfigServer_0 'G'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_1</NAME>
#define TC_IMPL_TC_ConfigServer_1 'C'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_2</NAME>
#define TC_IMPL_TC_ConfigServer_2 'o'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_3</NAME>
#define TC_IMPL_TC_ConfigServer_3 'n'
</MACRO>
<MACRO>
<NAME>TC_IMPL_TC_ConfigServer_4</NAME>
#define TC_IMPL_TC_ConfigServer_4 'f'
</MACRO>
<MACRO>
<NAME>TC_ConfigServer</NAME>
#define TC_ConfigServer ((CORBA_TypeCode)&TC_ConfigServer_struct)
</MACRO>
<FUNCTION>
<NAME>POA_ConfigListener__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigListener__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigDatabase__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigDatabase__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigDatabase2__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigDatabase2__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigServer__init</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>POA_ConfigServer__fini</NAME>
<RETURNS>void  </RETURNS>
PortableServer_Servant servant,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_notify</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj,const ConfigDatabase database,const CORBA_unsigned_long cnxn,const CORBA_char * key,const ConfigValue * value,const CORBA_boolean is_default,const CORBA_boolean is_writable,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_ping</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_update_listener</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj,const ConfigDatabase database,const CORBA_char * db_address,const CORBA_unsigned_long old_cnxn,const CORBA_char * where,const CORBA_unsigned_long new_cnxn,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_invalidate_cached_values</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj,const ConfigDatabase database,const ConfigListener_KeyList *keys, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigListener_drop_all_caches</NAME>
<RETURNS>void  </RETURNS>
ConfigListener _obj,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_add_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
ConfigDatabase _obj,const CORBA_char * where,const ConfigListener who,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_remove_listener</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,const CORBA_unsigned_long cnxn,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_lookup</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigDatabase _obj,const CORBA_char * key,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_lookup_with_locale</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigDatabase _obj,const CORBA_char * key,const CORBA_char * locale,const CORBA_booleanuse_schema_default,CORBA_boolean *value_is_default,CORBA_boolean *value_is_writable,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_lookup_default_value</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigDatabase _obj,const CORBA_char * key,const CORBA_char * locale,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_batch_lookup</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,const ConfigDatabase_KeyList * keys,const CORBA_char * locale,ConfigDatabase_ValueList ** values,ConfigDatabase_IsDefaultList **is_defaults,ConfigDatabase_IsWritableList **is_writables, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_set</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj, const CORBA_char * key,const ConfigValue * value, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_unset</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj, const CORBA_char * key,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_unset_with_locale</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,const CORBA_char * key,const CORBA_char * locale,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_batch_change</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,const CORBA_char * locale,const ConfigDatabase_KeyList * keys,const ConfigDatabase_ValueList * values,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_dir_exists</NAME>
<RETURNS>CORBA_boolean  </RETURNS>
ConfigDatabase _obj,const CORBA_char * dir,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_remove_dir</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj, const CORBA_char * dir,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_all_entries</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,const CORBA_char * dir,const CORBA_char * locale,ConfigDatabase_KeyList ** keys,ConfigDatabase_ValueList ** values,ConfigDatabase_IsDefaultList **is_defaults,ConfigDatabase_IsWritableList **is_writables, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_all_dirs</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj, const CORBA_char * dir,ConfigDatabase_KeyList ** subdirs,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_set_schema</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj, const CORBA_char * key,const CORBA_char * schema_key,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_sync</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_clear_cache</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase _obj,CORBA_Environment * ev
</FUNCTION>
<MACRO>
<NAME>ConfigDatabase2_add_listener</NAME>
#define ConfigDatabase2_add_listener ConfigDatabase_add_listener
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_remove_listener</NAME>
#define ConfigDatabase2_remove_listener ConfigDatabase_remove_listener
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_lookup</NAME>
#define ConfigDatabase2_lookup ConfigDatabase_lookup
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_lookup_with_locale</NAME>
#define ConfigDatabase2_lookup_with_locale ConfigDatabase_lookup_with_locale
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_lookup_default_value</NAME>
#define ConfigDatabase2_lookup_default_value ConfigDatabase_lookup_default_value
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_batch_lookup</NAME>
#define ConfigDatabase2_batch_lookup ConfigDatabase_batch_lookup
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_set</NAME>
#define ConfigDatabase2_set ConfigDatabase_set
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_unset</NAME>
#define ConfigDatabase2_unset ConfigDatabase_unset
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_unset_with_locale</NAME>
#define ConfigDatabase2_unset_with_locale ConfigDatabase_unset_with_locale
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_batch_change</NAME>
#define ConfigDatabase2_batch_change ConfigDatabase_batch_change
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_dir_exists</NAME>
#define ConfigDatabase2_dir_exists ConfigDatabase_dir_exists
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_remove_dir</NAME>
#define ConfigDatabase2_remove_dir ConfigDatabase_remove_dir
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_all_entries</NAME>
#define ConfigDatabase2_all_entries ConfigDatabase_all_entries
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_all_dirs</NAME>
#define ConfigDatabase2_all_dirs ConfigDatabase_all_dirs
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_set_schema</NAME>
#define ConfigDatabase2_set_schema ConfigDatabase_set_schema
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_sync</NAME>
#define ConfigDatabase2_sync ConfigDatabase_sync
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_clear_cache</NAME>
#define ConfigDatabase2_clear_cache ConfigDatabase_clear_cache
</MACRO>
<MACRO>
<NAME>ConfigDatabase2_synchronous_sync</NAME>
#define ConfigDatabase2_synchronous_sync ConfigDatabase_synchronous_sync
</MACRO>
<FUNCTION>
<NAME>ConfigDatabase2_lookup_with_schema_name</NAME>
<RETURNS>ConfigValue  *</RETURNS>
ConfigDatabase2 _obj,const CORBA_char *key,const CORBA_char *locale,const CORBA_booleanuse_schema_default,CORBA_char **schema_name,CORBA_boolean *value_is_default,CORBA_boolean *value_is_writable,CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigDatabase2_all_entries_with_schema_name</NAME>
<RETURNS>void  </RETURNS>
ConfigDatabase2 _obj,const CORBA_char * dir,const CORBA_char *locale,ConfigDatabase_KeyList **keys,ConfigDatabase_ValueList** values,ConfigDatabase2_SchemaNameList** schema_names,ConfigDatabase_IsDefaultList** is_defaults,ConfigDatabase_IsWritableList** is_writables,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_get_default_database</NAME>
<RETURNS>ConfigDatabase  </RETURNS>
ConfigServer _obj,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_get_database</NAME>
<RETURNS>ConfigDatabase  </RETURNS>
ConfigServer _obj,const CORBA_char * address,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_add_client</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj,const ConfigListener client,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_remove_client</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj,const ConfigListener client,CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_ping</NAME>
<RETURNS>CORBA_long  </RETURNS>
ConfigServer _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>ConfigServer_shutdown</NAME>
<RETURNS>void  </RETURNS>
ConfigServer _obj, CORBA_Environment * ev
</FUNCTION>
<FUNCTION>
<NAME>gce_app_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar* geometry
</FUNCTION>
<FUNCTION>
<NAME>gce_app_close</NAME>
<RETURNS>void</RETURNS>
GtkWidget* app
</FUNCTION>
<FUNCTION>
<NAME>gce_install_menus_and_toolbar</NAME>
<RETURNS>void  </RETURNS>
GtkWidget* app
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, int val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, bool val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, double val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const string& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<string>& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<int>& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<bool>& val
</FUNCTION>
<FUNCTION>
<NAME>set</NAME>
<RETURNS>void  </RETURNS>
const string& key, const vector<double>& val
</FUNCTION>
<FUNCTION>
<NAME>unset</NAME>
<RETURNS>void  </RETURNS>
const string& key
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, int* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, bool* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, double* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, string* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<string>* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<int>* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<bool>* val
</FUNCTION>
<FUNCTION>
<NAME>get</NAME>
<RETURNS>bool  </RETURNS>
const string& key, vector<double>* val
</FUNCTION>
<ENUM>
<NAME>GConfClientPreloadType</NAME>
typedef enum {
  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
} GConfClientPreloadType;
</ENUM>
<ENUM>
<NAME>GConfClientErrorHandlingMode</NAME>
typedef enum {
  GCONF_CLIENT_HANDLE_NONE,
  GCONF_CLIENT_HANDLE_UNRETURNED,
  GCONF_CLIENT_HANDLE_ALL
} GConfClientErrorHandlingMode;
</ENUM>
<STRUCT>
<NAME>GConfClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfClientClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfClientNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client,
                                      guint cnxn_id,
                                      GConfEntry *entry,
                                      gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfClientErrorHandlerFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client,
                                             GError* error
</USER_FUNCTION>
<MACRO>
<NAME>GCONF_TYPE_CLIENT</NAME>
#define GCONF_TYPE_CLIENT                  (gconf_client_get_type ())
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT</NAME>
#define GCONF_CLIENT(obj)                  (GTK_CHECK_CAST ((obj), GCONF_TYPE_CLIENT, GConfClient))
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT_CLASS</NAME>
#define GCONF_CLIENT_CLASS(klass)          (CONF_CHECK_CLASS_CAST ((klass), GCONF_TYPE_CLIENT, GConfClientClass))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT</NAME>
#define GCONF_IS_CLIENT(obj)               (GTK_CHECK_TYPE ((obj), GCONF_TYPE_CLIENT))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT_CLASS</NAME>
#define GCONF_IS_CLIENT_CLASS(klass)       (CONF_CHECK_CLASS_TYPE ((klass), GCONF_TYPE_CLIENT))
</MACRO>
<STRUCT>
<NAME>GConfClient</NAME>
struct GConfClient
{
  GtkObject object;

  /*< private >*/

  GConfEngine* engine;
  GConfClientErrorHandlingMode error_mode;
  GHashTable* dir_hash;
  GHashTable* cache_hash;
  GConfListeners* listeners;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_default</NAME>
<RETURNS>GConfClient *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_for_engine</NAME>
<RETURNS>GConfClient *</RETURNS>
GConfEngine* engine
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_add_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir,GConfClientPreloadType preload,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfClient* client,const gchar* namespace_section,GConfClientNotifyFunc func,gpointer user_data,GFreeFunc destroy_notify,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,guint cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_error_handling</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GConfClientErrorHandlingMode mode
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_global_default_error_handler</NAME>
<RETURNS>void  </RETURNS>
GConfClientErrorHandlerFunc func
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_preload</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dirname,GConfClientPreloadType type,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* val,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_entry</NAME>
<RETURNS>GConfEntry *</RETURNS>
GConfClient* client,const gchar* key,const gchar* locale,gboolean use_schema_default,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_key_is_writable</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* key,GError**     err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gpointer car_retloc, gpointer cdr_retloc,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gdouble val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gint val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,const gchar* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gboolean val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfSchema* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type,GSList* list,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unreturned_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_value_changed</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GError** err,const gchar* first_key,...
</FUNCTION>
<MACRO>
<NAME>GCONF_PROC</NAME>
#define GCONF_PROC(fname,primname, req, opt, var, ARGLIST) \
        SCM_PROC(s_ ## fname, primname, req, opt, var, fname); \
static SCM fname ARGLIST
</MACRO>
<MACRO>
<NAME>GCONF_PROC</NAME>
#define GCONF_PROC(fname,primname, req, opt, var, ARGLIST) \
        SCM_PROC(s_ ## fname, primname, req, opt, var, fname);
</MACRO>
<FUNCTION>
<NAME>gconf_init_scm</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>scm_gconfp</NAME>
<RETURNS>gboolean  </RETURNS>
SCM obj
</FUNCTION>
<FUNCTION>
<NAME>scm2gconf</NAME>
<RETURNS>GConfEngine *</RETURNS>
SCM obj
</FUNCTION>
<FUNCTION>
<NAME>gconf2scm</NAME>
<RETURNS>SCM  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_directory</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_key</NAME>
<RETURNS>const gchar *</RETURNS>
const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_test</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename, int test
</FUNCTION>
<FUNCTION>
<NAME>gconf_file_exists</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* filename
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_from_corba_value</NAME>
<RETURNS>GConfValue *</RETURNS>
const ConfigValue *value
</FUNCTION>
<FUNCTION>
<NAME>corba_value_from_gconf_value</NAME>
<RETURNS>ConfigValue *</RETURNS>
GConfValue        *value
</FUNCTION>
<FUNCTION>
<NAME>fill_corba_value_from_gconf_value</NAME>
<RETURNS>void  </RETURNS>
GConfValue        *value,ConfigValue       *dest
</FUNCTION>
<FUNCTION>
<NAME>invalid_corba_value</NAME>
<RETURNS>ConfigValue *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_object_to_string</NAME>
<RETURNS>gchar *</RETURNS>
CORBA_Object obj,GError **err
</FUNCTION>
<FUNCTION>
<NAME>fill_corba_schema_from_gconf_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSchema        *sc,ConfigSchema       *dest
</FUNCTION>
<FUNCTION>
<NAME>corba_schema_from_gconf_schema</NAME>
<RETURNS>ConfigSchema *</RETURNS>
GConfSchema        *sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_from_corba_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
const ConfigSchema *cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_type_from_string</NAME>
<RETURNS>GConfValueType  </RETURNS>
const gchar    *str
</FUNCTION>
<FUNCTION>
<NAME>gconf_load_source_path</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* filename, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_shutdown_daemon</NAME>
<RETURNS>void  </RETURNS>
GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_ping_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_spawn_daemon</NAME>
<RETURNS>gboolean  </RETURNS>
GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_gulong</NAME>
<RETURNS>gulong  </RETURNS>
const gchar *str
</FUNCTION>
<FUNCTION>
<NAME>gconf_string_to_double</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *str,gdouble     *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_double_to_string</NAME>
<RETURNS>gchar *</RETURNS>
gdouble      val
</FUNCTION>
<FUNCTION>
<NAME>gconf_current_locale</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GConfLogPriority</NAME>
typedef enum {
  GCL_EMERG,
  GCL_ALERT,
  GCL_CRIT,
  GCL_ERR,
  GCL_WARNING,
  GCL_NOTICE,
  GCL_INFO,
  GCL_DEBUG
} GConfLogPriority;
</ENUM>
<FUNCTION>
<NAME>gconf_log</NAME>
<RETURNS>void  </RETURNS>
GConfLogPriority pri, const gchar* format, ...
</FUNCTION>
<VARIABLE>
<NAME>gconf_log_debug_messages</NAME>
extern gboolean gconf_log_debug_messages;
</VARIABLE>
<FUNCTION>
<NAME>gconf_key_check</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type,const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_list_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType list_type,const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_new_pair_from_string</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType car_type,GConfValueType cdr_type,const gchar* str,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *str
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *str,const gchar **end,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_unquote_string_inplace</NAME>
<RETURNS>void  </RETURNS>
gchar        *str,gchar       **end,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_decode</NAME>
<RETURNS>GConfValue *</RETURNS>
const gchar *encoded
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_encode</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_quote_percents</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_from_primitive_list</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType  list_type,GSList         *list,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_from_primitive_pair</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType  car_type,GConfValueType  cdr_type,gconstpointer   address_of_car,gconstpointer   address_of_cdr,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_list_to_primitive_list_destructive</NAME>
<RETURNS>GSList *</RETURNS>
GConfValue      *val,GConfValueType   list_type,GError         **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_pair_to_primitive_pair_destructive</NAME>
<RETURNS>gboolean  </RETURNS>
GConfValue      *val,GConfValueType   car_type,GConfValueType   cdr_type,gpointer         car_retloc,gpointer         cdr_retloc,GError         **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_mode</NAME>
<RETURNS>void  </RETURNS>
gboolean     setting
</FUNCTION>
<FUNCTION>
<NAME>gconf_in_daemon_mode</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_daemon_ior</NAME>
<RETURNS>void  </RETURNS>
const gchar *ior
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_daemon_ior</NAME>
<RETURNS>const gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_handle_oaf_exception</NAME>
<RETURNS>gboolean  </RETURNS>
CORBA_Environment* ev, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_nanosleep</NAME>
<RETURNS>void  </RETURNS>
gulong useconds
</FUNCTION>
<STRUCT>
<NAME>GConfLock</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_get_lock</NAME>
<RETURNS>GConfLock *</RETURNS>
const gchar  *lock_directory,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_release_lock</NAME>
<RETURNS>gboolean  </RETURNS>
GConfLock    *lock,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_lock_or_current_holder</NAME>
<RETURNS>GConfLock *</RETURNS>
const gchar  *lock_directory,ConfigServer *current_server,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_current_lock_holder</NAME>
<RETURNS>ConfigServer  </RETURNS>
const gchar *lock_directory
</FUNCTION>
<FUNCTION>
<NAME>gconf_error_new</NAME>
<RETURNS>GError *</RETURNS>
GConfError en,const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>gconf_set_error</NAME>
<RETURNS>void  </RETURNS>
GError** err,GConfError en,const gchar* format, ...
</FUNCTION>
<FUNCTION>
<NAME>gconf_compose_errors</NAME>
<RETURNS>GError *</RETURNS>
GError* err1, GError* err2
</FUNCTION>
<FUNCTION>
<NAME>gconf_orb_get</NAME>
<RETURNS>CORBA_ORB  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_activate_server</NAME>
<RETURNS>ConfigServer  </RETURNS>
gboolean  start_if_not_found,GError  **error
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_lock_dir</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_daemon_dir</NAME>
<RETURNS>char *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_validate</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSchema *sc,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_validate</NAME>
<RETURNS>gboolean  </RETURNS>
GConfValue *value,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>g_utf8_validate</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *str,gssize        max_len,const gchar **end
</FUNCTION>
<MACRO>
<NAME>_</NAME>
#    define _(String) dgettext (GETTEXT_PACKAGE, String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#        define N_(String) gettext_noop (String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#        define N_(String) (String)
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
#    define textdomain(String) (String)
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
#    define bindtextdomain(Domain,Directory) (Domain)
</MACRO>
<MACRO>
<NAME>_</NAME>
#    define _(String) (String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#    define N_(String) (String)
</MACRO>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfBackendVTable</NAME>
struct GConfBackendVTable {
  void                (* shutdown)        (GError** err);

  GConfSource*        (* resolve_address) (const gchar* address,
                                           GError** err);

  /* Thread locks. If the backend is thread-safe, then these
   * can be NULL. If per-source locks are needed, then these
   * calls should lock a mutex stored in the GConfSource.
   * If a per-backend lock is needed, then the calls can ignore
   * their source argument and lock the whole backend.
   */
  void                (* lock)            (GConfSource* source,
                                           GError** err);

  void                (* unlock)          (GConfSource* source,
                                           GError** err);

  /* Report whether a given key (and its subkeys) can be read/written.
   * Sources may not permit reading/writing from/to /foo but forbid
   * writing to /foo/bar; if a key can be read or written then its
   * subkeys may also be read/written.
   *
   * This field allows backends to be configured so that they only
   * store certain kinds of data in certain sections of the GConf
   * namespace.
   *
   * If these functions return an error, they MUST return FALSE as
   * well.
   */

  gboolean           (* readable)         (GConfSource* source,
                                           const gchar* key,
                                           GError** err);

  gboolean           (* writable)        (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  /* schema_name filled if NULL or GCONF_VALUE_IGNORE_SUBSEQUENT returned.
     if schema_name is NULL, it isn't filled */
  GConfValue*         (* query_value)     (GConfSource* source, 
                                           const gchar* key,
                                           const gchar** locales,
                                           gchar** schema_name,
                                           GError** err);
  
  GConfMetaInfo*      (* query_metainfo)  (GConfSource* source,
                                           const gchar* key,
                                           GError** err);
  
  void                (* set_value)       (GConfSource* source, 
                                           const gchar* key, 
                                           GConfValue* value,
                                           GError** err);

  /* Returns list of GConfEntry with key set to a relative
   * pathname. In the public client-side API the key
   * is always absolute though.
   */
  GSList*             (* all_entries)     (GConfSource* source,
                                           const gchar* dir,
                                           const gchar** locales,
                                           GError** err);

  /* Returns list of allocated strings, relative names */
  GSList*             (* all_subdirs)     (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);

  void                (* unset_value)     (GConfSource* source,
                                           const gchar* key,
                                           const gchar* locale,
                                           GError** err);

  gboolean            (* dir_exists)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
        
  void                (* remove_dir)      (GConfSource* source,
                                           const gchar* dir,
                                           GError** err);
  
  void                (* set_schema)      (GConfSource* source,
                                           const gchar* key,
                                           const gchar* schema_key,
                                           GError** err);

  gboolean            (* sync_all)        (GConfSource* source,
                                           GError** err);

  void                (* destroy_source)  (GConfSource* source);

  /* This is basically used by the test suite */
  void                (* clear_cache)     (GConfSource* source);
};
</STRUCT>
<STRUCT>
<NAME>GConfBackend</NAME>
struct GConfBackend {
  const gchar* name;
  guint refcount;
  GConfBackendVTable* vtable;
  GModule* module;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_address_backend</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_resource</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_address_flags</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_file</NAME>
<RETURNS>gchar *</RETURNS>
const gchar* address
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_backend</NAME>
<RETURNS>GConfBackend *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_ref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_unref</NAME>
<RETURNS>void  </RETURNS>
GConfBackend* backend
</FUNCTION>
<FUNCTION>
<NAME>gconf_backend_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
GConfBackend* backend,const gchar* address,GError** err
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleCache</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_cache_new</NAME>
<RETURNS>GConfLocaleCache *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_free</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_expire</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleCache* cache,guint max_age_exclusive_in_seconds
</FUNCTION>
<STRUCT>
<NAME>GConfLocaleList</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfLocaleList</NAME>
struct GConfLocaleList {
  const gchar** list;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_locale_list_ref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_list_unref</NAME>
<RETURNS>void  </RETURNS>
GConfLocaleList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_locale_cache_get_list</NAME>
<RETURNS>GConfLocaleList *</RETURNS>
GConfLocaleCache* cache,const gchar* locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_split_locale</NAME>
<RETURNS>gchar **</RETURNS>
const gchar* locale
</FUNCTION>
<STRUCT>
<NAME>GConfDatabase</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfDatabase</NAME>
struct GConfDatabase
{
  /* "inherit" from the servant,
     must be first in struct */
  POA_ConfigDatabase2 servant;

  ConfigDatabase objref;
  
  GConfListeners* listeners;
  GConfSources* sources;

  GTime last_access;
  guint sync_idle;
  guint sync_timeout;

  gchar *persistent_name;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_database_new</NAME>
<RETURNS>GConfDatabase *</RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_free</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_drop_dead_listeners</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_add_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
GConfDatabase       *db,ConfigListener       who,const gchar         *where
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_remove_listener</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase       *db,CORBA_unsigned_long  cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_readd_listener</NAME>
<RETURNS>CORBA_unsigned_long  </RETURNS>
GConfDatabase       *db,ConfigListener       who,const gchar         *where
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_notify_listeners</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase       *db,const gchar         *key,const ConfigValue   *value,gboolean             is_default,gboolean             is_writable
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_query_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfDatabase  *db,const gchar    *key,const gchar   **locales,gboolean        use_schema_default,gchar         **schema_name,gboolean       *value_is_default,gboolean       *value_is_writable,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_query_default_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfDatabase  *db,const gchar    *key,const gchar   **locales,gboolean       *is_writable,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_set</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase      *db,const gchar        *key,GConfValue         *value,const ConfigValue  *cvalue,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_unset</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase      *db,const gchar        *key,const gchar        *locale,GError        **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfDatabase  *db,const gchar    *dir,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,const gchar    *dir,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfDatabase  *db,const gchar    *dir,const gchar   **locales,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfDatabase  *db,const gchar    *dir,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,const gchar    *key,const gchar    *schema_key,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_sync</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_synchronous_sync</NAME>
<RETURNS>gboolean  </RETURNS>
GConfDatabase  *db,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase  *db,GError    **err
</FUNCTION>
<FUNCTION>
<NAME>gconfd_locale_cache_expire</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconfd_locale_cache_drop</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_get_persistent_name</NAME>
<RETURNS>const gchar *</RETURNS>
GConfDatabase *db
</FUNCTION>
<FUNCTION>
<NAME>gconf_database_log_listeners_to_string</NAME>
<RETURNS>void  </RETURNS>
GConfDatabase *db,gboolean is_default,GString *str
</FUNCTION>
<STRUCT>
<NAME>GConfBackend</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSource</NAME>
struct GConfSource {
  guint flags;
  gchar* address;
  GConfBackend* backend;
};
</STRUCT>
<ENUM>
<NAME>GConfSourceFlags</NAME>
typedef enum {
  /* These are an optimization to avoid calls to
   * the writable/readable methods in the backend
   * vtable
   */
  GCONF_SOURCE_ALL_WRITEABLE = 1 << 0,
  GCONF_SOURCE_ALL_READABLE = 1 << 1,
  GCONF_SOURCE_NEVER_WRITEABLE = 1 << 2, 
  GCONF_SOURCE_ALL_FLAGS = ((1 << 0) | (1 << 1))
} GConfSourceFlags;
</ENUM>
<FUNCTION>
<NAME>gconf_resolve_address</NAME>
<RETURNS>GConfSource *</RETURNS>
const gchar* address,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_source_free</NAME>
<RETURNS>void  </RETURNS>
GConfSource* source
</FUNCTION>
<STRUCT>
<NAME>GConfSources</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfSources</NAME>
struct GConfSources {
  GList* sources;
  
};
</STRUCT>
<FUNCTION>
<NAME>gconf_sources_new_from_addresses</NAME>
<RETURNS>GConfSources *</RETURNS>
const gchar **addresses,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_new_from_source</NAME>
<RETURNS>GConfSources *</RETURNS>
GConfSource   *source
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_free</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources  *sources,const gchar   *key,const gchar  **locales,gboolean       use_schema_default,gboolean      *value_is_default,gboolean      *value_is_writable,gchar        **schema_name,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,GConfValue    *value,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_unset_value</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *locale,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,const gchar  **locales,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *dir,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfSources  *sources,const gchar   *key,const gchar   *schema_key,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_sync_all</NAME>
<RETURNS>gboolean  </RETURNS>
GConfSources  *sources,GError   **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
GConfSources* sources,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_sources_query_default_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfSources* sources,const gchar* key,const gchar** locales,gboolean* is_writable,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_get_poa</NAME>
<RETURNS>PortableServer_POA  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>gconf_set_exception</NAME>
<RETURNS>gboolean  </RETURNS>
GError** err, CORBA_Environment* ev
</FUNCTION>
<FUNCTION>
<NAME>gconfd_logfile_change_listener</NAME>
<RETURNS>gboolean  </RETURNS>
GConfDatabase *db,gboolean add,guint connection_id,ConfigListener listener,const gchar *where,GError **err
</FUNCTION>
<FUNCTION>
<NAME>gconfd_check_in_shutdown</NAME>
<RETURNS>gboolean  </RETURNS>
CORBA_Environment *ev
</FUNCTION>
<FUNCTION>
<NAME>gconfd_need_log_cleanup</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_is_initialized</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GConfNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfEngine* conf,
                                 guint cnxn_id,
                                 GConfEntry *entry,
                                 gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_engine_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfEngine      *conf,const gchar      *namespace_section,GConfNotifyFunc   func,gpointer          user_data,GError      **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfEngine      *conf,guint             cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_entry</NAME>
<RETURNS>GConfEntry *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,gboolean      use_schema_default,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_with_locale</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_associate_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine  *conf,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine  *conf,const gchar  *dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf,const gchar* dir,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_key_is_writable</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine *conf,const gchar *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_valid_key</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *key,gchar       **why_invalid
</FUNCTION>
<FUNCTION>
<NAME>gconf_key_is_below</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar  *above,const gchar  *below
</FUNCTION>
<FUNCTION>
<NAME>gconf_concat_dir_and_key</NAME>
<RETURNS>gchar *</RETURNS>
const gchar  *dir,const gchar  *key
</FUNCTION>
<FUNCTION>
<NAME>gconf_unique_key</NAME>
<RETURNS>gchar *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfEngine     *conf,const gchar     *key,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gpointer         car_retloc,gpointer         cdr_retloc,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gdouble          val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gint             val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,const gchar     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,gboolean         val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfSchema     *val,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   list_type,GSList          *list,GError     **err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine     *conf,const gchar     *key,GConfValueType   car_type,GConfValueType   cdr_type,gconstpointer    address_of_car,gconstpointer    address_of_cdr,GError     **err
</FUNCTION>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEnumStringPair</NAME>
struct GConfEnumStringPair {
  gint enum_value;
  const gchar* str;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_string_to_enum</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEnumStringPair  lookup_table[],const gchar         *str,gint                *enum_value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_enum_to_string</NAME>
<RETURNS>const gchar *</RETURNS>
GConfEnumStringPair  lookup_table[],gint                 enum_value
</FUNCTION>
<FUNCTION>
<NAME>gconf_init</NAME>
<RETURNS>gboolean  </RETURNS>
int argc, char **argv, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_preinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<FUNCTION>
<NAME>gconf_postinit</NAME>
<RETURNS>void  </RETURNS>
gpointer app, gpointer mod_info
</FUNCTION>
<FUNCTION>
<NAME>gconf_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_synchronous_sync</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_full</NAME>
<RETURNS>GConfValue  *</RETURNS>
GConfEngine *conf,const gchar *key,const gchar *locale,gboolean use_schema_default,gboolean *is_default_p,gboolean *is_writable_p,GError **err
</FUNCTION>
<STRUCT>
<NAME>GConfChangeSet</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfChangeSetForeachFunc</NAME>
<RETURNS>void </RETURNS>
GConfChangeSet* cs,
                                            const gchar* key,
                                            GConfValue* value,
                                            gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_engine_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfEngine* conf,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfEngine* conf,GError** err,const gchar* first_key,...
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_new</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_ref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unref</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_clear</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_size</NAME>
<RETURNS>guint  </RETURNS>
GConfChangeSet* cs
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_remove</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_foreach</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs,GConfChangeSetForeachFunc func,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_check_value</NAME>
<RETURNS>gboolean  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue** value_retloc
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_unset</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gdouble val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gint val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,const gchar* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,gboolean val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfSchema* val
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType list_type,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_pair</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet* cs, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_set_user_data</NAME>
<RETURNS>void  </RETURNS>
GConfChangeSet *cs,gpointer        data,GDestroyNotify  dnotify
</FUNCTION>
<FUNCTION>
<NAME>gconf_change_set_get_user_data</NAME>
<RETURNS>gpointer  </RETURNS>
GConfChangeSet *cs
</FUNCTION>
<STRUCT>
<NAME>GError</NAME>
</STRUCT>
<STRUCT>
<NAME>GError</NAME>
struct GError
{
  GQuark       domain;
  gint         code;
  gchar       *message;
};
</STRUCT>
<FUNCTION>
<NAME>g_error_new</NAME>
<RETURNS>GError *</RETURNS>
GQuark         domain,gint           code,const gchar   *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_error_new_literal</NAME>
<RETURNS>GError *</RETURNS>
GQuark         domain,gint           code,const gchar   *message
</FUNCTION>
<FUNCTION>
<NAME>g_error_free</NAME>
<RETURNS>void  </RETURNS>
GError        *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_copy</NAME>
<RETURNS>GError *</RETURNS>
const GError  *error
</FUNCTION>
<FUNCTION>
<NAME>g_error_matches</NAME>
<RETURNS>gboolean  </RETURNS>
const GError  *error,GQuark         domain,gint           code
</FUNCTION>
<FUNCTION>
<NAME>g_set_error</NAME>
<RETURNS>void  </RETURNS>
GError       **err,GQuark         domain,gint           code,const gchar   *format,...
</FUNCTION>
<FUNCTION>
<NAME>g_clear_error</NAME>
<RETURNS>void  </RETURNS>
GError       **err
</FUNCTION>
<FUNCTION>
<NAME>g_propagate_error</NAME>
<RETURNS>void  </RETURNS>
GError       **dest,GError        *src
</FUNCTION>
<STRUCT>
<NAME>GConfListeners</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfListenersCallback</NAME>
<RETURNS>void </RETURNS>
GConfListeners* listeners,
                                       const gchar*    all_above_key,
                                       guint           cnxn_id,
                                       gpointer        listener_data,
                                       gpointer        user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfListenersForeach</NAME>
<RETURNS>void </RETURNS>
const gchar* location,
                                       guint        cnxn_id,
                                       gpointer     listener_data,
                                       gpointer     user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfListenersPredicate</NAME>
<RETURNS>gboolean </RETURNS>
const gchar* location,
                                             guint        cnxn_id,
                                             gpointer     listener_data,
                                             gpointer     user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_new</NAME>
<RETURNS>GConfListeners *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_free</NAME>
<RETURNS>void  </RETURNS>
GConfListeners* listeners
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_add</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners* listeners,const gchar* listen_point,gpointer listener_data,GFreeFunc destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_remove</NAME>
<RETURNS>void  </RETURNS>
GConfListeners          *listeners,guint                    cnxn_id
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_notify</NAME>
<RETURNS>void  </RETURNS>
GConfListeners          *listeners,const gchar             *all_above,GConfListenersCallback   callback,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_count</NAME>
<RETURNS>guint  </RETURNS>
GConfListeners          *listeners
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_foreach</NAME>
<RETURNS>void  </RETURNS>
GConfListeners          *listeners,GConfListenersForeach    callback,gpointer                 user_data
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_get_data</NAME>
<RETURNS>gboolean  </RETURNS>
GConfListeners          *listeners,guint                    cnxn_id,gpointer                *listener_data_p,const gchar            **location_p
</FUNCTION>
<FUNCTION>
<NAME>gconf_listeners_remove_if</NAME>
<RETURNS>void  </RETURNS>
GConfListeners         *listeners,GConfListenersPredicate predicate,gpointer                user_data
</FUNCTION>
<STRUCT>
<NAME>GConfSchema</NAME>
struct GConfSchema {
  GConfValueType type; /* Type of the described entry */
  GConfValueType list_type; /* List type of the described entry */
  GConfValueType car_type; /* Pair car type of the described entry */
  GConfValueType cdr_type; /* Pair cdr type of the described entry */
  gchar* locale;       /* Schema locale */
  gchar* owner;        /* Name of creating application */
  gchar* short_desc;   /* 40 char or less description, no newlines */
  gchar* long_desc;    /* could be a paragraph or so */
  GConfValue* default_value; /* Default value of the key */
};
</STRUCT>
<FUNCTION>
<NAME>gconf_schema_new</NAME>
<RETURNS>GConfSchema *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_free</NAME>
<RETURNS>void  </RETURNS>
GConfSchema *sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_copy</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfSchema *sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_list_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_car_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_cdr_type</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValueType  type
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_locale</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *locale
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_short_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_long_desc</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *desc
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_owner</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,const gchar    *owner
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValue     *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_schema_set_default_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfSchema    *sc,GConfValue     *val
</FUNCTION>
<MACRO>
<NAME>gconf_schema_get_type</NAME>
#define       gconf_schema_get_type(x)          (x->type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_list_type</NAME>
#define       gconf_schema_get_list_type(x)     (x->list_type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_car_type</NAME>
#define       gconf_schema_get_car_type(x)      (x->car_type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_cdr_type</NAME>
#define       gconf_schema_get_cdr_type(x)      (x->cdr_type)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_locale</NAME>
#define       gconf_schema_get_locale(x)        ((const gchar*)(x)->locale)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_short_desc</NAME>
#define       gconf_schema_get_short_desc(x)    ((const gchar*)(x)->short_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_long_desc</NAME>
#define       gconf_schema_get_long_desc(x)     ((const gchar*)(x)->long_desc)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_owner</NAME>
#define       gconf_schema_get_owner(x)         ((const gchar*)(x)->owner)
</MACRO>
<MACRO>
<NAME>gconf_schema_get_default_value</NAME>
#define       gconf_schema_get_default_value(x) ((x)->default_value)
</MACRO>
<ENUM>
<NAME>GConfValueType</NAME>
typedef enum {
  GCONF_VALUE_INVALID,
  GCONF_VALUE_STRING,
  GCONF_VALUE_INT,
  GCONF_VALUE_FLOAT,
  GCONF_VALUE_BOOL,
  GCONF_VALUE_SCHEMA,

  /* unfortunately these aren't really types; we want list_of_string,
     list_of_int, etc.  but it's just too complicated to implement.
     instead we'll complain in various places if you do something
     moronic like mix types in a list or treat pair<string,int> and
     pair<float,bool> as the same type. */
  GCONF_VALUE_LIST,
  GCONF_VALUE_PAIR
  
} GConfValueType;
</ENUM>
<MACRO>
<NAME>GCONF_VALUE_TYPE_VALID</NAME>
#define GCONF_VALUE_TYPE_VALID(x) (((x) > GCONF_VALUE_INVALID) && ((x) <= GCONF_VALUE_PAIR))
</MACRO>
<STRUCT>
<NAME>GConfSchema</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfValue</NAME>
struct GConfValue {
  GConfValueType type;
  union {
    gchar* string_data;
    gint int_data;
    gboolean bool_data;
    gdouble float_data;
    GConfSchema* schema_data;
    struct {
      GConfValueType type;
      GSList* list;
    } list_data;
    struct {
      GConfValue* car;
      GConfValue* cdr;
    } pair_data;
  } d;
};
</STRUCT>
<MACRO>
<NAME>gconf_value_get_string</NAME>
#define gconf_value_get_string(x)    ((const gchar*)((x)->d.string_data))
</MACRO>
<MACRO>
<NAME>gconf_value_get_int</NAME>
#define gconf_value_get_int(x)       ((x)->d.int_data)
</MACRO>
<MACRO>
<NAME>gconf_value_get_float</NAME>
#define gconf_value_get_float(x)     ((x)->d.float_data)
</MACRO>
<MACRO>
<NAME>gconf_value_get_list_type</NAME>
#define gconf_value_get_list_type(x) ((x)->d.list_data.type)
</MACRO>
<MACRO>
<NAME>gconf_value_get_list</NAME>
#define gconf_value_get_list(x)      ((x)->d.list_data.list)
</MACRO>
<MACRO>
<NAME>gconf_value_get_car</NAME>
#define gconf_value_get_car(x)       ((x)->d.pair_data.car)
</MACRO>
<MACRO>
<NAME>gconf_value_get_cdr</NAME>
#define gconf_value_get_cdr(x)       ((x)->d.pair_data.cdr)
</MACRO>
<MACRO>
<NAME>gconf_value_get_bool</NAME>
#define gconf_value_get_bool(x)      ((x)->d.bool_data)
</MACRO>
<MACRO>
<NAME>gconf_value_get_schema</NAME>
#define gconf_value_get_schema(x)    ((x)->d.schema_data)
</MACRO>
<FUNCTION>
<NAME>gconf_value_new</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_copy</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfValue* src
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_free</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_int</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gint the_int
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_string</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,const gchar* the_str
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_float</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gdouble the_float
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_bool</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,gboolean the_bool
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_schema_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfSchema* sc
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_car_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* car
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_cdr_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValue* cdr
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_type</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GConfValueType type
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_set_list</NAME>
<RETURNS>void  </RETURNS>
GConfValue* value,GSList* list
</FUNCTION>
<FUNCTION>
<NAME>gconf_value_to_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfValue* value
</FUNCTION>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfMetaInfo</NAME>
struct GConfMetaInfo {
  gchar* schema;
  gchar* mod_user; /* user owning the daemon that made the last modification */
  GTime  mod_time; /* time of the modification */
};
</STRUCT>
<MACRO>
<NAME>gconf_meta_info_get_schema</NAME>
#define gconf_meta_info_get_schema(x)    ((const gchar*)(x)->schema)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_get_mod_user</NAME>
#define gconf_meta_info_get_mod_user(x)  ((x)->mod_user)
</MACRO>
<MACRO>
<NAME>gconf_meta_info_mod_time</NAME>
#define gconf_meta_info_mod_time(x)  ((x)->mod_time)
</MACRO>
<FUNCTION>
<NAME>gconf_meta_info_new</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_free</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_schema</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* schema_name
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,const gchar* mod_user
</FUNCTION>
<FUNCTION>
<NAME>gconf_meta_info_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
GConfMetaInfo* gcmi,GTime mod_time
</FUNCTION>
<STRUCT>
<NAME>GConfEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfEntry</NAME>
struct GConfEntry {
  gchar* key;
  GConfValue* value;
  gchar* schema_name;
  guint is_default : 1;
  guint is_writable : 1;
};
</STRUCT>
<MACRO>
<NAME>gconf_entry_get_key</NAME>
#define     gconf_entry_get_key(x)         ((const gchar*)(x)->key)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_value</NAME>
#define     gconf_entry_get_value(x)       ((x)->value)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_schema_name</NAME>
#define     gconf_entry_get_schema_name(x) ((const gchar*)(x)->schema_name)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_is_default</NAME>
#define     gconf_entry_get_is_default(x)  ((x)->is_default)
</MACRO>
<MACRO>
<NAME>gconf_entry_get_is_writable</NAME>
#define     gconf_entry_get_is_writable(x) ((x)->is_writable)
</MACRO>
<FUNCTION>
<NAME>gconf_entry_new</NAME>
<RETURNS>GConfEntry *</RETURNS>
const gchar *key,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_new_nocopy</NAME>
<RETURNS>GConfEntry *</RETURNS>
gchar       *key,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_free</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_steal_value</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfEntry  *entry
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_value</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_value_nocopy</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,GConfValue  *val
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_is_default</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,gboolean     is_default
</FUNCTION>
<FUNCTION>
<NAME>gconf_entry_set_is_writable</NAME>
<RETURNS>void  </RETURNS>
GConfEntry  *entry,gboolean     is_writable
</FUNCTION>
<MACRO>
<NAME>GCONF_ERROR</NAME>
#define GCONF_ERROR gconf_error_quark ()
</MACRO>
<ENUM>
<NAME>GConfError</NAME>
typedef enum {
  GCONF_ERROR_SUCCESS = 0,
  GCONF_ERROR_FAILED = 1,        /* Something didn't work, don't know why, probably unrecoverable
                                    so there's no point having a more specific errno */

  GCONF_ERROR_NO_SERVER = 2,     /* Server can't be launched/contacted */
  GCONF_ERROR_NO_PERMISSION = 3, /* don't have permission for that */
  GCONF_ERROR_BAD_ADDRESS = 4,   /* Address couldn't be resolved */
  GCONF_ERROR_BAD_KEY = 5,       /* directory or key isn't valid (contains bad
                                    characters, or malformed slash arrangement) */
  GCONF_ERROR_PARSE_ERROR = 6,   /* Syntax error when parsing */
  GCONF_ERROR_CORRUPT = 7,       /* Fatal error parsing/loading information inside the backend */
  GCONF_ERROR_TYPE_MISMATCH = 8, /* Type requested doesn't match type found */
  GCONF_ERROR_IS_DIR = 9,        /* Requested key operation on a dir */
  GCONF_ERROR_IS_KEY = 10,       /* Requested dir operation on a key */
  GCONF_ERROR_OVERRIDDEN = 11,   /* Read-only source at front of path has set the value */
  GCONF_ERROR_OAF_ERROR = 12,    /* liboaf error */
  GCONF_ERROR_LOCAL_ENGINE = 13, /* Tried to use remote operations on a local engine */
  GCONF_ERROR_LOCK_FAILED = 14,  /* Failed to get a lockfile */
  GCONF_ERROR_NO_WRITABLE_DATABASE = 15, /* nowhere to write a value */
  GCONF_ERROR_IN_SHUTDOWN = 16   /* server is shutting down */
} GConfError;
</ENUM>
<FUNCTION>
<NAME>gconf_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GConfEngine</NAME>
</STRUCT>
<FUNCTION>
<NAME>gconf_engine_get_default</NAME>
<RETURNS>GConfEngine *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_for_address</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_unref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_ref</NAME>
<RETURNS>void  </RETURNS>
GConfEngine* conf
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_local</NAME>
<RETURNS>GConfEngine *</RETURNS>
const gchar* address, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_set_user_data</NAME>
<RETURNS>void  </RETURNS>
GConfEngine   *engine,gpointer       data,GDestroyNotify dnotify
</FUNCTION>
<FUNCTION>
<NAME>gconf_engine_get_user_data</NAME>
<RETURNS>gpointer  </RETURNS>
GConfEngine   *engine
</FUNCTION>
<STRUCT>
<NAME>Cache</NAME>
</STRUCT>
<FUNCTION>
<NAME>cache_new</NAME>
<RETURNS>Cache *</RETURNS>
const gchar  *root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>cache_destroy</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache
</FUNCTION>
<FUNCTION>
<NAME>cache_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Cache        *cache,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_clean</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,GTime         older_than
</FUNCTION>
<FUNCTION>
<NAME>cache_delete_dir</NAME>
<RETURNS>void  </RETURNS>
Cache        *cache,const gchar  *key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>cache_lookup</NAME>
<RETURNS>Dir *</RETURNS>
Cache        *cache,const gchar  *key,gboolean create_if_missing,GError  **err
</FUNCTION>
<STRUCT>
<NAME>Dir</NAME>
</STRUCT>
<FUNCTION>
<NAME>dir_new</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *keyname,const gchar  *xml_root_dir,guint dir_mode,guint file_mode
</FUNCTION>
<FUNCTION>
<NAME>dir_load</NAME>
<RETURNS>Dir *</RETURNS>
const gchar  *key,const gchar  *xml_root_dir,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_destroy</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_clear_cache</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_ensure_exists</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_sync</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_set_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,GConfValue   *value,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Dir          *d,const gchar  *relative_key,const gchar **locales,gchar       **schema_name,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Dir          *d,const gchar  *relative_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_unset_value</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *locale,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_all_subdirs</NAME>
<RETURNS>GSList *</RETURNS>
Dir          *d,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_set_schema</NAME>
<RETURNS>void  </RETURNS>
Dir          *d,const gchar  *relative_key,const gchar  *schema_key,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>dir_get_last_access</NAME>
<RETURNS>GTime  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_sync_pending</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_mark_deleted</NAME>
<RETURNS>void  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>dir_is_deleted</NAME>
<RETURNS>gboolean  </RETURNS>
Dir          *d
</FUNCTION>
<FUNCTION>
<NAME>mode_t_to_mode</NAME>
<RETURNS>guint  </RETURNS>
mode_t orig
</FUNCTION>
<STRUCT>
<NAME>Entry</NAME>
</STRUCT>
<FUNCTION>
<NAME>entry_new</NAME>
<RETURNS>Entry *</RETURNS>
const gchar  *relative_name
</FUNCTION>
<FUNCTION>
<NAME>entry_destroy</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,xmlNodePtr    node
</FUNCTION>
<FUNCTION>
<NAME>entry_get_node</NAME>
<RETURNS>xmlNodePtr  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_fill_from_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_sync_to_node</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_get_value</NAME>
<RETURNS>GConfValue *</RETURNS>
Entry        *entry,const gchar **locales,GError  **err
</FUNCTION>
<FUNCTION>
<NAME>entry_set_value</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GConfValue   *value
</FUNCTION>
<FUNCTION>
<NAME>entry_unset_value</NAME>
<RETURNS>gboolean  </RETURNS>
Entry        *entry,const gchar  *locale
</FUNCTION>
<FUNCTION>
<NAME>entry_get_metainfo</NAME>
<RETURNS>GConfMetaInfo *</RETURNS>
Entry        *entry
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_time</NAME>
<RETURNS>void  </RETURNS>
Entry        *entry,GTime         mod_time
</FUNCTION>
<FUNCTION>
<NAME>entry_set_mod_user</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *user
</FUNCTION>
<FUNCTION>
<NAME>entry_get_schema_name</NAME>
<RETURNS>const gchar *</RETURNS>
Entry        *e
</FUNCTION>
<FUNCTION>
<NAME>entry_set_schema_name</NAME>
<RETURNS>void  </RETURNS>
Entry        *e,const gchar  *name
</FUNCTION>
<FUNCTION>
<NAME>my_xmlSetProp</NAME>
<RETURNS>void  </RETURNS>
xmlNodePtr node,const gchar* name,const gchar* str
</FUNCTION>
<FUNCTION>
<NAME>my_xmlGetProp</NAME>
<RETURNS>char *</RETURNS>
xmlNodePtr node,const gchar* name
</FUNCTION>
<MACRO>
<NAME>DBD_DIR</NAME>
#define	DBD_DIR	"dir.db"
</MACRO>
<MACRO>
<NAME>DBD_HIERARCHY</NAME>
#define	DBD_HIERARCHY	"hierarchy.db"
</MACRO>
<MACRO>
<NAME>DBD_KEY</NAME>
#define	DBD_KEY	"key.db"
</MACRO>
<MACRO>
<NAME>DBD_VALUE</NAME>
#define	DBD_VALUE	"value.db"
</MACRO>
<MACRO>
<NAME>DBD_SCHEMA</NAME>
#define	DBD_SCHEMA	"schema.db"
</MACRO>
<MACRO>
<NAME>DBD_SCHKEY</NAME>
#define	DBD_SCHKEY	"schkey.db"
</MACRO>
<FUNCTION>
<NAME>bdb_create</NAME>
<RETURNS>int  </RETURNS>
BDB_Store * bdb, const char *dbname
</FUNCTION>
<FUNCTION>
<NAME>bdb_new</NAME>
<RETURNS>BDB_Store  *</RETURNS>
const char *dir, int flags
</FUNCTION>
<MACRO>
<NAME>CLEAR_STRUCT</NAME>
#define CLEAR_STRUCT(x) (memset(&x, 0, sizeof(x)))
</MACRO>
<FUNCTION>
<NAME>temp_string_key</NAME>
<RETURNS>DBT  *</RETURNS>
const char *key
</FUNCTION>
<FUNCTION>
<NAME>temp_int_key</NAME>
<RETURNS>DBT  *</RETURNS>
int akey
</FUNCTION>
<FUNCTION>
<NAME>get_dir_id</NAME>
<RETURNS>guint32  </RETURNS>
BDB_Store * bdb, const char *dir
</FUNCTION>
<FUNCTION>
<NAME>add_key</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *dir, const char *keypath
</FUNCTION>
<FUNCTION>
<NAME>bdb_set_sysname</NAME>
<RETURNS>void  </RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>get_or_create_dir</NAME>
<RETURNS>guint32  </RETURNS>
BDB_Store * bdb, const char *dir
</FUNCTION>
<FUNCTION>
<NAME>bdb_create</NAME>
<RETURNS>int  </RETURNS>
BDB_Store * bdb, const char *dir
</FUNCTION>
<FUNCTION>
<NAME>bdb_open</NAME>
<RETURNS>int  </RETURNS>
BDB_Store * bdb, const char *dir, int flags
</FUNCTION>
<FUNCTION>
<NAME>bdb_close</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb
</FUNCTION>
<FUNCTION>
<NAME>bdb_query_value</NAME>
<RETURNS>GConfValue  *</RETURNS>
BDB_Store * bdb, const char *key,char **schema_name, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_all_dirs</NAME>
<RETURNS>GSList  *</RETURNS>
BDB_Store * bdb, const char *dirname,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_all_entries</NAME>
<RETURNS>GSList  *</RETURNS>
BDB_Store * bdb, const char *dirpath,GSList * inlist, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_put_value</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *key, GConfValue * val,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_all_subdirs</NAME>
<RETURNS>GSList  *</RETURNS>
BDB_Store * bdb, const char *dirname,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_unset_value</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *keypath,const char *locale, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_remove_dir</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *dirname,GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_set_schema</NAME>
<RETURNS>void  </RETURNS>
BDB_Store * bdb, const char *key,const char *schema_key, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>bdb_is_localised</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar * key
</FUNCTION>
<MACRO>
<NAME>struct_dup</NAME>
#define struct_dup(x) g_memdup(&x, sizeof(x))
</MACRO>
<FUNCTION>
<NAME>bdb_serialize_value</NAME>
<RETURNS>char  *</RETURNS>
GConfValue * val, size_t * lenp
</FUNCTION>
<FUNCTION>
<NAME>bdb_restore_value</NAME>
<RETURNS>GConfValue  *</RETURNS>
const char *srz
</FUNCTION>
<ENUM>
<NAME>GConfClientPreloadType</NAME>
typedef enum {
  GCONF_CLIENT_PRELOAD_NONE,     /* don't preload anything */
  GCONF_CLIENT_PRELOAD_ONELEVEL, /* load entries directly under the directory. */
  GCONF_CLIENT_PRELOAD_RECURSIVE /* recurse the directory tree; possibly quite expensive! */
} GConfClientPreloadType;
</ENUM>
<ENUM>
<NAME>GConfClientErrorHandlingMode</NAME>
typedef enum {
  GCONF_CLIENT_HANDLE_NONE,
  GCONF_CLIENT_HANDLE_UNRETURNED,
  GCONF_CLIENT_HANDLE_ALL
} GConfClientErrorHandlingMode;
</ENUM>
<STRUCT>
<NAME>GConfClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GConfClientClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GConfClientNotifyFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client,
                                      guint cnxn_id,
                                      GConfEntry *entry,
                                      gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GConfClientErrorHandlerFunc</NAME>
<RETURNS>void </RETURNS>
GConfClient* client,
                                             GError* error
</USER_FUNCTION>
<MACRO>
<NAME>GCONF_TYPE_CLIENT</NAME>
#define GCONF_TYPE_CLIENT                  (gconf_client_get_type ())
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT</NAME>
#define GCONF_CLIENT(obj)                  (GTK_CHECK_CAST ((obj), GCONF_TYPE_CLIENT, GConfClient))
</MACRO>
<MACRO>
<NAME>GCONF_CLIENT_CLASS</NAME>
#define GCONF_CLIENT_CLASS(klass)          (CONF_CHECK_CLASS_CAST ((klass), GCONF_TYPE_CLIENT, GConfClientClass))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT</NAME>
#define GCONF_IS_CLIENT(obj)               (GTK_CHECK_TYPE ((obj), GCONF_TYPE_CLIENT))
</MACRO>
<MACRO>
<NAME>GCONF_IS_CLIENT_CLASS</NAME>
#define GCONF_IS_CLIENT_CLASS(klass)       (CONF_CHECK_CLASS_TYPE ((klass), GCONF_TYPE_CLIENT))
</MACRO>
<STRUCT>
<NAME>GConfClient</NAME>
struct GConfClient
{
  GtkObject object;

  /*< private >*/

  GConfEngine* engine;
  GConfClientErrorHandlingMode error_mode;
  GHashTable* dir_hash;
  GHashTable* cache_hash;
  GConfListeners* listeners;
};
</STRUCT>
<FUNCTION>
<NAME>gconf_client_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_default</NAME>
<RETURNS>GConfClient *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_for_engine</NAME>
<RETURNS>GConfClient *</RETURNS>
GConfEngine* engine
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_add_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir,GConfClientPreloadType preload,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_remove_dir</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dir,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_add</NAME>
<RETURNS>guint  </RETURNS>
GConfClient* client,const gchar* namespace_section,GConfClientNotifyFunc func,gpointer user_data,GFreeFunc destroy_notify,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_notify_remove</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,guint cnxn
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_error_handling</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GConfClientErrorHandlingMode mode
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_global_default_error_handler</NAME>
<RETURNS>void  </RETURNS>
GConfClientErrorHandlerFunc func
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_clear_cache</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_preload</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* dirname,GConfClientPreloadType type,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* val,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_without_default</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_entry</NAME>
<RETURNS>GConfEntry *</RETURNS>
GConfClient* client,const gchar* key,const gchar* locale,gboolean use_schema_default,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_default_from_schema</NAME>
<RETURNS>GConfValue *</RETURNS>
GConfClient* client,const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unset</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_entries</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_all_dirs</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_suggest_sync</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_dir_exists</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* dir, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_key_is_writable</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,const gchar* key,GError**     err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_float</NAME>
<RETURNS>gdouble  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_int</NAME>
<RETURNS>gint  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_string</NAME>
<RETURNS>gchar *</RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_schema</NAME>
<RETURNS>GConfSchema *</RETURNS>
GConfClient* client,const gchar* key, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_list</NAME>
<RETURNS>GSList *</RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_get_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gpointer car_retloc, gpointer cdr_retloc,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gdouble val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gint val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,const gchar* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_bool</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,gboolean val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_schema</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfSchema* val, GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_list</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType list_type,GSList* list,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_set_pair</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client, const gchar* key,GConfValueType car_type, GConfValueType cdr_type,gconstpointer address_of_car,gconstpointer address_of_cdr,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_unreturned_error</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client, GError* error
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_value_changed</NAME>
<RETURNS>void  </RETURNS>
GConfClient* client,const gchar* key,GConfValue* value
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_commit_change_set</NAME>
<RETURNS>gboolean  </RETURNS>
GConfClient* client,GConfChangeSet* cs,gboolean remove_committed,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_reverse_change_set</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GConfChangeSet* cs,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_change_set_from_currentv</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,const gchar** keys,GError** err
</FUNCTION>
<FUNCTION>
<NAME>gconf_client_change_set_from_current</NAME>
<RETURNS>GConfChangeSet *</RETURNS>
GConfClient* client,GError** err,const gchar* first_key,...
</FUNCTION>
