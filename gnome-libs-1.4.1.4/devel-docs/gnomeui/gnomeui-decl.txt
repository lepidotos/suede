<MACRO>
<NAME>GNOME_ABOUT</NAME>
#define GNOME_ABOUT(obj)        GTK_CHECK_CAST (obj, gnome_about_get_type (), GnomeAbout)
</MACRO>
<MACRO>
<NAME>GNOME_ABOUT_CLASS</NAME>
#define GNOME_ABOUT_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_about_get_type (), GnomeAboutClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_ABOUT</NAME>
#define GNOME_IS_ABOUT(obj)       GTK_CHECK_TYPE (obj, gnome_about_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeAbout</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAboutClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAbout</NAME>
struct GnomeAbout
{
  GnomeDialog dialog;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_about_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_about_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar	*title,const gchar	*version,const gchar	*copyright,const gchar	**authors,const gchar	*comments,const gchar	*logo
</FUNCTION>
<FUNCTION>
<NAME>gnome_about_construct</NAME>
<RETURNS>void</RETURNS>
GnomeAbout *about,const gchar	*title,const gchar	*version,const gchar   *copyright,const gchar   **authors,const gchar   *comments,const gchar   *logo
</FUNCTION>
<MACRO>
<NAME>GNOME_ANIMATOR</NAME>
#define GNOME_ANIMATOR(obj) \
  GTK_CHECK_CAST (obj, gnome_animator_get_type (), GnomeAnimator)
</MACRO>
<MACRO>
<NAME>GNOME_ANIMATOR_CLASS</NAME>
#define GNOME_ANIMATOR_CLASS(klass) \
  GTK_CHECK_CLASS_CAST (klass, gnome_animator_get_type (), GnomeAnimatorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_ANIMATOR</NAME>
#define GNOME_IS_ANIMATOR(obj) \
  GTK_CHECK_TYPE (obj, gnome_animator_get_type ())
</MACRO>
<ENUM>
<NAME>GnomeAnimatorStatus</NAME>
typedef enum
{
    GNOME_ANIMATOR_STATUS_STOPPED,
    GNOME_ANIMATOR_STATUS_RUNNING
} GnomeAnimatorStatus;
</ENUM>
<ENUM>
<NAME>GnomeAnimatorLoopType</NAME>
typedef enum
{
    /* No loop: after the last (first) frame is played, the animation
       is stopped.  */
    GNOME_ANIMATOR_LOOP_NONE,

    /* After the last (first) frame is played, restart from the first
       (last) frame.  */
    GNOME_ANIMATOR_LOOP_RESTART,

    /* After the last (first) frame is played, the playback direction
       is reversed.  */
    GNOME_ANIMATOR_LOOP_PING_PONG
} GnomeAnimatorLoopType;
</ENUM>
<STRUCT>
<NAME>GnomeAnimator</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAnimatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAnimatorFrame</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAnimatorPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAnimator</NAME>
struct GnomeAnimator
  {
    GtkWidget widget;

    guint num_frames;

    guint current_frame_number;

    GnomeAnimatorStatus status;

    GnomeAnimatorLoopType loop_type;

    gint playback_direction;

    gdouble playback_speed;

    GnomeAnimatorPrivate *privat;
  };
</STRUCT>
<FUNCTION>
<NAME>gnome_animator_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_new_with_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
guint width,guint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_set_loop_type</NAME>
<RETURNS>void  </RETURNS>
GnomeAnimator *animator,GnomeAnimatorLoopType loop_type
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_get_loop_type</NAME>
<RETURNS>GnomeAnimatorLoopType  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_set_playback_direction</NAME>
<RETURNS>void  </RETURNS>
GnomeAnimator *animator,gint playback_direction
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_get_playback_direction</NAME>
<RETURNS>gint  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frame_from_imlib_at_size</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,GdkImlibImage *image,gint x_offset,gint y_offset,guint32 interval,guint width,guint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frame_from_imlib</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,GdkImlibImage *image,gint x_offset,gint y_offset,guint32 interval
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frame_from_file_at_size</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,const gchar *name,gint x_offset,gint y_offset,guint32 interval,guint width,guint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frame_from_file</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,const gchar *name,gint x_offset,gint y_offset,guint32 interval
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frames_from_imlib_at_size</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,GdkImlibImage *image,gint x_offset,gint y_offset,guint32 interval,gint x_unit,guint width,guint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frames_from_imlib</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,GdkImlibImage *image,gint x_offset,gint y_offset,guint32 interval,gint x_unit
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frames_from_file_at_size</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,const gchar *name,gint x_offset,gint y_offset,guint32 interval,gint x_unit,guint width,guint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frames_from_file</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,const gchar *name,gint x_offset,gint y_offset,guint32 interval,gint x_unit
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_append_frame_from_gnome_pixmap</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,GnomePixmap *pixmap,gint x_offset,gint y_offset,guint32 interval
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_start</NAME>
<RETURNS>void  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_stop</NAME>
<RETURNS>void  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_advance</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeAnimator *animator,gint num
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_goto_frame</NAME>
<RETURNS>void  </RETURNS>
GnomeAnimator *animator,guint frame_number
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_get_current_frame_number</NAME>
<RETURNS>guint  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_get_status</NAME>
<RETURNS>GnomeAnimatorStatus  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_set_playback_speed</NAME>
<RETURNS>void  </RETURNS>
GnomeAnimator *animator,gdouble speed
</FUNCTION>
<FUNCTION>
<NAME>gnome_animator_get_playback_speed</NAME>
<RETURNS>gdouble  </RETURNS>
GnomeAnimator *animator
</FUNCTION>
<ENUM>
<NAME>GnomeUIInfoType</NAME>
typedef enum {
	GNOME_APP_UI_ENDOFINFO,		/* No more items, use it at the end of 
					   an array */
	GNOME_APP_UI_ITEM,		/* Normal item, or radio item if it is 
					   inside a radioitems group */
	GNOME_APP_UI_TOGGLEITEM,	/* Toggle (check box) item */
	GNOME_APP_UI_RADIOITEMS,	/* Radio item group */
	GNOME_APP_UI_SUBTREE,		/* Item that defines a 
					   subtree/submenu */
	GNOME_APP_UI_SEPARATOR,		/* Separator line (menus) or blank 
					   space (toolbars) */
	GNOME_APP_UI_HELP,		/* Create a list of help topics, 
					   used in the Help menu */
	GNOME_APP_UI_BUILDER_DATA,	/* Specifies the builder data for the 
					   following entries, see code for 
					   further info */
	GNOME_APP_UI_ITEM_CONFIGURABLE, /* A configurable menu item. */
	/* one should be careful when using 
	 * gnome_app_create_*_[custom|interp|with_data]() functions with 
	 * GnomeUIInfo arrays containing GNOME_APP_UI_BUILDER_DATA items since 
	 * their GnomeUIBuilderData structures completely override the ones 
	 * generated or supplied by the above functions. */
	GNOME_APP_UI_SUBTREE_STOCK	/* Item that defines a 
					   subtree/submenu, same as GNOME_APP_UI_SUBTREE,
					   but the texts should be looked up in the
					   gnome-libs catalog
					*/
} GnomeUIInfoType;
</ENUM>
<ENUM>
<NAME>GnomeUIInfoConfigurableTypes</NAME>
typedef enum {
        /* 0 */
        GNOME_APP_CONFIGURABLE_ITEM_NEW,
        GNOME_APP_CONFIGURABLE_ITEM_OPEN,
        GNOME_APP_CONFIGURABLE_ITEM_SAVE,
        GNOME_APP_CONFIGURABLE_ITEM_SAVE_AS,
        GNOME_APP_CONFIGURABLE_ITEM_REVERT,
        GNOME_APP_CONFIGURABLE_ITEM_PRINT,
        GNOME_APP_CONFIGURABLE_ITEM_PRINT_SETUP,
        GNOME_APP_CONFIGURABLE_ITEM_CLOSE,
        GNOME_APP_CONFIGURABLE_ITEM_EXIT,
        GNOME_APP_CONFIGURABLE_ITEM_CUT,
	/* 10 */
        GNOME_APP_CONFIGURABLE_ITEM_COPY,
        GNOME_APP_CONFIGURABLE_ITEM_PASTE,
        GNOME_APP_CONFIGURABLE_ITEM_CLEAR,
        GNOME_APP_CONFIGURABLE_ITEM_UNDO,
        GNOME_APP_CONFIGURABLE_ITEM_REDO,
        GNOME_APP_CONFIGURABLE_ITEM_FIND,
        GNOME_APP_CONFIGURABLE_ITEM_FIND_AGAIN,
        GNOME_APP_CONFIGURABLE_ITEM_REPLACE,
        GNOME_APP_CONFIGURABLE_ITEM_PROPERTIES,
        GNOME_APP_CONFIGURABLE_ITEM_PREFERENCES,
	/* 20 */
        GNOME_APP_CONFIGURABLE_ITEM_ABOUT,
	GNOME_APP_CONFIGURABLE_ITEM_SELECT_ALL,
	GNOME_APP_CONFIGURABLE_ITEM_NEW_WINDOW,
	GNOME_APP_CONFIGURABLE_ITEM_CLOSE_WINDOW,
	GNOME_APP_CONFIGURABLE_ITEM_NEW_GAME,
	GNOME_APP_CONFIGURABLE_ITEM_PAUSE_GAME,
	GNOME_APP_CONFIGURABLE_ITEM_RESTART_GAME,
	GNOME_APP_CONFIGURABLE_ITEM_UNDO_MOVE,
	GNOME_APP_CONFIGURABLE_ITEM_REDO_MOVE,
	GNOME_APP_CONFIGURABLE_ITEM_HINT,
	/* 30 */
	GNOME_APP_CONFIGURABLE_ITEM_SCORES,
	GNOME_APP_CONFIGURABLE_ITEM_END_GAME
} GnomeUIInfoConfigurableTypes;
</ENUM>
<ENUM>
<NAME>GnomeUIPixmapType</NAME>
typedef enum {
	GNOME_APP_PIXMAP_NONE,		/* No pixmap specified */
	GNOME_APP_PIXMAP_STOCK,		/* Use a stock pixmap (GnomeStock) */
	GNOME_APP_PIXMAP_DATA,		/* Use a pixmap from inline xpm data */
	GNOME_APP_PIXMAP_FILENAME	/* Use a pixmap from the specified 
					   filename */
} GnomeUIPixmapType;
</ENUM>
<STRUCT>
<NAME>GnomeUIInfo</NAME>
typedef struct {
	GnomeUIInfoType type;		/* Type of item */
	gchar *label;			/* String to use in the label */
	gchar *hint;			/* For toolbar items, the tooltip. For 
					   menu items, the status bar message */
	gpointer moreinfo;		/* For an item, toggleitem, or 
					   radioitem, this is a pointer to the 
					   function to call when the item is 
					   activated. For a subtree, a pointer 
					   to another array of GnomeUIInfo 
					   structures. For a radioitem lead 
					   entry, a pointer to an array of 
					   GnomeUIInfo structures for the radio 
					   item group. For a help item, 
					   specifies the help node to load 
					   (i.e. the application's identifier) 
					   or NULL for the main program's name.
					   For builder data, points to the 
					   GnomeUIBuilderData structure for 
					   the following items */
	gpointer user_data;		/* Data pointer to pass to callbacks */
	gpointer unused_data;		/* Reserved for future expansion, 
					   should be NULL */
	GnomeUIPixmapType pixmap_type;	/* Type of pixmap for the item */
	gpointer pixmap_info;		/* Pointer to the pixmap information:
					 *
					 * For GNOME_APP_PIXMAP_STOCK, a 
					 * pointer to the stock icon name.
					 *
					 * For GNOME_APP_PIXMAP_DATA, a 
					 * pointer to the inline xpm data.
					 *
					 * For GNOME_APP_PIXMAP_FILENAME, a 
					 * pointer to the filename string.
					 */
	guint accelerator_key;		/* Accelerator key, or 0 for none */
	GdkModifierType ac_mods;	/* Mask of modifier keys for the 
					   accelerator */

	GtkWidget *widget;		/* Filled in by gnome_app_create*, you 
					   can use this to tweak the widgets 
					   once they have been created */
} GnomeUIInfo;
</STRUCT>
<MACRO>
<NAME>GNOMEUIINFO_KEY_UIDATA</NAME>
#define GNOMEUIINFO_KEY_UIDATA		"uidata"
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_KEY_UIBDATA</NAME>
#define GNOMEUIINFO_KEY_UIBDATA		"uibdata"
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_END</NAME>
#define GNOMEUIINFO_END			{ GNOME_APP_UI_ENDOFINFO, NULL, NULL, NULL, NULL, NULL,		\
					  (GnomeUIPixmapType) 0, NULL, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_SEPARATOR</NAME>
#define GNOMEUIINFO_SEPARATOR		{ GNOME_APP_UI_SEPARATOR, NULL, NULL, NULL, NULL, NULL,		\
					  (GnomeUIPixmapType) 0, NULL, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_ITEM</NAME>
#define GNOMEUIINFO_ITEM(label, tooltip, callback, xpm_data) \
	{ GNOME_APP_UI_ITEM, label, tooltip, callback, NULL, NULL, \
		GNOME_APP_PIXMAP_DATA, xpm_data, 0, (GdkModifierType) 0, NULL}
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_ITEM_STOCK</NAME>
#define GNOMEUIINFO_ITEM_STOCK(label, tooltip, callback, stock_id) \
	{ GNOME_APP_UI_ITEM, label, tooltip, callback, NULL, NULL, \
		GNOME_APP_PIXMAP_STOCK, stock_id, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_ITEM_NONE</NAME>
#define GNOMEUIINFO_ITEM_NONE(label, tooltip, callback) \
	{ GNOME_APP_UI_ITEM, label, tooltip, callback, NULL, NULL, \
		GNOME_APP_PIXMAP_NONE, NULL, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_ITEM_DATA</NAME>
#define GNOMEUIINFO_ITEM_DATA(label, tooltip, callback, user_data, xpm_data) \
	{ GNOME_APP_UI_ITEM, label, tooltip, callback, user_data, NULL, \
		GNOME_APP_PIXMAP_DATA, xpm_data, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_TOGGLEITEM</NAME>
#define GNOMEUIINFO_TOGGLEITEM(label, tooltip, callback, xpm_data) \
	{ GNOME_APP_UI_TOGGLEITEM, label, tooltip, callback, NULL, NULL, \
		GNOME_APP_PIXMAP_DATA, xpm_data, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_TOGGLEITEM_DATA</NAME>
#define GNOMEUIINFO_TOGGLEITEM_DATA(label, tooltip, callback, user_data, xpm_data)		\
					{ GNOME_APP_UI_TOGGLEITEM, label, tooltip, callback,	\
					  user_data, NULL, GNOME_APP_PIXMAP_DATA, xpm_data,	\
					  0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_HELP</NAME>
#define GNOMEUIINFO_HELP(app_name) \
	{ GNOME_APP_UI_HELP, NULL, NULL, app_name, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_SUBTREE</NAME>
#define GNOMEUIINFO_SUBTREE(label, tree) \
	{ GNOME_APP_UI_SUBTREE, label, NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_SUBTREE_HINT</NAME>
#define GNOMEUIINFO_SUBTREE_HINT(label, hint, tree) \
	{ GNOME_APP_UI_SUBTREE, label, hint, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_SUBTREE_STOCK</NAME>
#define GNOMEUIINFO_SUBTREE_STOCK(label, tree, stock_id) \
	{ GNOME_APP_UI_SUBTREE, label, NULL, tree, NULL, NULL, \
		GNOME_APP_PIXMAP_STOCK, stock_id, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_RADIOLIST</NAME>
#define GNOMEUIINFO_RADIOLIST(list) \
	{ GNOME_APP_UI_RADIOITEMS, NULL, NULL, list, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_RADIOITEM</NAME>
#define GNOMEUIINFO_RADIOITEM(label, tooltip, callback, xpm_data) \
	{ GNOME_APP_UI_ITEM, label, tooltip, callback, NULL, NULL, \
		GNOME_APP_PIXMAP_DATA, xpm_data, 0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_RADIOITEM_DATA</NAME>
#define GNOMEUIINFO_RADIOITEM_DATA(label, tooltip, callback, user_data, xpm_data)		\
					{ GNOME_APP_UI_ITEM, label, tooltip, callback,	\
					  user_data, NULL, GNOME_APP_PIXMAP_DATA, xpm_data,	\
					  0, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_NEW_ITEM</NAME>
#define GNOMEUIINFO_MENU_NEW_ITEM(label, tip, cb, data)                     \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, label, tip,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_NEW, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_NEW_SUBTREE</NAME>
#define GNOMEUIINFO_MENU_NEW_SUBTREE(tree)                                  \
        { GNOME_APP_UI_SUBTREE_STOCK, N_("_New"), NULL, tree, NULL, NULL,   \
          GNOME_APP_PIXMAP_STOCK, GNOME_STOCK_MENU_NEW,                     \
          GNOME_KEY_NAME_NEW, GNOME_KEY_MOD_NEW, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_OPEN_ITEM</NAME>
#define GNOMEUIINFO_MENU_OPEN_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_OPEN, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_SAVE_ITEM</NAME>
#define GNOMEUIINFO_MENU_SAVE_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_SAVE, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_SAVE_AS_ITEM</NAME>
#define GNOMEUIINFO_MENU_SAVE_AS_ITEM(cb, data)                             \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_SAVE_AS, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_REVERT_ITEM</NAME>
#define GNOMEUIINFO_MENU_REVERT_ITEM(cb, data)                              \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_REVERT, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_PRINT_ITEM</NAME>
#define GNOMEUIINFO_MENU_PRINT_ITEM(cb, data)                               \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_PRINT, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_PRINT_SETUP_ITEM</NAME>
#define GNOMEUIINFO_MENU_PRINT_SETUP_ITEM(cb, data)                         \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_PRINT_SETUP, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_CLOSE_ITEM</NAME>
#define GNOMEUIINFO_MENU_CLOSE_ITEM(cb, data)                               \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_CLOSE, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_EXIT_ITEM</NAME>
#define GNOMEUIINFO_MENU_EXIT_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_EXIT, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_CUT_ITEM</NAME>
#define GNOMEUIINFO_MENU_CUT_ITEM(cb, data)                                 \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_CUT, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_COPY_ITEM</NAME>
#define GNOMEUIINFO_MENU_COPY_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_COPY, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_PASTE_ITEM</NAME>
#define GNOMEUIINFO_MENU_PASTE_ITEM(cb, data)                               \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_PASTE, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_SELECT_ALL_ITEM</NAME>
#define GNOMEUIINFO_MENU_SELECT_ALL_ITEM(cb, data)                          \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_SELECT_ALL, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_CLEAR_ITEM</NAME>
#define GNOMEUIINFO_MENU_CLEAR_ITEM(cb, data)                               \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_CLEAR, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_UNDO_ITEM</NAME>
#define GNOMEUIINFO_MENU_UNDO_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_UNDO, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_REDO_ITEM</NAME>
#define GNOMEUIINFO_MENU_REDO_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_REDO, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_FIND_ITEM</NAME>
#define GNOMEUIINFO_MENU_FIND_ITEM(cb, data)                                \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_FIND, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_FIND_AGAIN_ITEM</NAME>
#define GNOMEUIINFO_MENU_FIND_AGAIN_ITEM(cb, data)                          \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_FIND_AGAIN, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_REPLACE_ITEM</NAME>
#define GNOMEUIINFO_MENU_REPLACE_ITEM(cb, data)                             \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_REPLACE, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_PROPERTIES_ITEM</NAME>
#define GNOMEUIINFO_MENU_PROPERTIES_ITEM(cb, data)                          \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_PROPERTIES, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_PREFERENCES_ITEM</NAME>
#define GNOMEUIINFO_MENU_PREFERENCES_ITEM(cb, data)                         \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_PREFERENCES, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_NEW_WINDOW_ITEM</NAME>
#define GNOMEUIINFO_MENU_NEW_WINDOW_ITEM(cb, data)                          \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_NEW_WINDOW, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_CLOSE_WINDOW_ITEM</NAME>
#define GNOMEUIINFO_MENU_CLOSE_WINDOW_ITEM(cb, data)                        \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_CLOSE_WINDOW, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_ABOUT_ITEM</NAME>
#define GNOMEUIINFO_MENU_ABOUT_ITEM(cb, data)                               \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_ABOUT, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_NEW_GAME_ITEM</NAME>
#define GNOMEUIINFO_MENU_NEW_GAME_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_NEW_GAME, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_PAUSE_GAME_ITEM</NAME>
#define GNOMEUIINFO_MENU_PAUSE_GAME_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_PAUSE_GAME, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_RESTART_GAME_ITEM</NAME>
#define GNOMEUIINFO_MENU_RESTART_GAME_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_RESTART_GAME, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_UNDO_MOVE_ITEM</NAME>
#define GNOMEUIINFO_MENU_UNDO_MOVE_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_UNDO_MOVE, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_REDO_MOVE_ITEM</NAME>
#define GNOMEUIINFO_MENU_REDO_MOVE_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_REDO_MOVE, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_HINT_ITEM</NAME>
#define GNOMEUIINFO_MENU_HINT_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_HINT, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_SCORES_ITEM</NAME>
#define GNOMEUIINFO_MENU_SCORES_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_SCORES, (GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_END_GAME_ITEM</NAME>
#define GNOMEUIINFO_MENU_END_GAME_ITEM(cb, data)                            \
        { GNOME_APP_UI_ITEM_CONFIGURABLE, NULL, NULL,                       \
          cb, (gpointer)(data), NULL,                                       \
          GNOME_APP_PIXMAP_NONE, NULL,                                      \
          GNOME_APP_CONFIGURABLE_ITEM_END_GAME, (GdkModifierType) 0, NULL }
</MACRO>
<FUNCTION>
<NAME>gnome_app_helper_gettext</NAME>
<RETURNS>char  *</RETURNS>
char *string
</FUNCTION>
<MACRO>
<NAME>D_</NAME>
#define D_(x) dgettext (PACKAGE, x)
</MACRO>
<MACRO>
<NAME>L_</NAME>
#define L_(x) gnome_app_helper_gettext(x)
</MACRO>
<MACRO>
<NAME>D_</NAME>
#define D_(x) x
</MACRO>
<MACRO>
<NAME>L_</NAME>
#define L_(x) x
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_FILE_TREE</NAME>
#define GNOMEUIINFO_MENU_FILE_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_File"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_EDIT_TREE</NAME>
#define GNOMEUIINFO_MENU_EDIT_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_Edit"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_VIEW_TREE</NAME>
#define GNOMEUIINFO_MENU_VIEW_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_View"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_SETTINGS_TREE</NAME>
#define GNOMEUIINFO_MENU_SETTINGS_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_Settings"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_FILES_TREE</NAME>
#define GNOMEUIINFO_MENU_FILES_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("Fi_les"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_WINDOWS_TREE</NAME>
#define GNOMEUIINFO_MENU_WINDOWS_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_Windows"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_HELP_TREE</NAME>
#define GNOMEUIINFO_MENU_HELP_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_Help"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOMEUIINFO_MENU_GAME_TREE</NAME>
#define GNOMEUIINFO_MENU_GAME_TREE(tree) \
	{ GNOME_APP_UI_SUBTREE_STOCK, N_("_Game"), NULL, tree, NULL, NULL, \
		(GnomeUIPixmapType) 0, NULL, 0,	(GdkModifierType) 0, NULL }
</MACRO>
<MACRO>
<NAME>GNOME_MENU_FILE_STRING</NAME>
#define GNOME_MENU_FILE_STRING D_("_File")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_FILE_PATH</NAME>
#define GNOME_MENU_FILE_PATH D_("_File/")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_EDIT_STRING</NAME>
#define GNOME_MENU_EDIT_STRING D_("_Edit")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_EDIT_PATH</NAME>
#define GNOME_MENU_EDIT_PATH D_("_Edit/")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_VIEW_STRING</NAME>
#define GNOME_MENU_VIEW_STRING D_("_View")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_VIEW_PATH</NAME>
#define GNOME_MENU_VIEW_PATH D_("_View/")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_SETTINGS_STRING</NAME>
#define GNOME_MENU_SETTINGS_STRING D_("_Settings")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_SETTINGS_PATH</NAME>
#define GNOME_MENU_SETTINGS_PATH D_("_Settings/")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_NEW_STRING</NAME>
#define GNOME_MENU_NEW_STRING D_("_New")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_NEW_PATH</NAME>
#define GNOME_MENU_NEW_PATH D_("_New/")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_FILES_STRING</NAME>
#define GNOME_MENU_FILES_STRING D_("Fi_les")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_FILES_PATH</NAME>
#define GNOME_MENU_FILES_PATH D_("Fi_les/")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_WINDOWS_STRING</NAME>
#define GNOME_MENU_WINDOWS_STRING D_("_Windows")
</MACRO>
<MACRO>
<NAME>GNOME_MENU_WINDOWS_PATH</NAME>
#define GNOME_MENU_WINDOWS_PATH D_("_Windows/")
</MACRO>
<STRUCT>
<NAME>GnomeUIBuilderData</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GnomeUISignalConnectFunc</NAME>
<RETURNS>void </RETURNS>
GnomeUIInfo        *uiinfo,
					   gchar              *signal_name,
					   GnomeUIBuilderData *uibdata
</USER_FUNCTION>
<STRUCT>
<NAME>GnomeUIBuilderData</NAME>
struct GnomeUIBuilderData {
	GnomeUISignalConnectFunc connect_func;	/* Function that connects to the item's signals */
	gpointer data;				/* User data pointer */
	gboolean is_interp;			/* Should use gtk_signal_connect_interp or normal gtk_signal_connect? */
	GtkCallbackMarshal relay_func;		/* Marshaller function for language bindings */
	GtkDestroyNotify destroy_func;		/* Destroy notification function for language bindings */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_accelerators_sync</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_fill_menu</NAME>
<RETURNS>void  </RETURNS>
GtkMenuShell	*menu_shell,GnomeUIInfo	*uiinfo,GtkAccelGroup	*accel_group,gboolean	 uline_accels,gint		 pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_fill_menu_with_data</NAME>
<RETURNS>void  </RETURNS>
GtkMenuShell	*menu_shell,GnomeUIInfo		*uiinfo,GtkAccelGroup	*accel_group,gboolean		 uline_accels,gint		 pos,gpointer		 user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_fill_menu_custom</NAME>
<RETURNS>void  </RETURNS>
GtkMenuShell	    *menu_shell,GnomeUIInfo	    *uiinfo,GnomeUIBuilderData *uibdata,GtkAccelGroup	    *accel_group,gboolean	     uline_accels,gint		     pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_ui_configure_configurable</NAME>
<RETURNS>void  </RETURNS>
GnomeUIInfo* uiinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_menus</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_menus_interp</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo,GtkCallbackMarshal relay_func, gpointer data,GtkDestroyNotify destroy_func
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_menus_with_data</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_menus_custom</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo, GnomeUIBuilderData *uibdata
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_fill_toolbar</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar *toolbar, GnomeUIInfo *uiinfo, GtkAccelGroup *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_fill_toolbar_with_data</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar *toolbar, GnomeUIInfo *uiinfo,GtkAccelGroup *accel_group, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_fill_toolbar_custom</NAME>
<RETURNS>void  </RETURNS>
GtkToolbar *toolbar, GnomeUIInfo *uiinfo, GnomeUIBuilderData *uibdata,GtkAccelGroup *accel_group
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_toolbar</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_toolbar_interp</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo,GtkCallbackMarshal relay_func, gpointer data,GtkDestroyNotify destroy_func
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_toolbar_with_data</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_create_toolbar_custom</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GnomeUIInfo *uiinfo, GnomeUIBuilderData *uibdata
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_find_menu_pos</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkWidget *parent, gchar *path, gint *pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_remove_menus</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *path, gint items
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_remove_menu_range</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *path, gint start, gint items
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_insert_menus_custom</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *path, GnomeUIInfo *menuinfo, GnomeUIBuilderData *uibdata
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_insert_menus</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *path, GnomeUIInfo *menuinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_insert_menus_with_data</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *path, GnomeUIInfo *menuinfo, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_insert_menus_interp</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *path, GnomeUIInfo *menuinfo,GtkCallbackMarshal relay_func, gpointer data,GtkDestroyNotify destroy_func
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_install_appbar_menu_hints</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar* appbar,GnomeUIInfo* uiinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_install_statusbar_menu_hints</NAME>
<RETURNS>void  </RETURNS>
GtkStatusbar* bar,GnomeUIInfo* uiinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_install_menu_hints</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app,GnomeUIInfo *uinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_message</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * message
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_flash</NAME>
<RETURNS>void</RETURNS>
GnomeApp * app, const gchar * flash
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_error</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * error
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_warning</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * warning
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_question</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * question,GnomeReplyCallback callback, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_question_modal</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * question,GnomeReplyCallback callback, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_ok_cancel</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * message,GnomeReplyCallback callback, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_ok_cancel_modal</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * message,GnomeReplyCallback callback, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_request_string</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * prompt,GnomeStringCallback callback, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_request_password</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeApp * app, const gchar * prompt,GnomeStringCallback callback, gpointer data
</FUNCTION>
<USER_FUNCTION>
<NAME>GnomeAppProgressFunc</NAME>
<RETURNS>gdouble </RETURNS>
gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeAppProgressCancelFunc</NAME>
<RETURNS>void </RETURNS>
gpointer data
</USER_FUNCTION>
<TYPEDEF>
<NAME>GnomeAppProgressKey</NAME>
typedef gpointer GnomeAppProgressKey;
</TYPEDEF>
<FUNCTION>
<NAME>gnome_app_progress_timeout</NAME>
<RETURNS>GnomeAppProgressKey</RETURNS>
GnomeApp * app,const gchar * description,guint32 interval,GnomeAppProgressFunc percentage_cb,GnomeAppProgressCancelFunc cancel_cb,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_progress_manual</NAME>
<RETURNS>GnomeAppProgressKey</RETURNS>
GnomeApp * app,const gchar * description,GnomeAppProgressCancelFunc cancel_cb,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_set_progress</NAME>
<RETURNS>void</RETURNS>
GnomeAppProgressKey key, gdouble percent
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_progress_done</NAME>
<RETURNS>void</RETURNS>
GnomeAppProgressKey key
</FUNCTION>
<MACRO>
<NAME>GNOME_APP_MENUBAR_NAME</NAME>
#define GNOME_APP_MENUBAR_NAME "Menubar"
</MACRO>
<MACRO>
<NAME>GNOME_APP_TOOLBAR_NAME</NAME>
#define GNOME_APP_TOOLBAR_NAME "Toolbar"
</MACRO>
<MACRO>
<NAME>GNOME_APP</NAME>
#define GNOME_APP(obj)         GTK_CHECK_CAST(obj, gnome_app_get_type(), GnomeApp)
</MACRO>
<MACRO>
<NAME>GNOME_APP_CLASS</NAME>
#define GNOME_APP_CLASS(class) GTK_CHECK_CAST_CLASS(class, gnome_app_get_type(), GnomeAppClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_APP</NAME>
#define GNOME_IS_APP(obj)      GTK_CHECK_TYPE(obj, gnome_app_get_type())
</MACRO>
<STRUCT>
<NAME>GnomeApp</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAppClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeApp</NAME>
struct GnomeApp {
	GtkWindow parent_object;

	/* Application name. */
	char *name;

	/* Prefix for gnome-config (used to save the layout).  */
	char *prefix;

        /* The dock.  */
        GtkWidget *dock;

	/* The status bar.  */
        GtkWidget *statusbar;

	/* The vbox widget that ties them.  */
	GtkWidget *vbox;

	/* The menubar.  This is a pointer to a widget contained into
           the dock.  */
	GtkWidget *menubar;

	/* The contents.  This is a pointer to dock->client_area.  */
	GtkWidget *contents;

	/* Dock layout.  */
	GnomeDockLayout *layout;

	/* Main accelerator group for this window (hotkeys live here).  */
	GtkAccelGroup *accel_group;

	/* If TRUE, the application uses gnome-config to retrieve and
           save the docking configuration automagically.  */
	gboolean enable_layout_config : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_app_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gchar *appname, char *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_construct</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gchar *appname, char *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_set_menus</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GtkMenuBar *menubar
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_set_toolbar</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GtkToolbar *toolbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_set_statusbar</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GtkWidget *statusbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_set_statusbar_custom</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app,GtkWidget *container,GtkWidget *statusbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_set_contents</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, GtkWidget *contents
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_add_toolbar</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app,GtkToolbar *toolbar,const gchar *name,GnomeDockItemBehavior behavior,GnomeDockPlacement placement,gint band_num,gint band_position,gint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_add_docked</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app,GtkWidget *widget,const gchar *name,GnomeDockItemBehavior behavior,GnomeDockPlacement placement,gint band_num,gint band_position,gint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_add_dock_item</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app,GnomeDockItem *item,GnomeDockPlacement placement,gint band_num,gint band_position,gint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_enable_layout_config</NAME>
<RETURNS>void  </RETURNS>
GnomeApp *app, gboolean enable
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_get_dock</NAME>
<RETURNS>GnomeDock  *</RETURNS>
GnomeApp *app
</FUNCTION>
<FUNCTION>
<NAME>gnome_app_get_dock_item_by_name</NAME>
<RETURNS>GnomeDockItem  *</RETURNS>
GnomeApp *app,const gchar *name
</FUNCTION>
<MACRO>
<NAME>GNOME_APPBAR</NAME>
#define GNOME_APPBAR(obj)          GTK_CHECK_CAST (obj, gnome_appbar_get_type (), GnomeAppBar)
</MACRO>
<MACRO>
<NAME>GNOME_APPBAR_CLASS</NAME>
#define GNOME_APPBAR_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_appbar_get_type (), GnomeAppBarClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_APPBAR</NAME>
#define GNOME_IS_APPBAR(obj)       GTK_CHECK_TYPE (obj, gnome_appbar_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_APPBAR_HAS_STATUS</NAME>
#define GNOME_APPBAR_HAS_STATUS(appbar) (GNOME_APPBAR(appbar)->status != NULL)
</MACRO>
<MACRO>
<NAME>GNOME_APPBAR_HAS_PROGRESS</NAME>
#define GNOME_APPBAR_HAS_PROGRESS(appbar) (GNOME_APPBAR(appbar)->progress != NULL)
</MACRO>
<STRUCT>
<NAME>GnomeAppBar</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAppBarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAppBarMsg</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeAppBar</NAME>
struct GnomeAppBar
{
  GtkHBox parent_widget;

  /* Private; there's no guarantee on the type of these in the
     future. Statusbar could be a label, entry, GtkStatusbar, or
     something else; progress could be a label or progress bar; it's
     all up in the air for now. */
  GtkWidget * progress;
  GtkWidget * status;
  guint interactive : 1; /* This means status is an entry rather than a
			   label, for the moment. */
  gint editable_start; /* The first editable position in the interactive
			  buffer. */
  gchar * prompt; /* The text of a prompt, if any. */

  /* Keep it simple; no contexts. 
     if (status_stack) display_top_of_stack;
     else if (default_status) display_default;
     else display_nothing;      */
  /* Also private by the way */
  GSList * status_stack;
  gchar  * default_status;
};
</STRUCT>
<MACRO>
<NAME>GNOME_APPBAR_INTERACTIVE</NAME>
#define GNOME_APPBAR_INTERACTIVE(ab) ((ab) ? (ab)->interactive : FALSE)
</MACRO>
<FUNCTION>
<NAME>gnome_appbar_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
gboolean has_progress,gboolean has_status,GnomePreferencesType interactivity
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_set_status</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar,const gchar * status
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_set_default</NAME>
<RETURNS>void 	</RETURNS>
GnomeAppBar * appbar,const gchar * default_status
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_push</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar,const gchar * status
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_pop</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_clear_stack</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_set_progress</NAME>
<RETURNS>void 	</RETURNS>
GnomeAppBar *appbar,gfloat percentage
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_get_progress</NAME>
<RETURNS>GtkProgress *</RETURNS>
GnomeAppBar * appbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_refresh</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_set_prompt</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar,const gchar * prompt,gboolean modal
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_clear_prompt</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * appbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_get_response</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeAppBar * appbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_appbar_construct</NAME>
<RETURNS>void  </RETURNS>
GnomeAppBar * ab,gboolean has_progress,gboolean has_status,GnomePreferencesType interactivity
</FUNCTION>
<MACRO>
<NAME>GNOME_CALCULATOR</NAME>
#define GNOME_CALCULATOR(obj)         GTK_CHECK_CAST (obj, gnome_calculator_get_type (), GnomeCalculator)
</MACRO>
<MACRO>
<NAME>GNOME_CALCULATOR_CLASS</NAME>
#define GNOME_CALCULATOR_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_calculator_get_type (), GnomeCalculatorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_CALCULATOR</NAME>
#define GNOME_IS_CALCULATOR(obj)      GTK_CHECK_TYPE (obj, gnome_calculator_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeCalculator</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCalculatorClass</NAME>
</STRUCT>
<ENUM>
<NAME>GnomeCalculatorMode</NAME>
typedef enum {
	GNOME_CALCULATOR_DEG,
	GNOME_CALCULATOR_RAD,
	GNOME_CALCULATOR_GRAD
} GnomeCalculatorMode;
</ENUM>
<STRUCT>
<NAME>GnomeCalculator</NAME>
struct GnomeCalculator {
	GtkVBox vbox;

	gdouble result;
	gchar result_string[13];
	gdouble memory;

	GtkWidget *display;

	GnomeCalculatorMode mode;

	guint add_digit : 1;	/*add a digit instead of starting a new
				  number*/
	guint error : 1;
	guint invert : 1;
	GtkWidget *invert_button;

	GList *stack;
	GtkAccelGroup *accel;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_calculator_get_type</NAME>
<RETURNS>guint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_calculator_new</NAME>
<RETURNS>GtkWidget 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_calculator_clear</NAME>
<RETURNS>void 	</RETURNS>
GnomeCalculator *gc,const gboolean reset
</FUNCTION>
<FUNCTION>
<NAME>gnome_calculator_set</NAME>
<RETURNS>void 	</RETURNS>
GnomeCalculator *gc,gdouble result
</FUNCTION>
<MACRO>
<NAME>gnome_calculator_get_result</NAME>
#define gnome_calculator_get_result(gc) (GNOME_CALCULATOR(gc)->result)
</MACRO>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_IMAGE</NAME>
#define GNOME_TYPE_CANVAS_IMAGE            (gnome_canvas_image_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_IMAGE</NAME>
#define GNOME_CANVAS_IMAGE(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_IMAGE, GnomeCanvasImage))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_IMAGE_CLASS</NAME>
#define GNOME_CANVAS_IMAGE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_IMAGE, GnomeCanvasImageClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_IMAGE</NAME>
#define GNOME_IS_CANVAS_IMAGE(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_IMAGE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_IMAGE_CLASS</NAME>
#define GNOME_IS_CANVAS_IMAGE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_IMAGE))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasImage</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasImageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasImage</NAME>
struct GnomeCanvasImage {
	GnomeCanvasItem item;

	GdkImlibImage *im;		/* The image to paint */
	GdkPixmap *pixmap;		/* Pixmap rendered from the image */
	GdkBitmap *mask;		/* Mask rendered from the image */

	double x, y;			/* Position at anchor, item relative */
	double width, height;		/* Size of image, item relative */
	GtkAnchorType anchor;		/* Anchor side for image */

	int cx, cy;			/* Top-left canvas coordinates for display */
	int cwidth, cheight;		/* Rendered size in pixels */
	GdkGC *gc;			/* GC for drawing image */

	unsigned int need_recalc : 1;	/* Do we need to rescale the image? */

	ArtPixBuf *pixbuf;		/* A pixbuf, for aa rendering */
	double affine[6];               /* The item -> canvas affine */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_image_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_LINE</NAME>
#define GNOME_TYPE_CANVAS_LINE            (gnome_canvas_line_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_LINE</NAME>
#define GNOME_CANVAS_LINE(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_LINE, GnomeCanvasLine))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_LINE_CLASS</NAME>
#define GNOME_CANVAS_LINE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_LINE, GnomeCanvasLineClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_LINE</NAME>
#define GNOME_IS_CANVAS_LINE(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_LINE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_LINE_CLASS</NAME>
#define GNOME_IS_CANVAS_LINE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_LINE))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasLine</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasLineClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasLine</NAME>
struct GnomeCanvasLine {
	GnomeCanvasItem item;

	int num_points;		/* Number of points in the line */
	double *coords;		/* Array of coordinates for the line's points.  X coords are in the
				 * even indices, Y coords are in the odd indices.  If the line has
				 * arrowheads then the first and last points have been adjusted to
				 * refer to the necks of the arrowheads rather than their tips.  The
				 * actual endpoints are stored in the first_arrow and last_arrow
				 * arrays, if they exist.
				 */

	double width;		/* Width of the line */

	guint fill_color;	/* Fill color, RGBA */

	gulong fill_pixel;	/* Color for line */

	GdkBitmap *stipple;	/* Stipple pattern */

	GdkCapStyle cap;	/* Cap style for line */
	GdkJoinStyle join;	/* Join style for line */
	GdkLineStyle line_style;/* Style for the line */

	double shape_a;		/* Distance from tip of arrowhead to center */
	double shape_b;		/* Distance from tip of arrowhead to trailing point, measured along shaft */
	double shape_c;		/* Distance of trailing points from outside edge of shaft */

	double *first_coords;	/* Array of points describing polygon for the first arrowhead */
	double *last_coords;	/* Array of points describing polygon for the last arrowhead */

	int spline_steps;	/* Number of steps in each spline segment */

	GdkGC *gc;		/* GC for drawing line */

	guint width_pixels : 1;	/* Is the width specified in pixels or units? */
	guint first_arrow : 1;	/* Draw first arrowhead? */
	guint last_arrow : 1;	/* Draw last arrowhead? */
	guint smooth : 1;	/* Smooth line (with parabolic splines)? */

	/* Antialiased specific stuff follows */
	guint32 fill_rgba;		/* RGBA color for outline */
	ArtSVP *fill_svp;		/* The SVP for the outline shape */
	ArtSVP *first_svp;		/* The SVP for the first arrow */
	ArtSVP *last_svp;		/* The SVP for the last arrow */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_line_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_load_alpha</NAME>
<RETURNS>GdkImlibImage  *</RETURNS>
char *file
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_destroy_image</NAME>
<RETURNS>void  </RETURNS>
GdkImlibImage *image
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_POLYGON</NAME>
#define GNOME_TYPE_CANVAS_POLYGON            (gnome_canvas_polygon_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_POLYGON</NAME>
#define GNOME_CANVAS_POLYGON(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_POLYGON, GnomeCanvasPolygon))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_POLYGON_CLASS</NAME>
#define GNOME_CANVAS_POLYGON_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_POLYGON, GnomeCanvasPolygonClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_POLYGON</NAME>
#define GNOME_IS_CANVAS_POLYGON(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_POLYGON))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_POLYGON_CLASS</NAME>
#define GNOME_IS_CANVAS_POLYGON_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_POLYGON))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasPolygon</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasPolygonClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasPolygon</NAME>
struct GnomeCanvasPolygon {
	GnomeCanvasItem item;

	int num_points;			/* Number of points in the polygon */
	double *coords;			/* Array of coordinates for the polygon's points.  X coords
					 * are in the even indices, Y coords are in the odd indices.
					 */

	double width;			/* Width of polygon's outline */

	guint fill_color;		/* Fill color, RGBA */
	guint outline_color;		/* Outline color, RGBA */

	gulong fill_pixel;		/* Color for fill */
	gulong outline_pixel;		/* Color for outline */

	GdkBitmap *fill_stipple;	/* Stipple for fill */
	GdkBitmap *outline_stipple;	/* Stipple for outline */

	GdkGC *fill_gc;			/* GC for filling */
	GdkGC *outline_gc;		/* GC for outline */

	guint fill_set : 1;		/* Is fill color set? */
	guint outline_set : 1;		/* Is outline color set? */
	guint width_pixels : 1;		/* Is outline width specified in pixels or units? */

	/* Antialiased specific stuff follows */
	guint32 fill_rgba;		/* RGBA color for filling */
	ArtSVP *fill_svp;		/* The SVP for the filled shape */
	guint32 outline_rgba;		/* RGBA color for outline */
	ArtSVP *outline_svp;		/* The SVP for the outline shape */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_polygon_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_RE</NAME>
#define GNOME_TYPE_CANVAS_RE            (gnome_canvas_re_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_RE</NAME>
#define GNOME_CANVAS_RE(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_RE, GnomeCanvasRE))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_RE_CLASS</NAME>
#define GNOME_CANVAS_RE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_RE, GnomeCanvasREClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_RE</NAME>
#define GNOME_IS_CANVAS_RE(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_RE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_RE_CLASS</NAME>
#define GNOME_IS_CANVAS_RE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_RE))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasRE</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasREClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasRE</NAME>
struct GnomeCanvasRE {
	GnomeCanvasItem item;

	double x1, y1, x2, y2;		/* Corners of item */
	double width;			/* Outline width */

	guint fill_color;		/* Fill color, RGBA */
	guint outline_color;		/* Outline color, RGBA */

	gulong fill_pixel;		/* Fill color */
	gulong outline_pixel;		/* Outline color */

	GdkBitmap *fill_stipple;	/* Stipple for fill */
	GdkBitmap *outline_stipple;	/* Stipple for outline */

	GdkGC *fill_gc;			/* GC for filling */
	GdkGC *outline_gc;		/* GC for outline */

	/* Antialiased specific stuff follows */

	ArtSVP *fill_svp;		/* The SVP for the filled shape */
	ArtSVP *outline_svp;		/* The SVP for the outline shape */

	/* Configuration flags */

	unsigned int fill_set : 1;	/* Is fill color set? */
	unsigned int outline_set : 1;	/* Is outline color set? */
	unsigned int width_pixels : 1;	/* Is outline width specified in pixels or units? */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_re_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_RECT</NAME>
#define GNOME_TYPE_CANVAS_RECT            (gnome_canvas_rect_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_RECT</NAME>
#define GNOME_CANVAS_RECT(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_RECT, GnomeCanvasRect))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_RECT_CLASS</NAME>
#define GNOME_CANVAS_RECT_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_RECT, GnomeCanvasRectClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_RECT</NAME>
#define GNOME_IS_CANVAS_RECT(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_RECT))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_RECT_CLASS</NAME>
#define GNOME_IS_CANVAS_RECT_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_RECT))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasRect</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasRectClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasRect</NAME>
struct GnomeCanvasRect {
	GnomeCanvasRE re;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_rect_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_ELLIPSE</NAME>
#define GNOME_TYPE_CANVAS_ELLIPSE            (gnome_canvas_ellipse_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_ELLIPSE</NAME>
#define GNOME_CANVAS_ELLIPSE(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_ELLIPSE, GnomeCanvasEllipse))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_ELLIPSE_CLASS</NAME>
#define GNOME_CANVAS_ELLIPSE_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_ELLIPSE, GnomeCanvasEllipseClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_ELLIPSE</NAME>
#define GNOME_IS_CANVAS_ELLIPSE(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_ELLIPSE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_ELLIPSE_CLASS</NAME>
#define GNOME_IS_CANVAS_ELLIPSE_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_ELLIPSE))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasEllipse</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasEllipseClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasEllipse</NAME>
struct GnomeCanvasEllipse {
	GnomeCanvasRE re;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_ellipse_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_TEXT</NAME>
#define GNOME_TYPE_CANVAS_TEXT            (gnome_canvas_text_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_TEXT</NAME>
#define GNOME_CANVAS_TEXT(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_TEXT, GnomeCanvasText))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_TEXT_CLASS</NAME>
#define GNOME_CANVAS_TEXT_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_TEXT, GnomeCanvasTextClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_TEXT</NAME>
#define GNOME_IS_CANVAS_TEXT(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_TEXT))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_TEXT_CLASS</NAME>
#define GNOME_IS_CANVAS_TEXT_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_TEXT))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasText</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasTextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasTextSuckFont</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasTextSuckChar</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasTextSuckChar</NAME>
struct GnomeCanvasTextSuckChar {
	int     left_sb;
	int     right_sb;
	int     width;
	int     ascent;
	int     descent;
	int     bitmap_offset; /* in pixels */
};
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasTextSuckFont</NAME>
struct GnomeCanvasTextSuckFont {
	guchar *bitmap;
	gint    bitmap_width;
	gint    bitmap_height;
	gint    ascent;
	GnomeCanvasTextSuckChar chars[256];
};
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasText</NAME>
struct GnomeCanvasText {
	GnomeCanvasItem item;

	char *text;			/* Text to display */
	gpointer lines;			/* Text split into lines (private field) */
	int num_lines;			/* Number of lines of text */

	double x, y;			/* Position at anchor */
	GdkFont *font;			/* Font for text */
	GtkAnchorType anchor;		/* Anchor side for text */
	GtkJustification justification;	/* Justification for text */

	double clip_width;		/* Width of optional clip rectangle */
	double clip_height;		/* Height of optional clip rectangle */

	double xofs, yofs;		/* Text offset distance from anchor position */

	gulong pixel;			/* Fill color */
	GdkBitmap *stipple;		/* Stipple for text */
	GdkGC *gc;			/* GC for drawing text */

	int cx, cy;			/* Top-left canvas coordinates for text */
	int clip_cx, clip_cy;		/* Top-left canvas coordinates for clip rectangle */
	int clip_cwidth, clip_cheight;	/* Size of clip rectangle in pixels */
	int max_width;			/* Maximum width of text lines */
	int height;			/* Rendered text height in pixels */

	guint clip : 1;			/* Use clip rectangle? */

	/* Antialiased specific stuff follows */
	GnomeCanvasTextSuckFont *suckfont; /* Sucked font */
	guint32 rgba;			/* RGBA color for text */
	double affine[6];               /* The item -> canvas affine */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_text_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GnomeCanvasPoints</NAME>
typedef struct {
	int num_points;
	double *coords;
	int ref_count;
} GnomeCanvasPoints;
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_points_new</NAME>
<RETURNS>GnomeCanvasPoints  *</RETURNS>
int num_points
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_points_ref</NAME>
<RETURNS>GnomeCanvasPoints  *</RETURNS>
GnomeCanvasPoints *points
</FUNCTION>
<MACRO>
<NAME>gnome_canvas_points_unref</NAME>
#define gnome_canvas_points_unref gnome_canvas_points_free
</MACRO>
<FUNCTION>
<NAME>gnome_canvas_points_free</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasPoints *points
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_miter_points</NAME>
<RETURNS>int  </RETURNS>
double x1, double y1, double x2, double y2, double x3, double y3,double width,double *mx1, double *my1, double *mx2, double *my2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_butt_points</NAME>
<RETURNS>void  </RETURNS>
double x1, double y1, double x2, double y2,double width, int project,double *bx1, double *by1, double *bx2, double *by2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_polygon_to_point</NAME>
<RETURNS>double  </RETURNS>
double *poly, int num_points, double x, double y
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_render_svp</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasBuf *buf, ArtSVP *svp, guint32 rgba
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_update_svp</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, ArtSVP **p_svp, ArtSVP *new_svp
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_update_svp_clip</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, ArtSVP **p_svp, ArtSVP *new_svp,ArtSVP *clip_svp
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_reset_bounds</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_update_svp</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, ArtSVP **p_svp, ArtSVP *new_svp
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_update_svp_clip</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, ArtSVP **p_svp, ArtSVP *new_svp,ArtSVP *clip_svp
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_request_redraw_svp</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, const ArtSVP *svp
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_update_bbox</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, int x1, int y1, int x2, int y2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_buf_ensure_buf</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasBuf *buf
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_join_gdk_to_art</NAME>
<RETURNS>ArtPathStrokeJoinType  </RETURNS>
GdkJoinStyle gdk_join
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_cap_gdk_to_art</NAME>
<RETURNS>ArtPathStrokeCapType  </RETURNS>
GdkCapStyle gdk_cap
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_WIDGET</NAME>
#define GNOME_TYPE_CANVAS_WIDGET            (gnome_canvas_widget_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_WIDGET</NAME>
#define GNOME_CANVAS_WIDGET(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_WIDGET, GnomeCanvasWidget))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_WIDGET_CLASS</NAME>
#define GNOME_CANVAS_WIDGET_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_WIDGET, GnomeCanvasWidgetClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_WIDGET</NAME>
#define GNOME_IS_CANVAS_WIDGET(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_WIDGET))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_WIDGET_CLASS</NAME>
#define GNOME_IS_CANVAS_WIDGET_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_WIDGET))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasWidgetClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasWidget</NAME>
struct GnomeCanvasWidget {
	GnomeCanvasItem item;

	GtkWidget *widget;		/* The child widget */

	double x, y;			/* Position at anchor */
	double width, height;		/* Dimensions of widget */
	GtkAnchorType anchor;		/* Anchor side for widget */

	int cx, cy;			/* Top-left canvas coordinates for widget */
	int cwidth, cheight;		/* Size of widget in pixels */

	guint destroy_id;		/* Signal connection id for destruction of child widget */

	guint size_pixels : 1;		/* Is size specified in (unchanging) pixels or units (get scaled)? */
	guint in_destroy : 1;		/* Is child widget being destroyed? */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_widget_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_CANVAS_EPSILON</NAME>
#define GNOME_CANVAS_EPSILON 1e-10
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_COLOR</NAME>
#define GNOME_CANVAS_COLOR(r, g, b) ((((int) (r) & 0xff) << 24)	\
				     | (((int) (g) & 0xff) << 16)	\
				     | (((int) (b) & 0xff) << 8)	\
				     | 0xff)
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_COLOR_A</NAME>
#define GNOME_CANVAS_COLOR_A(r, g, b, a) ((((int) (r) & 0xff) << 24)	\
					  | (((int) (g) & 0xff) << 16)	\
					  | (((int) (b) & 0xff) << 8)	\
					  | ((int) (a) & 0xff))
</MACRO>
<STRUCT>
<NAME>GnomeCanvas</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasGroup</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasGroupClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeCanvasBuf</NAME>
typedef struct {
	/* 24-bit RGB buffer for rendering */
	guchar *buf;

	/* Rowstride for the buffer */
	int buf_rowstride;

	/* Rectangle describing the rendering area */
	ArtIRect rect;

	/* Background color, given as 0xrrggbb */
	guint32 bg_color;

	/* Invariant: at least one of the following flags is true. */

	/* Set when the render rectangle area is the solid color bg_color */
	unsigned int is_bg : 1;

	/* Set when the render rectangle area is represented by the buf */
	unsigned int is_buf : 1;
} GnomeCanvasBuf;
</STRUCT>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_ITEM</NAME>
#define GNOME_TYPE_CANVAS_ITEM            (gnome_canvas_item_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_ITEM</NAME>
#define GNOME_CANVAS_ITEM(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_ITEM, GnomeCanvasItem))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_ITEM_CLASS</NAME>
#define GNOME_CANVAS_ITEM_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_ITEM, GnomeCanvasItemClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_ITEM</NAME>
#define GNOME_IS_CANVAS_ITEM(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_ITEM))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_ITEM_CLASS</NAME>
#define GNOME_IS_CANVAS_ITEM_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_ITEM))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasItem</NAME>
struct GnomeCanvasItem {
	GtkObject object;

	/* Parent canvas for this item */
	GnomeCanvas *canvas;

	/* Parent canvas group for this item (a GnomeCanvasGroup) */
	GnomeCanvasItem *parent;

	/* Bounding box for this item (in world coordinates) */
	double x1, y1, x2, y2;

	/* If NULL, assumed to be the identity tranform.  If flags does not have
	 * AFFINE_FULL, then a two-element array containing a translation.  If
	 * flags contains AFFINE_FULL, a six-element array containing an affine
	 * transformation.
	 */
	double *xform;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_new</NAME>
<RETURNS>GnomeCanvasItem  *</RETURNS>
GnomeCanvasGroup *parent, GtkType type,const gchar *first_arg_name, ...
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_newv</NAME>
<RETURNS>GnomeCanvasItem  *</RETURNS>
GnomeCanvasGroup *parent, GtkType type,guint nargs, GtkArg *args
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_construct</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, GnomeCanvasGroup *parent,const gchar *first_arg_name, va_list args
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_constructv</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, GnomeCanvasGroup *parent,guint nargs, GtkArg *args
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_set</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, const gchar *first_arg_name, ...
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_setv</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, guint nargs, GtkArg *args
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_set_valist</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item,const gchar *first_arg_name, va_list args
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_move</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, double dx, double dy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_affine_relative</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, const double affine[6]
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_affine_absolute</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, const double affine[6]
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_scale</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item,double x, double y,double scale_x, double scale_y
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_rotate</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, double x, double y, double angle
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_raise</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, int positions
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_lower</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, int positions
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_raise_to_top</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_lower_to_bottom</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_show</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_hide</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_grab</NAME>
<RETURNS>int  </RETURNS>
GnomeCanvasItem *item, unsigned int event_mask,GdkCursor *cursor, guint32 etime
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_ungrab</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, guint32 etime
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_w2i</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, double *x, double *y
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_i2w</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, double *x, double *y
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_i2w_affine</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, double affine[6]
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_i2c_affine</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, double affine[6]
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_reparent</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item, GnomeCanvasGroup *new_group
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_grab_focus</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_get_bounds</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item,double *x1, double *y1, double *x2, double *y2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_item_request_update</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasItem *item
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS_GROUP</NAME>
#define GNOME_TYPE_CANVAS_GROUP            (gnome_canvas_group_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_GROUP</NAME>
#define GNOME_CANVAS_GROUP(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS_GROUP, GnomeCanvasGroup))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_GROUP_CLASS</NAME>
#define GNOME_CANVAS_GROUP_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS_GROUP, GnomeCanvasGroupClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_GROUP</NAME>
#define GNOME_IS_CANVAS_GROUP(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS_GROUP))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_GROUP_CLASS</NAME>
#define GNOME_IS_CANVAS_GROUP_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS_GROUP))
</MACRO>
<STRUCT>
<NAME>GnomeCanvasGroup</NAME>
struct GnomeCanvasGroup {
	GnomeCanvasItem item;

	/* Children of the group */
	GList *item_list;
	GList *item_list_end;

	/* The position of the group has been subsumed into the xform of all items */
#ifdef OLD_XFORM
	double xpos, ypos;	/* Point that defines the group's origin */
#endif
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_group_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_group_child_bounds</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvasGroup *group, GnomeCanvasItem *item
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_CANVAS</NAME>
#define GNOME_TYPE_CANVAS            (gnome_canvas_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS</NAME>
#define GNOME_CANVAS(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_CANVAS, GnomeCanvas))
</MACRO>
<MACRO>
<NAME>GNOME_CANVAS_CLASS</NAME>
#define GNOME_CANVAS_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_CANVAS, GnomeCanvasClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS</NAME>
#define GNOME_IS_CANVAS(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_CANVAS))
</MACRO>
<MACRO>
<NAME>GNOME_IS_CANVAS_CLASS</NAME>
#define GNOME_IS_CANVAS_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_CANVAS))
</MACRO>
<STRUCT>
<NAME>GnomeCanvas</NAME>
struct GnomeCanvas {
	GtkLayout layout;

	/* Idle handler ID */
	guint idle_id;

	/* Root canvas group */
	GnomeCanvasItem *root;

	/* Signal handler ID for destruction of the root item */
	guint root_destroy_id;

	/* Scrolling region */
	double scroll_x1, scroll_y1;
	double scroll_x2, scroll_y2;

	/* Scaling factor to be used for display */
	double pixels_per_unit;

	/* Area that is being redrawn.  Contains (x1, y1) but not (x2, y2).
	 * Specified in canvas pixel coordinates.
	 */
	int redraw_x1, redraw_y1;
	int redraw_x2, redraw_y2;

	/* Area that needs redrawing, stored as a microtile array */
	ArtUta *redraw_area;

	/* Offsets of the temprary drawing pixmap */
	int draw_xofs, draw_yofs;

	/* Internal pixel offsets when zoomed out */
	int zoom_xofs, zoom_yofs;

	/* Last known modifier state, for deferred repick when a button is down */
	int state;

	/* The item containing the mouse pointer, or NULL if none */
	GnomeCanvasItem *current_item;

	/* Item that is about to become current (used to track deletions and such) */
	GnomeCanvasItem *new_current_item;

	/* Item that holds a pointer grab, or NULL if none */
	GnomeCanvasItem *grabbed_item;

	/* Event mask specified when grabbing an item */
	guint grabbed_event_mask;

	/* If non-NULL, the currently focused item */
	GnomeCanvasItem *focused_item;

	/* Event on which selection of current item is based */
	GdkEvent pick_event;

	/* Tolerance distance for picking items */
	int close_enough;

	/* Color context used for color allocation */
	GdkColorContext *cc;

	/* GC for temporary draw pixmap */
	GdkGC *pixmap_gc;

	/* Whether items need update at next idle loop iteration */
	unsigned int need_update : 1;

	/* Whether the canvas needs redrawing at the next idle loop iteration */
	unsigned int need_redraw : 1;

	/* Whether current item will be repicked at next idle loop iteration */
	unsigned int need_repick : 1;

	/* For use by internal pick_current_item() function */
	unsigned int left_grabbed_item : 1;

	/* For use by internal pick_current_item() function */
	unsigned int in_repick : 1;

	/* Whether the canvas is in antialiased mode or not */
	unsigned int aa : 1;

	/* dither mode for aa drawing */
	unsigned int dither : 2;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_canvas_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_new_aa</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_root</NAME>
<RETURNS>GnomeCanvasGroup  *</RETURNS>
GnomeCanvas *canvas
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_set_scroll_region</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas,double x1, double y1, double x2, double y2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_scroll_region</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas,double *x1, double *y1, double *x2, double *y2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_set_pixels_per_unit</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, double n
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_scroll_to</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, int cx, int cy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_scroll_offsets</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, int *cx, int *cy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_update_now</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_item_at</NAME>
<RETURNS>GnomeCanvasItem  *</RETURNS>
GnomeCanvas *canvas, double x, double y
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_request_redraw_uta</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, ArtUta *uta
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_request_redraw</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, int x1, int y1, int x2, int y2
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_w2c_affine</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, double affine[6]
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_w2c</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, double wx, double wy, int *cx, int *cy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_w2c_d</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, double wx, double wy, double *cx, double *cy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_c2w</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, int cx, int cy, double *wx, double *wy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_window_to_world</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas,double winx, double winy, double *worldx, double *worldy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_world_to_window</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas,double worldx, double worldy, double *winx, double *winy
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_color</NAME>
<RETURNS>int  </RETURNS>
GnomeCanvas *canvas, char *spec, GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_color_pixel</NAME>
<RETURNS>gulong  </RETURNS>
GnomeCanvas *canvas,guint        rgba
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_set_stipple_origin</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, GdkGC *gc
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_set_dither</NAME>
<RETURNS>void  </RETURNS>
GnomeCanvas *canvas, GdkRgbDither dither
</FUNCTION>
<FUNCTION>
<NAME>gnome_canvas_get_dither</NAME>
<RETURNS>GdkRgbDither  </RETURNS>
GnomeCanvas *canvas
</FUNCTION>
<MACRO>
<NAME>GNOME_CLIENT</NAME>
#define GNOME_CLIENT(obj)           GTK_CHECK_CAST (obj, gnome_client_get_type (), GnomeClient)
</MACRO>
<MACRO>
<NAME>GNOME_CLIENT_CLASS</NAME>
#define GNOME_CLIENT_CLASS(klass)   GTK_CHECK_CLASS_CAST (klass, gnome_client_get_type (), GnomeClientClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_CLIENT</NAME>
#define GNOME_IS_CLIENT(obj)        GTK_CHECK_TYPE (obj, gnome_client_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_CLIENT_CONNECTED</NAME>
#define GNOME_CLIENT_CONNECTED(obj) (GNOME_CLIENT (obj)->smc_conn)
</MACRO>
<STRUCT>
<NAME>GnomeClient</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeClientClass</NAME>
</STRUCT>
<ENUM>
<NAME>GnomeInteractStyle</NAME>
typedef enum
{
  GNOME_INTERACT_NONE,
  GNOME_INTERACT_ERRORS,
  GNOME_INTERACT_ANY
} GnomeInteractStyle;
</ENUM>
<ENUM>
<NAME>GnomeDialogType</NAME>
typedef enum
{
  GNOME_DIALOG_ERROR,
  GNOME_DIALOG_NORMAL
} GnomeDialogType;
</ENUM>
<ENUM>
<NAME>GnomeSaveStyle</NAME>
typedef enum
{
  GNOME_SAVE_GLOBAL,
  GNOME_SAVE_LOCAL,
  GNOME_SAVE_BOTH
} GnomeSaveStyle;
</ENUM>
<ENUM>
<NAME>GnomeRestartStyle</NAME>
typedef enum
{
  GNOME_RESTART_IF_RUNNING,
  GNOME_RESTART_ANYWAY,
  GNOME_RESTART_IMMEDIATELY,
  GNOME_RESTART_NEVER
} GnomeRestartStyle;
</ENUM>
<ENUM>
<NAME>GnomeClientState</NAME>
typedef enum
{
  GNOME_CLIENT_IDLE,
  GNOME_CLIENT_SAVING_PHASE_1,
  GNOME_CLIENT_WAITING_FOR_PHASE_2,
  GNOME_CLIENT_SAVING_PHASE_2,
  GNOME_CLIENT_FROZEN,
  GNOME_CLIENT_DISCONNECTED,
  GNOME_CLIENT_REGISTERING
} GnomeClientState;
</ENUM>
<ENUM>
<NAME>GnomeClientFlags</NAME>
typedef enum
{
  GNOME_CLIENT_IS_CONNECTED= 1 << 0,
  GNOME_CLIENT_RESTARTED   = 1 << 1,
  GNOME_CLIENT_RESTORED    = 1 << 2
} GnomeClientFlags;
</ENUM>
<USER_FUNCTION>
<NAME>GnomeInteractFunction</NAME>
<RETURNS>void </RETURNS>
GnomeClient     *client,
				       gint             key,
				       GnomeDialogType  dialog_type,
				       gpointer         data
</USER_FUNCTION>
<STRUCT>
<NAME>GnomeClient</NAME>
struct GnomeClient
{
  GtkObject           object;

  /* general information about the connection to the session manager */
  gpointer            smc_conn;
  gint                input_id;

  /* client id of this client */
  gchar              *client_id;

  /* Previous client id of this client.  */
  gchar		     *previous_id;

  /* Prefix for per save configuration files.  */
  gchar              *config_prefix;

  /* Prefix for app configuration files.  */
  gchar              *global_config_prefix;

  /* Static command line options.  */
  GList              *static_args;

  /* The following properties are predefined in the X session
     management protocol.  The entries marked with a 'x' are required
     by the session management protocol.  The entries marked with a
     's' are set automatically when creating a new gnome client.  */
  gchar             **clone_command;        /*[xs]*/
  gchar              *current_directory;    /*[  ]*/
  gchar             **discard_command;      /*[  ]*/
  GHashTable         *environment;          /*[  ]*/
  pid_t               process_id;           /*[ s]*/
  gchar              *program;              /*[xs]*/
  gchar             **resign_command;       /*[  ]*/
  gchar             **restart_command;      /*[xs]*/
  GnomeRestartStyle   restart_style;        /*[  ]*/
  gchar             **shutdown_command;     /*[  ]*/
  gchar              *user_id;              /*[xs]*/

  /* values sent with the last SaveYourself message */
  GnomeSaveStyle      save_style;
  GnomeInteractStyle  interact_style;
  gboolean            shutdown;
  gboolean            fast;

  /* other internal state information */
  GnomeClientState    state;
  gboolean            save_phase_2_requested;
  gboolean            save_successfull;
  gboolean            save_yourself_emitted;

  GSList             *interaction_keys;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_client_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_master_client</NAME>
<RETURNS>GnomeClient  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_get_config_prefix</NAME>
<RETURNS>gchar *</RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_get_global_config_prefix</NAME>
<RETURNS>gchar *</RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_global_config_prefix</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,gchar* prefix
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_get_flags</NAME>
<RETURNS>GnomeClientFlags  </RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_restart_style</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,GnomeRestartStyle style
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_priority</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,guint priority
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_restart_command</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,gint argc, gchar *argv[]
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_add_static_arg</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client, ...
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_discard_command</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,gint argc, gchar *argv[]
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_resign_command</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,gint argc, gchar *argv[]
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_shutdown_command</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,gint argc, gchar *argv[]
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_current_directory</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,const gchar *dir
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_environment</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,const gchar *name,const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_clone_command</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,gint argc, gchar *argv[]
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_process_id</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,pid_t pid
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_program</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,const gchar *program
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_user_id</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,const gchar *user_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_save_any_dialog</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,GnomeDialog *dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_save_error_dialog</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,GnomeDialog *dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_request_phase_2</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_request_save</NAME>
<RETURNS>void 	</RETURNS>
GnomeClient	       *client,GnomeSaveStyle		save_style,gboolean		shutdown,GnomeInteractStyle	interact_style,gboolean		fast,gboolean		global
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_flush</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_disable_master_connection</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_new</NAME>
<RETURNS>GnomeClient  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_new_without_connection</NAME>
<RETURNS>GnomeClient  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_connect</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_disconnect</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_set_id</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,const gchar *client_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_get_id</NAME>
<RETURNS>gchar *</RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_get_previous_id</NAME>
<RETURNS>gchar *</RETURNS>
GnomeClient *client
</FUNCTION>
<FUNCTION>
<NAME>gnome_cloned_client</NAME>
<RETURNS>GnomeClient  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_request_interaction</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,GnomeDialogType dialog,GnomeInteractFunction func,gpointer client_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_client_request_interaction_interp</NAME>
<RETURNS>void  </RETURNS>
GnomeClient *client,GnomeDialogType dialog,GtkCallbackMarshal func,gpointer data,GtkDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gnome_interaction_key_return</NAME>
<RETURNS>void  </RETURNS>
gint     key,gboolean cancel_shutdown
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_COLOR_PICKER</NAME>
#define GNOME_TYPE_COLOR_PICKER            (gnome_color_picker_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_COLOR_PICKER</NAME>
#define GNOME_COLOR_PICKER(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_COLOR_PICKER, GnomeColorPicker))
</MACRO>
<MACRO>
<NAME>GNOME_COLOR_PICKER_CLASS</NAME>
#define GNOME_COLOR_PICKER_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_COLOR_PICKER, GnomeColorPickerClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_COLOR_PICKER</NAME>
#define GNOME_IS_COLOR_PICKER(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_COLOR_PICKER))
</MACRO>
<MACRO>
<NAME>GNOME_IS_COLOR_PICKER_CLASS</NAME>
#define GNOME_IS_COLOR_PICKER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_COLOR_PICKER))
</MACRO>
<STRUCT>
<NAME>GnomeColorPicker</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeColorPickerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeColorPicker</NAME>
struct GnomeColorPicker {
	GtkButton button;

	gdouble r, g, b, a;	/* Red, green, blue, and alpha values */

	GdkImlibImage *im;	/* Imlib image for rendering dithered sample */
	GdkPixmap *pixmap;	/* Pixmap with the sample contents */
	GdkGC *gc;		/* GC for drawing */

	GtkWidget *da;		/* Drawing area for color sample */
	GtkWidget *cs_dialog;	/* Color selection dialog */

	gchar *title;		/* Title for the color selection window */

	guint dither : 1;	/* Dither or just paint a solid color? */
	guint use_alpha : 1;	/* Use alpha or not */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_color_picker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_set_d</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, gdouble r, gdouble g, gdouble b, gdouble a
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_get_d</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, gdouble *r, gdouble *g, gdouble *b, gdouble *a
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_set_i8</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, guint8 r, guint8 g, guint8 b, guint8 a
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_get_i8</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, guint8 *r, guint8 *g, guint8 *b, guint8 *a
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_set_i16</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, gushort r, gushort g, gushort b, gushort a
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_get_i16</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, gushort *r, gushort *g, gushort *b, gushort *a
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_set_dither</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, gboolean dither
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_set_use_alpha</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, gboolean use_alpha
</FUNCTION>
<FUNCTION>
<NAME>gnome_color_picker_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeColorPicker *cp, const gchar *title
</FUNCTION>
<MACRO>
<NAME>GNOME_IS_MDI_MDI_CHILD</NAME>
#  define GNOME_IS_MDI_MDI_CHILD(obj)     GNOME_IS_MDI_GENERIC_CHILD(obj)
</MACRO>
<ENUM>
<NAME>GnomeDateEditFlags</NAME>
typedef enum {
	GNOME_DATE_EDIT_SHOW_TIME             = 1 << 0,
	GNOME_DATE_EDIT_24_HR                 = 1 << 1,
	GNOME_DATE_EDIT_WEEK_STARTS_ON_MONDAY = 1 << 2
} GnomeDateEditFlags;
</ENUM>
<MACRO>
<NAME>GNOME_DATE_EDIT</NAME>
#define GNOME_DATE_EDIT(obj)          GTK_CHECK_CAST (obj, gnome_date_edit_get_type(), GnomeDateEdit)
</MACRO>
<MACRO>
<NAME>GNOME_DATE_EDIT_CLASS</NAME>
#define GNOME_DATE_EDIT_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_date_edit_get_type(), GnomeDateEditClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DATE_EDIT</NAME>
#define GNOME_IS_DATE_EDIT(obj)       GTK_CHECK_TYPE (obj, gnome_date_edit_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeDateEdit</NAME>
typedef struct {
	GtkHBox hbox;

	GtkWidget *date_entry;
	GtkWidget *date_button;
	
	GtkWidget *time_entry;
	GtkWidget *time_popup;

	GtkWidget *cal_label;
	GtkWidget *cal_popup;
	GtkWidget *calendar;

	int       lower_hour;
	int       upper_hour;
	
	time_t    initial_time;
	int       flags;
} GnomeDateEdit;
</STRUCT>
<FUNCTION>
<NAME>gnome_date_edit_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
time_t the_time, int show_time, int use_24_format
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_new_flags</NAME>
<RETURNS>GtkWidget  *</RETURNS>
time_t the_time, GnomeDateEditFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_set_time</NAME>
<RETURNS>void  </RETURNS>
GnomeDateEdit *gde, time_t the_time
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_set_popup_range</NAME>
<RETURNS>void  </RETURNS>
GnomeDateEdit *gde, int low_hour, int up_hour
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_get_date</NAME>
<RETURNS>time_t  </RETURNS>
GnomeDateEdit *gde
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_set_flags</NAME>
<RETURNS>void  </RETURNS>
GnomeDateEdit *gde, GnomeDateEditFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gnome_date_edit_get_flags</NAME>
<RETURNS>int  </RETURNS>
GnomeDateEdit *gde
</FUNCTION>
<STRUCT>
<NAME>GnomeDEntryEdit</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDEntryEditClass</NAME>
</STRUCT>
<MACRO>
<NAME>GNOME_DENTRY_EDIT</NAME>
#define GNOME_DENTRY_EDIT(obj)          GTK_CHECK_CAST (obj, gnome_dentry_edit_get_type (), GnomeDEntryEdit)
</MACRO>
<MACRO>
<NAME>GNOME_DENTRY_EDIT_CLASS</NAME>
#define GNOME_DENTRY_EDIT_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_dentry_edit_get_type (), GnomeDEntryEditClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DENTRY_EDIT</NAME>
#define GNOME_IS_DENTRY_EDIT(obj)       GTK_CHECK_TYPE (obj, gnome_dentry_edit_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeDEntryEdit</NAME>
struct GnomeDEntryEdit {
  GtkObject object;
  
  /*semi public entries, you should however use macros to get these*/
  GtkWidget *child1;
  GtkWidget *child2;
  
  /* Remaining fields are private - if you need them, 
     please add an accessor function. */

  GtkWidget *name_entry;
  GtkWidget *comment_entry;
  GtkWidget *exec_entry;
  GtkWidget *tryexec_entry;
  GtkWidget *doc_entry;

  GtkWidget *type_combo;

  GtkWidget *terminal_button;  

  GtkWidget *icon_entry;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_dentry_edit_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_edit_new</NAME>
<RETURNS>GtkObject  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>gnome_dentry_edit_child1</NAME>
#define gnome_dentry_edit_child1(d) (GNOME_DENTRY_EDIT(d)->child1)
</MACRO>
<MACRO>
<NAME>gnome_dentry_edit_child2</NAME>
#define gnome_dentry_edit_child2(d) (GNOME_DENTRY_EDIT(d)->child2)
</MACRO>
<FUNCTION>
<NAME>gnome_dentry_edit_new_notebook</NAME>
<RETURNS>GtkObject  *</RETURNS>
GtkNotebook * notebook
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_edit_clear</NAME>
<RETURNS>void  </RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_edit_load_file</NAME>
<RETURNS>void  </RETURNS>
GnomeDEntryEdit * dee,const gchar * path
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_edit_set_dentry</NAME>
<RETURNS>void  </RETURNS>
GnomeDEntryEdit * dee,GnomeDesktopEntry * dentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_dentry</NAME>
<RETURNS>GnomeDesktopEntry  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_edit_get_icon</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_edit_get_name</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_name_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_comment_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_exec_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_tryexec_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_doc_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_dentry_get_icon_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeDEntryEdit * dee
</FUNCTION>
<FUNCTION>
<NAME>gnome_ok_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * message
</FUNCTION>
<FUNCTION>
<NAME>gnome_ok_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * message,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_error_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * error
</FUNCTION>
<FUNCTION>
<NAME>gnome_error_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * error,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_warning_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * warning
</FUNCTION>
<FUNCTION>
<NAME>gnome_warning_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * warning,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_question_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * question,GnomeReplyCallback callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_question_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * question,GnomeReplyCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_question_dialog_modal</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * question,GnomeReplyCallback callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_question_dialog_modal_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * question,GnomeReplyCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_ok_cancel_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * message,GnomeReplyCallback callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_ok_cancel_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * message,GnomeReplyCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_ok_cancel_dialog_modal</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * message,GnomeReplyCallback callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_ok_cancel_dialog_modal_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * message,GnomeReplyCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_request_string_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * prompt,GnomeStringCallback callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_request_string_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * prompt,GnomeStringCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_request_password_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * prompt,GnomeStringCallback callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_request_password_dialog_parented</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * prompt,GnomeStringCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_request_dialog</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gboolean password,const gchar * prompt,const gchar * default_text,const guint16 max_length,GnomeStringCallback callback,gpointer data,GtkWindow * parent
</FUNCTION>
<MACRO>
<NAME>GNOME_DIALOG</NAME>
#define GNOME_DIALOG(obj)        GTK_CHECK_CAST (obj, gnome_dialog_get_type (), GnomeDialog)
</MACRO>
<MACRO>
<NAME>GNOME_DIALOG_CLASS</NAME>
#define GNOME_DIALOG_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_dialog_get_type (), GnomeDialogClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DIALOG</NAME>
#define GNOME_IS_DIALOG(obj)       GTK_CHECK_TYPE (obj, gnome_dialog_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeDialog</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDialogClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDialog</NAME>
struct GnomeDialog
{
  GtkWindow window;
  GtkWidget * vbox;

  GtkWidget * action_area; /* A button box, not an hbox */

  GList *buttons;
  GtkAccelGroup * accelerators;

  unsigned int click_closes : 1;
  unsigned int just_hide : 1;

  gpointer padding;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_dialog_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar * title,...
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_newv</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar * title,const gchar **buttons
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_set_parent</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,GtkWindow   * parent
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_button_connect</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog *dialog,gint button,GtkSignalFunc callback,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_button_connect_object</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog *dialog,gint button,GtkSignalFunc callback,GtkObject * obj
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_run</NAME>
<RETURNS>gint  </RETURNS>
GnomeDialog *dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_run_and_close</NAME>
<RETURNS>gint  </RETURNS>
GnomeDialog *dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_set_default</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog *dialog,gint         button
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_set_sensitive</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog *dialog,gint         button,gboolean     setting
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_set_accelerator</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,gint button,const guchar accelerator_key,guint8       accelerator_mods
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_close</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_close_hides</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,gboolean just_hide
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_set_close</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,gboolean click_closes
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_editable_enters</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,GtkEditable * editable
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_append_buttons</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar * first,...
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_append_button</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_append_buttonsv</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar **buttons
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_append_button_with_pixmap</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar * name,const gchar * pixmap
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_append_buttons_with_pixmaps</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar **names,const gchar **pixmaps
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_construct</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar * title,va_list ap
</FUNCTION>
<FUNCTION>
<NAME>gnome_dialog_constructv</NAME>
<RETURNS>void  </RETURNS>
GnomeDialog * dialog,const gchar * title,const gchar **buttons
</FUNCTION>
<FUNCTION>
<NAME>gnome_dns_init</NAME>
<RETURNS>void  </RETURNS>
gint server_count
</FUNCTION>
<FUNCTION>
<NAME>gnome_dns_lookup</NAME>
<RETURNS>guint32  </RETURNS>
const char *hostname,void (* callback) (guint32 ip_addr, void *callback_data),void *callback_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_dns_abort</NAME>
<RETURNS>void  </RETURNS>
guint32 tag
</FUNCTION>
<MACRO>
<NAME>GNOME_DOCK_BAND</NAME>
#define GNOME_DOCK_BAND(obj) \
  GTK_CHECK_CAST (obj, gnome_dock_band_get_type (), GnomeDockBand)
</MACRO>
<MACRO>
<NAME>GNOME_DOCK_BAND_CLASS</NAME>
#define GNOME_DOCK_BAND_CLASS(class) \
  GTK_CHECK_CLASS_CAST (class, gnome_dock_band_get_type (), GnomeDockBandClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DOCK_BAND</NAME>
#define GNOME_IS_DOCK_BAND(obj) \
  GTK_CHECK_TYPE (obj, gnome_dock_band_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeDockBand</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockBandClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockBandChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockBand</NAME>
struct GnomeDockBand
{
  GtkContainer container;

  GtkOrientation orientation;

  GList *children;              /* GnomeDockBandChild */
  guint num_children;

  GList *floating_child;        /* GnomeDockBandChild */

  gboolean doing_drag;

  guint max_space_requisition;
  guint tot_offsets;

  /* This used to remember the allocation before the drag begin: it is
     necessary to do so because we actually decide what docking action
     happens depending on it, instead of using the current allocation
     (which might be constantly changing while the user drags things
     around).  */
  GtkAllocation drag_allocation;

  guint new_for_drag : 1;
};
</STRUCT>
<STRUCT>
<NAME>GnomeDockBandChild</NAME>
struct GnomeDockBandChild
{
  GtkWidget *widget;

  /* Maximum (requested) offset from the previous child.  */
  guint offset;

  /* Actual offset.  */
  guint real_offset;

  guint drag_offset;

  GtkAllocation drag_allocation;

  guint prev_space, foll_space;
  guint drag_prev_space, drag_foll_space;

  guint max_space_requisition;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_dock_band_new</NAME>
<RETURNS>GtkWidget      *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_set_orientation</NAME>
<RETURNS>void  </RETURNS>
GnomeDockBand *band,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
GnomeDockBand *band
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_insert</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockBand *band,GtkWidget *child,guint offset,gint position
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_prepend</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockBand *band,GtkWidget *child,guint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_append</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockBand *band,GtkWidget *child,guint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_set_child_offset</NAME>
<RETURNS>void  </RETURNS>
GnomeDockBand *band,GtkWidget *child,guint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_get_child_offset</NAME>
<RETURNS>guint  </RETURNS>
GnomeDockBand *band,GtkWidget *child
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_move_child</NAME>
<RETURNS>void  </RETURNS>
GnomeDockBand *band,GList *old_child,guint new_num
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_get_num_children</NAME>
<RETURNS>guint  </RETURNS>
GnomeDockBand *band
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_drag_begin</NAME>
<RETURNS>void  </RETURNS>
GnomeDockBand *band,GnomeDockItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_drag_to</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockBand *band,GnomeDockItem *item,gint x, gint y
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_drag_end</NAME>
<RETURNS>void  </RETURNS>
GnomeDockBand *band,GnomeDockItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_get_item_by_name</NAME>
<RETURNS>GnomeDockItem  *</RETURNS>
GnomeDockBand *band,const char *name,guint *position_return,guint *offset_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_band_layout_add</NAME>
<RETURNS>void  </RETURNS>
GnomeDockBand *band,GnomeDockLayout *layout,GnomeDockPlacement placement,guint band_num
</FUNCTION>
<MACRO>
<NAME>GNOME_DOCK_ITEM</NAME>
#define GNOME_DOCK_ITEM(obj) \
  GTK_CHECK_CAST (obj, gnome_dock_item_get_type (), GnomeDockItem)
</MACRO>
<MACRO>
<NAME>GNOME_DOCK_ITEM_CLASS</NAME>
#define GNOME_DOCK_ITEM_CLASS(klass) \
  GTK_CHECK_CLASS_CAST (klass, gnome_dock_item_get_type (), GnomeDockItemClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DOCK_ITEM</NAME>
#define GNOME_IS_DOCK_ITEM(obj) \
  GTK_CHECK_TYPE (obj, gnome_dock_item_get_type ())
</MACRO>
<ENUM>
<NAME>GnomeDockItemBehavior</NAME>
typedef enum
{
  GNOME_DOCK_ITEM_BEH_NORMAL = 0,
  GNOME_DOCK_ITEM_BEH_EXCLUSIVE = 1 << 0,
  GNOME_DOCK_ITEM_BEH_NEVER_FLOATING = 1 << 1,
  GNOME_DOCK_ITEM_BEH_NEVER_VERTICAL = 1 << 2,
  GNOME_DOCK_ITEM_BEH_NEVER_HORIZONTAL = 1 << 3,
  GNOME_DOCK_ITEM_BEH_LOCKED = 1 << 4
} GnomeDockItemBehavior;
</ENUM>
<MACRO>
<NAME>GNOME_DOCK_ITEM_BEH_NEVER_DETACH</NAME>
#define GNOME_DOCK_ITEM_BEH_NEVER_DETACH GNOME_DOCK_ITEM_BEH_NEVER_FLOATING
</MACRO>
<MACRO>
<NAME>GNOME_DOCK_ITEM_NOT_LOCKED</NAME>
#define GNOME_DOCK_ITEM_NOT_LOCKED(x) (! (GNOME_DOCK_ITEM(x)->behavior \
                                          & GNOME_DOCK_ITEM_BEH_LOCKED))
</MACRO>
<STRUCT>
<NAME>GnomeDockItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockItem</NAME>
struct GnomeDockItem
{
  GtkBin bin;

  gchar                *name;

  GdkWindow            *bin_window; /* parent window for children */
  GdkWindow            *float_window;
  GtkShadowType         shadow_type;

  GtkOrientation        orientation;
  GnomeDockItemBehavior behavior;

  guint                 float_window_mapped : 1;
  guint                 is_floating : 1;
  guint                 in_drag : 1;

  /* Start drag position (wrt widget->window).  */
  gint                  dragoff_x, dragoff_y;

  /* Position of the floating window.  */
  gint                  float_x, float_y;

  /* If TRUE, the pointer must be grabbed on "map_event".  */
  guint                 grab_on_map_event;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_dock_item_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_new</NAME>
<RETURNS>GtkWidget      *</RETURNS>
const gchar *name,GnomeDockItemBehavior behavior
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_get_child</NAME>
<RETURNS>GtkWidget      *</RETURNS>
GnomeDockItem *dock_item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_get_name</NAME>
<RETURNS>char           *</RETURNS>
GnomeDockItem *dock_item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_set_shadow_type</NAME>
<RETURNS>void  </RETURNS>
GnomeDockItem *dock_item,GtkShadowType type
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_get_shadow_type</NAME>
<RETURNS>GtkShadowType  </RETURNS>
GnomeDockItem *dock_item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_set_orientation</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockItem *dock_item,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_get_orientation</NAME>
<RETURNS>GtkOrientation  </RETURNS>
GnomeDockItem *dock_item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_get_behavior</NAME>
<RETURNS>GnomeDockItemBehavior</RETURNS>
GnomeDockItem *dock_item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_detach</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockItem *item,gint x, gint y
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_attach</NAME>
<RETURNS>void  </RETURNS>
GnomeDockItem *item,GtkWidget *parent,gint x, gint y
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_grab_pointer</NAME>
<RETURNS>void  </RETURNS>
GnomeDockItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_drag_floating</NAME>
<RETURNS>void  </RETURNS>
GnomeDockItem *item,gint x, gint y
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_handle_size_request</NAME>
<RETURNS>void  </RETURNS>
GnomeDockItem *item,GtkRequisition *requisition
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_item_get_floating_position</NAME>
<RETURNS>void  </RETURNS>
GnomeDockItem *item,gint *x, gint *y
</FUNCTION>
<MACRO>
<NAME>GNOME_DOCK_LAYOUT</NAME>
#define GNOME_DOCK_LAYOUT(obj) \
  GTK_CHECK_CAST (obj, gnome_dock_layout_get_type (), GnomeDockLayout)
</MACRO>
<MACRO>
<NAME>GNOME_DOCK_LAYOUT_CLASS</NAME>
#define GNOME_DOCK_LAYOUT_CLASS(klass) \
  GTK_CHECK_CLASS_CAST (klass, gnome_dock_layout_get_type (), GnomeDockLayoutClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DOCK_LAYOUT</NAME>
#define GNOME_IS_DOCK_LAYOUT(obj) \
  GTK_CHECK_TYPE (obj, gnome_dock_layout_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeDockLayoutItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockLayoutClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockLayout</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockLayoutItem</NAME>
struct GnomeDockLayoutItem
{
  GnomeDockItem *item;

  GnomeDockPlacement placement;

  union
  {
    struct
    {
      gint x;
      gint y;
      GtkOrientation orientation;
    } floating;

    struct
    {
      gint band_num;
      gint band_position;
      gint offset;
    } docked;

  } position;
};
</STRUCT>
<STRUCT>
<NAME>GnomeDockLayout</NAME>
struct GnomeDockLayout
{
  GtkObject object;

  GList *items;                 /* GnomeDockLayoutItem */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_dock_layout_new</NAME>
<RETURNS>GnomeDockLayout      *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_add_item</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockLayout *layout,GnomeDockItem *item,GnomeDockPlacement placement,gint band_num,gint band_position,gint offset
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_add_floating_item</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockLayout *layout,GnomeDockItem *item,gint x, gint y,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_get_item</NAME>
<RETURNS>GnomeDockLayoutItem  *</RETURNS>
GnomeDockLayout *layout,GnomeDockItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_get_item_by_name</NAME>
<RETURNS>GnomeDockLayoutItem  *</RETURNS>
GnomeDockLayout *layout,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_remove_item</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockLayout *layout,GnomeDockItem *item
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_remove_item_by_name</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockLayout *layout,const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_create_string</NAME>
<RETURNS>gchar                *</RETURNS>
GnomeDockLayout *layout
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_parse_string</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockLayout *layout,const gchar *string
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_layout_add_to_dock</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDockLayout *layout,GnomeDock *dock
</FUNCTION>
<MACRO>
<NAME>GNOME_DOCK</NAME>
#define GNOME_DOCK(obj) \
  GTK_CHECK_CAST (obj, gnome_dock_get_type (), GnomeDock)
</MACRO>
<MACRO>
<NAME>GNOME_DOCK_CLASS</NAME>
#define GNOME_DOCK_CLASS(klass) \
  GTK_CHECK_CLASS_CAST (klass, gnome_dock_get_type (), GnomeDockClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_DOCK</NAME>
#define GNOME_IS_DOCK(obj) \
  GTK_CHECK_TYPE (obj, gnome_dock_get_type ())
</MACRO>
<ENUM>
<NAME>GnomeDockPlacement</NAME>
typedef enum
{
  GNOME_DOCK_TOP,
  GNOME_DOCK_RIGHT,
  GNOME_DOCK_BOTTOM,
  GNOME_DOCK_LEFT,
  GNOME_DOCK_FLOATING
} GnomeDockPlacement;
</ENUM>
<STRUCT>
<NAME>GnomeDock</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDockClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDock</NAME>
struct GnomeDock
{
  GtkContainer container;

  GtkWidget *client_area;

  /* GnomeDockBands associated with this dock.  */
  GList *top_bands;
  GList *bottom_bands;
  GList *right_bands;
  GList *left_bands;

  /* Children that are currently not docked.  */
  GList *floating_children;     /* GtkWidget */

  /* Client rectangle before drag.  */
  GtkAllocation client_rect;

  gboolean floating_items_allowed : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_dock_new</NAME>
<RETURNS>GtkWidget      *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_allow_floating_items</NAME>
<RETURNS>void  </RETURNS>
GnomeDock *dock,gboolean enable
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_add_item</NAME>
<RETURNS>void  </RETURNS>
GnomeDock             *dock,GnomeDockItem         *item,GnomeDockPlacement  placement,guint                  band_num,gint                   position,guint                  offset,gboolean               in_new_band
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_add_floating_item</NAME>
<RETURNS>void  </RETURNS>
GnomeDock *dock,GnomeDockItem *widget,gint x, gint y,GtkOrientation orientation
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_set_client_area</NAME>
<RETURNS>void  </RETURNS>
GnomeDock             *dock,GtkWidget             *widget
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_get_client_area</NAME>
<RETURNS>GtkWidget      *</RETURNS>
GnomeDock             *dock
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_get_item_by_name</NAME>
<RETURNS>GnomeDockItem  *</RETURNS>
GnomeDock *dock,const gchar *name,GnomeDockPlacement *placement_return,guint *num_band_return,guint *band_position_return,guint *offset_return
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_get_layout</NAME>
<RETURNS>GnomeDockLayout  *</RETURNS>
GnomeDock *dock
</FUNCTION>
<FUNCTION>
<NAME>gnome_dock_add_from_layout</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDock *dock,GnomeDockLayout *layout
</FUNCTION>
<MACRO>
<NAME>GNOME_ENTRY</NAME>
#define GNOME_ENTRY(obj)         GTK_CHECK_CAST (obj, gnome_entry_get_type (), GnomeEntry)
</MACRO>
<MACRO>
<NAME>GNOME_ENTRY_CLASS</NAME>
#define GNOME_ENTRY_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_entry_get_type (), GnomeEntryClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_ENTRY</NAME>
#define GNOME_IS_ENTRY(obj)      GTK_CHECK_TYPE (obj, gnome_entry_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeEntry</NAME>
struct GnomeEntry {
	GtkCombo combo;

	int    changed;
	char  *history_id;
	GList *items;
	guint  max_saved;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_entry_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar *history_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_gtk_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeEntry *gentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_set_history_id</NAME>
<RETURNS>void  </RETURNS>
GnomeEntry *gentry, const gchar *history_id
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_set_max_saved</NAME>
<RETURNS>void 	</RETURNS>
GnomeEntry *gentry, guint max_saved
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_prepend_history</NAME>
<RETURNS>void  </RETURNS>
GnomeEntry *gentry, gint save, const gchar *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_append_history</NAME>
<RETURNS>void  </RETURNS>
GnomeEntry *gentry, gint save, const gchar *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_load_history</NAME>
<RETURNS>void  </RETURNS>
GnomeEntry *gentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_entry_save_history</NAME>
<RETURNS>void  </RETURNS>
GnomeEntry *gentry
</FUNCTION>
<MACRO>
<NAME>GNOME_FILE_ENTRY</NAME>
#define GNOME_FILE_ENTRY(obj)         GTK_CHECK_CAST (obj, gnome_file_entry_get_type (), GnomeFileEntry)
</MACRO>
<MACRO>
<NAME>GNOME_FILE_ENTRY_CLASS</NAME>
#define GNOME_FILE_ENTRY_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_file_entry_get_type (), GnomeFileEntryClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_FILE_ENTRY</NAME>
#define GNOME_IS_FILE_ENTRY(obj)      GTK_CHECK_TYPE (obj, gnome_file_entry_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeFileEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeFileEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeFileEntry</NAME>
struct GnomeFileEntry {
	GtkHBox hbox;

	char *browse_dialog_title;
	char *default_path;
	
	/*the file dialog widget*/
	GtkWidget *fsw;
	
	int is_modal;
	
	int directory_entry; /*optional flag to only do directories*/

	GtkWidget *gentry;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_file_entry_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
char *history_id,char *browse_dialog_title
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_gnome_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeFileEntry *fentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_gtk_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeFileEntry *fentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeFileEntry *fentry,char *browse_dialog_title
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_set_default_path</NAME>
<RETURNS>void 	</RETURNS>
GnomeFileEntry *fentry,char *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_set_directory</NAME>
<RETURNS>void 	</RETURNS>
GnomeFileEntry *fentry,int directory_entry
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_get_full_path</NAME>
<RETURNS>char       *</RETURNS>
GnomeFileEntry *fentry,int file_must_exist
</FUNCTION>
<FUNCTION>
<NAME>gnome_file_entry_set_modal</NAME>
<RETURNS>void  </RETURNS>
GnomeFileEntry *fentry,int is_modal
</FUNCTION>
<ENUM>
<NAME>GnomeFontPickerMode</NAME>
typedef enum {
    GNOME_FONT_PICKER_MODE_PIXMAP,
    GNOME_FONT_PICKER_MODE_FONT_INFO,
    GNOME_FONT_PICKER_MODE_USER_WIDGET,
    GNOME_FONT_PICKER_MODE_UNKNOWN
} GnomeFontPickerMode;
</ENUM>
<MACRO>
<NAME>GNOME_TYPE_FONT_PICKER</NAME>
#define GNOME_TYPE_FONT_PICKER            (gnome_font_picker_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_FONT_PICKER</NAME>
#define GNOME_FONT_PICKER(obj)            (GTK_CHECK_CAST ((obj), GNOME_TYPE_FONT_PICKER, GnomeFontPicker))
</MACRO>
<MACRO>
<NAME>GNOME_FONT_PICKER_CLASS</NAME>
#define GNOME_FONT_PICKER_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_FONT_PICKER, GnomeFontPickerClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_FONT_PICKER</NAME>
#define GNOME_IS_FONT_PICKER(obj)         (GTK_CHECK_TYPE ((obj), GNOME_TYPE_FONT_PICKER))
</MACRO>
<MACRO>
<NAME>GNOME_IS_FONT_PICKER_CLASS</NAME>
#define GNOME_IS_FONT_PICKER_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GNOME_TYPE_FONT_PICKER))
</MACRO>
<STRUCT>
<NAME>GnomeFontPicker</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeFontPickerClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeFontPicker</NAME>
struct GnomeFontPicker {
        GtkButton button;
    
	GtkWidget     *font_dialog;
        GtkWidget     *inside;
        GtkWidget     *font_label,*vsep,*size_label;

        
        /* Do not change, use set/get functions */
        GnomeFontPickerMode mode;
        gchar         *font_name;
        gchar         *preview_text;
        /* Only for GNOME_FONT_PICKER_MODE_FONT_INFO */
        gboolean      use_font_in_label;
        gboolean      use_font_in_label_size;
        gboolean      show_size;

        gchar         *title;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_font_picker_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeFontPicker *gfp, const gchar *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_get_mode</NAME>
<RETURNS>GnomeFontPickerMode</RETURNS>
GnomeFontPicker *gfp
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_set_mode</NAME>
<RETURNS>void  </RETURNS>
GnomeFontPicker *gfp,GnomeFontPickerMode mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_fi_set_use_font_in_label</NAME>
<RETURNS>void  </RETURNS>
GnomeFontPicker *gfp,gboolean use_font_in_label,gint size
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_fi_set_show_size</NAME>
<RETURNS>void  </RETURNS>
GnomeFontPicker *gfp,gboolean show_size
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_uw_set_widget</NAME>
<RETURNS>void  </RETURNS>
GnomeFontPicker *gfp,GtkWidget       *widget
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_get_font_name</NAME>
<RETURNS>gchar *</RETURNS>
GnomeFontPicker *gfp
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_get_font</NAME>
<RETURNS>GdkFont *</RETURNS>
GnomeFontPicker *gfp
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_set_font_name</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeFontPicker *gfp,const gchar     *fontname
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_get_preview_text</NAME>
<RETURNS>gchar *</RETURNS>
GnomeFontPicker *gfp
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_picker_set_preview_text</NAME>
<RETURNS>void 	</RETURNS>
GnomeFontPicker *gfp,const gchar     *text
</FUNCTION>
<STRUCT>
<NAME>GnomeFontSelector</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeFontSelectorClass</NAME>
</STRUCT>
<MACRO>
<NAME>GNOME_FONT_SELECTOR</NAME>
#define GNOME_FONT_SELECTOR(obj) GTK_CHECK_CAST(obj, gnome_font_selector_get_type(), GnomeFontSelector)
</MACRO>
<MACRO>
<NAME>GNOME_FONT_SELECTOR_CLASS</NAME>
#define GNOME_FONT_SELECTOR_CLASS(klass) GTK_CHECK_CLASS_CAST(klass, gnome_font_selector_get_type(), GnomeFontSelectorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_FONT_SELECTOR</NAME>
#define GNOME_IS_FONT_SELECTOR(obj)      GTK_CHECK_TYPE(obj, gnome_font_selector_get_type())
</MACRO>
<STRUCT>
<NAME>FontInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeFontSelector</NAME>
struct GnomeFontSelector
{
  GtkDialog parent_object;

  GtkWidget *ok_button, *cancel_button;
  GtkWidget *main_vbox;
  GtkWidget *font_list;
  GtkWidget *size_menu;
  GtkWidget *size_text;
  GtkWidget *border_text;
  GtkWidget *text_frame;
  GtkWidget *the_text;
  GtkWidget *menus[5];
  GtkWidget *option_menus[5];
  GtkWidget **foundry_items;
  GtkWidget **weight_items;
  GtkWidget **slant_items;
  GtkWidget **set_width_items;
  GtkWidget **spacing_items;
  GtkWidget *antialias_toggle;
  GdkFont *font;
  gint font_index;
  gint size_type;
  gint foundry;
  gint weight;
  gint slant;
  gint set_width;
  gint spacing;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_font_selector_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_selector_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_selector_get_selected</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeFontSelector *text_tool
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_select</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_font_select_with_default</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *
</FUNCTION>
<FUNCTION>
<NAME>gnome_parse_geometry</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *geometry, gint *xpos, gint *ypos,gint *width, gint *height
</FUNCTION>
<FUNCTION>
<NAME>gnome_geometry_string</NAME>
<RETURNS>gchar  *</RETURNS>
GdkWindow * window
</FUNCTION>
<STRUCT>
<NAME>GnomeGuru</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeGuruClass</NAME>
</STRUCT>
<MACRO>
<NAME>GNOME_GURU</NAME>
#define GNOME_GURU(obj) GTK_CHECK_CAST (obj, gnome_guru_get_type (), GnomeGuru)
</MACRO>
<MACRO>
<NAME>GNOME_GURU_CLASS</NAME>
#define GNOME_GURU_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_guru_get_type (), GnomeGuruClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_GURU</NAME>
#define GNOME_IS_GURU(obj)  GTK_CHECK_TYPE (obj, gnome_guru_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeGuru</NAME>
struct GnomeGuru {
  GtkVBox vbox;

  /* all private, don't touch it. */

  GtkWidget * graphic;

  GList * pages;

  struct _GnomeGuruPage* current_page;

  GtkWidget * next;
  GtkWidget * back;
  GtkWidget * finish;
  GtkWidget * page_title;
  GtkWidget * page_box;
  GtkWidget * buttonbox;

  guint has_dialog : 1;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_guru_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_guru_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar * name,GtkWidget   * graphic,GnomeDialog * dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_guru_construct</NAME>
<RETURNS>void  </RETURNS>
GnomeGuru   * guru,const gchar * name,GtkWidget   * graphic,GnomeDialog * dialog
</FUNCTION>
<FUNCTION>
<NAME>gnome_guru_append_page</NAME>
<RETURNS>void  </RETURNS>
GnomeGuru   * guru,const gchar * name,GtkWidget   * widget
</FUNCTION>
<FUNCTION>
<NAME>gnome_guru_next_set_sensitive</NAME>
<RETURNS>void  </RETURNS>
GnomeGuru   * guru,gboolean      sensitivity
</FUNCTION>
<FUNCTION>
<NAME>gnome_guru_back_set_sensitive</NAME>
<RETURNS>void  </RETURNS>
GnomeGuru   * guru,gboolean      sensitivity
</FUNCTION>
<FUNCTION>
<NAME>gnome_guru_current_page</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeGuru   * guru
</FUNCTION>
<MACRO>
<NAME>GNOME_HREF</NAME>
#define GNOME_HREF(obj) GTK_CHECK_CAST(obj, gnome_href_get_type(), GnomeHRef)
</MACRO>
<MACRO>
<NAME>GNOME_HREF_CLASS</NAME>
#define GNOME_HREF_CLASS(klass) GTK_CHECK_CLASS_CAST(klass, gnome_href_get_type, GnomeHRefClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_HREF</NAME>
#define GNOME_IS_HREF(obj) GTK_CHECK_TYPE(obj, gnome_href_get_type())
</MACRO>
<STRUCT>
<NAME>GnomeHRef</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeHRefClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeHRef</NAME>
struct GnomeHRef {
  GtkButton button;

  gchar *url;
  GtkWidget *label;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_href_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_href_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const gchar *url, const gchar *label
</FUNCTION>
<FUNCTION>
<NAME>gnome_href_set_url</NAME>
<RETURNS>void  </RETURNS>
GnomeHRef *href, const gchar *url
</FUNCTION>
<FUNCTION>
<NAME>gnome_href_get_url</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeHRef *href
</FUNCTION>
<FUNCTION>
<NAME>gnome_href_set_label</NAME>
<RETURNS>void  </RETURNS>
GnomeHRef *href, const gchar *label
</FUNCTION>
<FUNCTION>
<NAME>gnome_href_get_label</NAME>
<RETURNS>gchar  *</RETURNS>
GnomeHRef *href
</FUNCTION>
<FUNCTION>
<NAME>gnome_ice_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GNOME_ICON_ENTRY</NAME>
#define GNOME_ICON_ENTRY(obj)         GTK_CHECK_CAST (obj, gnome_icon_entry_get_type (), GnomeIconEntry)
</MACRO>
<MACRO>
<NAME>GNOME_ICON_ENTRY_CLASS</NAME>
#define GNOME_ICON_ENTRY_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_icon_entry_get_type (), GnomeIconEntryClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_ICON_ENTRY</NAME>
#define GNOME_IS_ICON_ENTRY(obj)      GTK_CHECK_TYPE (obj, gnome_icon_entry_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeIconEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeIconEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeIconEntry</NAME>
struct GnomeIconEntry {
	GtkVBox vbox;
	
	GtkWidget *fentry;

	GtkWidget *pickbutton;
	
	GtkWidget *pick_dialog;
	char *pick_dialog_dir;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_icon_entry_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
char *history_id,char *browse_dialog_title
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_set_pixmap_subdir</NAME>
<RETURNS>void  </RETURNS>
GnomeIconEntry *ientry,const char *subdir
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_set_icon</NAME>
<RETURNS>void  </RETURNS>
GnomeIconEntry *ientry,const char *filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_gnome_file_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeIconEntry *ientry
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_gnome_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeIconEntry *ientry
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_gtk_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeIconEntry *ientry
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_entry_get_filename</NAME>
<RETURNS>char       *</RETURNS>
GnomeIconEntry *ientry
</FUNCTION>
<MACRO>
<NAME>GNOME_ICON_TEXT_ITEM</NAME>
#define GNOME_ICON_TEXT_ITEM(obj)     (GTK_CHECK_CAST((obj), \
        gnome_icon_text_item_get_type (), GnomeIconTextItem))
</MACRO>
<MACRO>
<NAME>GNOME_ICON_TEXT_ITEM_CLASS</NAME>
#define GNOME_ICON_TEXT_ITEM_CLASS(k) (GTK_CHECK_CLASS_CAST ((k),\
	gnome_icon_text_item_get_type ()))
</MACRO>
<MACRO>
<NAME>GNOME_IS_ICON_TEXT_ITEM</NAME>
#define GNOME_IS_ICON_TEXT_ITEM(o)    (GTK_CHECK_TYPE((o), \
	gnome_icon_text_item_get_type ()))
</MACRO>
<STRUCT>
<NAME>GnomeIconTextItem</NAME>
typedef struct {
	GnomeCanvasItem canvas_item;

	/* Size and maximum allowed width */
	int x, y;
	int width;

	/* Font name */
	char *fontname;

	/* Private data */
	gpointer priv; /* was GtkEntry *entry */
	gpointer pad1; /* was GtkWidget *entry_top */
	gpointer pad2; /* was GdkFont *font */

	/* Actual text */
	char *text;

	/* Text layout information */
	GnomeIconTextInfo *ti;

	/* Whether the text is being edited */
	unsigned int editing : 1;

	/* Whether the text item is selected */
	unsigned int selected : 1;

	unsigned int pad3; /* was unsigned int unselected_click : 1 */

	/* Whether the user is select-dragging a block of text */
	unsigned int selecting : 1;

	/* Whether the text is editable */
	unsigned int is_editable : 1;

	/* Whether the text is allocated by us (FALSE if allocated by the client) */
	unsigned int is_text_allocated : 1;
} GnomeIconTextItem;
</STRUCT>
<FUNCTION>
<NAME>gnome_icon_text_item_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_text_item_configure</NAME>
<RETURNS>void  </RETURNS>
GnomeIconTextItem *iti,int                x,int                y,int                width,const char        *fontname,const char        *text,gboolean           is_editable,gboolean           is_static
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_text_item_setxy</NAME>
<RETURNS>void  </RETURNS>
GnomeIconTextItem *iti,int                x,int                y
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_text_item_select</NAME>
<RETURNS>void  </RETURNS>
GnomeIconTextItem *iti,int                sel
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_text_item_get_text</NAME>
<RETURNS>char     *</RETURNS>
GnomeIconTextItem *iti
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_text_item_stop_editing</NAME>
<RETURNS>void  </RETURNS>
GnomeIconTextItem *iti,gboolean           accept
</FUNCTION>
<MACRO>
<NAME>GNOME_ICON_LIST</NAME>
#define GNOME_ICON_LIST(obj)     GTK_CHECK_CAST (obj, gnome_icon_list_get_type (), GnomeIconList)
</MACRO>
<MACRO>
<NAME>GNOME_ICON_LIST_CLASS</NAME>
#define GNOME_ICON_LIST_CLASS(k) GTK_CHECK_CLASS_CAST (k, gnome_icon_list_get_type (), GnomeIconListClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_ICON_LIST</NAME>
#define GNOME_IS_ICON_LIST(obj)  GTK_CHECK_TYPE (obj, gnome_icon_list_get_type ())
</MACRO>
<ENUM>
<NAME>GnomeIconListMode</NAME>
typedef enum {
	GNOME_ICON_LIST_ICONS,
	GNOME_ICON_LIST_TEXT_BELOW,
	GNOME_ICON_LIST_TEXT_RIGHT
} GnomeIconListMode;
</ENUM>
<STRUCT>
<NAME>GnomeIconList</NAME>
typedef struct {
	GnomeCanvas canvas;

	/* Private data */
	gpointer priv; /* was GtkAdjustment *adj */

	gpointer pad1; /* was GtkAdjustment *hadj */

	/* Number of icons in the list */
	int icons;

	gpointer pad2; /* was GList *icon_list */
	int pad3; /* was int frozen */
	int pad4; /* was int dirty */
	int pad5; /* was int row_spacing */
	int pad6; /* was int col_spacing */
	int pad7; /* was int text_spacing */
	int pad8; /* was int icon_border */
	gpointer pad9; /* was char *separators */
	GnomeIconListMode pad10; /* was GnomeIconListMode mode */

	GtkSelectionMode pad11; /* was GtkSelectionMode selection_mode */

	/* A list of integers with the indices of the currently selected icons */
	GList *selection;

	gpointer pad12; /* was GList *preserve_selection */
	int pad13; /* was int icon_width */
	unsigned int pad14 : 1; /* was unsigned int is_editable : 1 */
	unsigned int pad15 : 1; /* was unsigned int static_text : 1 */
	int pad16; /* was int last_selected */
	gpointer pad17; /* was void *last_clicked */
	int pad18; /* was int timer_tag */
	int pad19; /* was int value_diff */
	gdouble pad20; /* was gdouble event_last_x */
	gdouble pad21; /* was gdouble event_last_y */
	gpointer pad22; /* was GList *lines */
	int pad23; /* was int total_height */
	double pad24; /* was double sel_start_x */
	double pad25; /* was double sel_start_y */
	gpointer pad26; /* was GnomeCanvasItem *sel_rect */
} GnomeIconList;
</STRUCT>
<MACRO>
<NAME>GNOME_ICON_LIST_IS_EDITABLE</NAME>
#define GNOME_ICON_LIST_IS_EDITABLE 1
</MACRO>
<MACRO>
<NAME>GNOME_ICON_LIST_STATIC_TEXT</NAME>
#define GNOME_ICON_LIST_STATIC_TEXT 2
</MACRO>
<FUNCTION>
<NAME>gnome_icon_list_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_new</NAME>
<RETURNS>GtkWidget      *</RETURNS>
guint         icon_width,GtkAdjustment *adj,int           flags
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_new_flags</NAME>
<RETURNS>GtkWidget      *</RETURNS>
guint         icon_width,GtkAdjustment *adj,int           flags
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_construct</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,guint icon_width,GtkAdjustment *adj,int flags
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_hadjustment</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,GtkAdjustment *hadj
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_vadjustment</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,GtkAdjustment *vadj
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_freeze</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_thaw</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_insert</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pos, const char *icon_filename,const char *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_insert_imlib</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pos, GdkImlibImage *im,const char *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_append</NAME>
<RETURNS>int  </RETURNS>
GnomeIconList *gil,const char *icon_filename,const char *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_append_imlib</NAME>
<RETURNS>int  </RETURNS>
GnomeIconList *gil,GdkImlibImage *im,char *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_clear</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_remove</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil, int pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_selection_mode</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,GtkSelectionMode mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_select_icon</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int idx
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_unselect_icon</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_unselect_all</NAME>
<RETURNS>int  </RETURNS>
GnomeIconList *gil,GdkEvent *event, gpointer keep
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_icon_width</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int w
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_row_spacing</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pixels
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_col_spacing</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pixels
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_text_spacing</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pixels
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_icon_border</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pixels
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_separators</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,const char *sep
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_icon_data</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pos, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_set_icon_data_full</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pos, gpointer data,GtkDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_find_icon_from_data</NAME>
<RETURNS>int  </RETURNS>
GnomeIconList *gil,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_get_icon_data</NAME>
<RETURNS>gpointer  </RETURNS>
GnomeIconList *gil,int pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_moveto</NAME>
<RETURNS>void  </RETURNS>
GnomeIconList *gil,int pos, double yalign
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_icon_is_visible</NAME>
<RETURNS>GtkVisibility  </RETURNS>
GnomeIconList *gil,int pos
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_get_icon_at</NAME>
<RETURNS>int  </RETURNS>
GnomeIconList *gil, int x, int y
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_list_get_items_per_line</NAME>
<RETURNS>int  </RETURNS>
GnomeIconList *gil
</FUNCTION>
<STRUCT>
<NAME>GnomeIconSelection</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeIconSelectionClass</NAME>
</STRUCT>
<MACRO>
<NAME>GNOME_ICON_SELECTION</NAME>
#define GNOME_ICON_SELECTION(obj) GTK_CHECK_CAST (obj, gnome_icon_selection_get_type (), GnomeIconSelection)
</MACRO>
<MACRO>
<NAME>GNOME_ICON_SELECTION_CLASS</NAME>
#define GNOME_ICON_SELECTION_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_icon_selection_get_type (), GnomeIconSelectionClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_ICON_SELECTION</NAME>
#define GNOME_IS_ICON_SELECTION(obj)  GTK_CHECK_TYPE (obj, gnome_icon_selection_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeIconSelection</NAME>
struct GnomeIconSelection {
  GtkVBox vbox;

  GtkWidget * box;

  GtkWidget * gil;

  GList * file_list;
  
  int stop_loading; /* a flag set to stop the loading of images in midprocess */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_icon_selection_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_add_defaults</NAME>
<RETURNS>void  </RETURNS>
GnomeIconSelection * gis
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_add_directory</NAME>
<RETURNS>void  </RETURNS>
GnomeIconSelection * gis,const gchar * dir
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_show_icons</NAME>
<RETURNS>void  </RETURNS>
GnomeIconSelection * gis
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_clear</NAME>
<RETURNS>void  </RETURNS>
GnomeIconSelection * gis,gboolean not_shown
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_get_icon</NAME>
<RETURNS>const gchar  *</RETURNS>
GnomeIconSelection * gis,gboolean full_path
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_select_icon</NAME>
<RETURNS>void  </RETURNS>
GnomeIconSelection * gis,const gchar * filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_selection_stop_loading</NAME>
<RETURNS>void  </RETURNS>
GnomeIconSelection * gis
</FUNCTION>
<STRUCT>
<NAME>GnomeIconTextInfoRow</NAME>
typedef struct {
	char *text;
	int width;
	GdkWChar *text_wc;	/* text in wide characters */
	int text_length;	/* number of characters */
} GnomeIconTextInfoRow;
</STRUCT>
<STRUCT>
<NAME>GnomeIconTextInfo</NAME>
typedef struct {
	GList *rows;
	GdkFont *font;
	int width;
	int height;
	int baseline_skip;
} GnomeIconTextInfo;
</STRUCT>
<FUNCTION>
<NAME>gnome_icon_layout_text</NAME>
<RETURNS>GnomeIconTextInfo  *</RETURNS>
GdkFont *font, char *text,char *separators, int max_width,int confine
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_paint_text</NAME>
<RETURNS>void  </RETURNS>
GnomeIconTextInfo *ti,GdkDrawable *drawable, GdkGC *gc,int x, int y,GtkJustification just
</FUNCTION>
<FUNCTION>
<NAME>gnome_icon_text_info_free</NAME>
<RETURNS>void  </RETURNS>
GnomeIconTextInfo *ti
</FUNCTION>
<FUNCTION>
<NAME>gnome_init</NAME>
<RETURNS>int  </RETURNS>
const char *app_id, const char *app_version,int argc, char **argv
</FUNCTION>
<FUNCTION>
<NAME>gnome_init_with_popt_table</NAME>
<RETURNS>int  </RETURNS>
const char *app_id,const char *app_version,int argc, char **argv,const struct poptOption *options,int flags,poptContext *return_ctx
</FUNCTION>
<STRUCT>
<NAME>GnomeLess</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeLessClass</NAME>
</STRUCT>
<MACRO>
<NAME>GNOME_LESS</NAME>
#define GNOME_LESS(obj)          GTK_CHECK_CAST (obj, gnome_less_get_type (), GnomeLess)
</MACRO>
<MACRO>
<NAME>GNOME_LESS_CLASS</NAME>
#define GNOME_LESS_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_less_get_type (), GnomeLessClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_LESS</NAME>
#define GNOME_IS_LESS(obj)       GTK_CHECK_TYPE (obj, gnome_less_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeLess</NAME>
struct GnomeLess {
  GtkVBox vbox;

  GtkText * text; 

  GtkMenu * popup;

  GdkFont * font;  /* font that goes to gtk_text_insert_text call,
		      can be NULL */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_less_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_clear</NAME>
<RETURNS>void  </RETURNS>
GnomeLess * gl
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_show_file</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeLess * gl, const gchar * path
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_show_command</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeLess * gl, const gchar * command_line
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_show_string</NAME>
<RETURNS>void  </RETURNS>
GnomeLess * gl, const gchar * s
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_show_filestream</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeLess * gl, FILE * f
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_show_fd</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeLess * gl, int file_descriptor
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_write_file</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeLess * gl, const gchar * path
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_write_fd</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeLess * gl, int fd
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_set_font</NAME>
<RETURNS>void  </RETURNS>
GnomeLess * gl, GdkFont * font
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_set_fixed_font</NAME>
<RETURNS>void  </RETURNS>
GnomeLess * gl, gboolean fixed
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_reshow</NAME>
<RETURNS>void  </RETURNS>
GnomeLess * gl
</FUNCTION>
<FUNCTION>
<NAME>gnome_less_fixed_font</NAME>
<RETURNS>void  </RETURNS>
GnomeLess * gl
</FUNCTION>
<MACRO>
<NAME>GNOME_MDI_CHILD</NAME>
#define GNOME_MDI_CHILD(obj)          GTK_CHECK_CAST (obj, gnome_mdi_child_get_type (), GnomeMDIChild)
</MACRO>
<MACRO>
<NAME>GNOME_MDI_CHILD_CLASS</NAME>
#define GNOME_MDI_CHILD_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_mdi_child_get_type (), GnomeMDIChildClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_MDI_CHILD</NAME>
#define GNOME_IS_MDI_CHILD(obj)       GTK_CHECK_TYPE (obj, gnome_mdi_child_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeMDIChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMDIChildClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMDIChild</NAME>
struct GnomeMDIChild
{
	GtkObject object;

	GtkObject *parent;

	gchar *name;

	GList *views;

	GnomeUIInfo *menu_template;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GnomeMDIChildViewCreator</NAME>
<RETURNS>GtkWidget *</RETURNS>
GnomeMDIChild *, gpointer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeMDIChildMenuCreator</NAME>
<RETURNS>GList *</RETURNS>
GnomeMDIChild *, GtkWidget *, gpointer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeMDIChildConfigFunc</NAME>
<RETURNS>gchar *</RETURNS>
GnomeMDIChild *, gpointer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeMDIChildLabelFunc</NAME>
<RETURNS>GtkWidget *</RETURNS>
GnomeMDIChild *, GtkWidget *, gpointer
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_child_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_child_add_view</NAME>
<RETURNS>GtkWidget      *</RETURNS>
GnomeMDIChild *mdi_child
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_child_remove_view</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIChild *mdi_child, GtkWidget *view
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_child_set_name</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIChild *mdi_child, gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_child_set_menu_template</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIChild *mdi_child, GnomeUIInfo *menu_tmpl
</FUNCTION>
<MACRO>
<NAME>GNOME_MDI_GENERIC_CHILD</NAME>
#define GNOME_MDI_GENERIC_CHILD(obj)          GTK_CHECK_CAST (obj, gnome_mdi_generic_child_get_type (), GnomeMDIGenericChild)
</MACRO>
<MACRO>
<NAME>GNOME_MDI_GENERIC_CHILD_CLASS</NAME>
#define GNOME_MDI_GENERIC_CHILD_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_mdi_generic_child_get_type (), GnomeMDIGenericChildClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_MDI_GENERIC_CHILD</NAME>
#define GNOME_IS_MDI_GENERIC_CHILD(obj)       GTK_CHECK_TYPE (obj, gnome_mdi_generic_child_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeMDIGenericChild</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMDIGenericChildClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMDIGenericChild</NAME>
struct GnomeMDIGenericChild {
	GnomeMDIChild mdi_child;

	/* if any of these are set they override the virtual functions
	   in GnomeMDIChildClass. create_view is mandatory, as no default
	   handler is provided, others may be NULL */
	GnomeMDIChildViewCreator create_view;
	GnomeMDIChildMenuCreator create_menus;
	GnomeMDIChildConfigFunc  get_config_string;
	GnomeMDIChildLabelFunc   set_label;

	GtkCallbackMarshal create_view_cbm, create_menus_cbm,
		               get_config_string_cbm, set_label_cbm;
	GtkDestroyNotify   create_view_dn, create_menus_dn,
		               get_config_string_dn, set_label_dn;
	gpointer           create_view_data, create_menus_data,
		               get_config_string_data, set_label_data;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_mdi_generic_child_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_new</NAME>
<RETURNS>GnomeMDIGenericChild  *</RETURNS>
gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_view_creator</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildViewCreator func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_view_creator_full</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildViewCreator func,GtkCallbackMarshal marshal,gpointer data,GtkDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_menu_creator</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildMenuCreator func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_menu_creator_full</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildMenuCreator func,GtkCallbackMarshal marshal,gpointer data,GtkDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_config_func</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildConfigFunc func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_config_func_full</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildConfigFunc func,GtkCallbackMarshal marshal,gpointer data,GtkDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_label_func</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildLabelFunc func,gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_generic_child_set_label_func_full</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIGenericChild *child,GnomeMDIChildLabelFunc func,GtkCallbackMarshal marshal,gpointer data,GtkDestroyNotify notify
</FUNCTION>
<USER_FUNCTION>
<NAME>GnomeMDIChildCreator</NAME>
<RETURNS>GnomeMDIChild *</RETURNS>
const gchar *
</USER_FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_restore_state</NAME>
<RETURNS>gboolean 	</RETURNS>
GnomeMDI *mdi, const char *section,GnomeMDIChildCreator child_create_func
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_save_state</NAME>
<RETURNS>void 	</RETURNS>
GnomeMDI *mdi, const gchar *section
</FUNCTION>
<MACRO>
<NAME>GNOME_MDI</NAME>
#define GNOME_MDI(obj)          GTK_CHECK_CAST (obj, gnome_mdi_get_type (), GnomeMDI)
</MACRO>
<MACRO>
<NAME>GNOME_MDI_CLASS</NAME>
#define GNOME_MDI_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_mdi_get_type (), GnomeMDIClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_MDI</NAME>
#define GNOME_IS_MDI(obj)       GTK_CHECK_TYPE (obj, gnome_mdi_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeMDI</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMDIClass</NAME>
</STRUCT>
<ENUM>
<NAME>GnomeMDIMode</NAME>
typedef enum {
	GNOME_MDI_NOTEBOOK,
	GNOME_MDI_TOPLEVEL,
	GNOME_MDI_MODAL,
	GNOME_MDI_DEFAULT_MODE = 42
} GnomeMDIMode;
</ENUM>
<STRUCT>
<NAME>GnomeMDI</NAME>
struct GnomeMDI {
	GtkObject object;

	GnomeMDIMode mode;

	GtkPositionType tab_pos;

	guint signal_id;
	gint in_drag : 1;

	gchar *appname, *title;

	GnomeUIInfo *menu_template;
	GnomeUIInfo *toolbar_template;

    /* probably only one of these would do, but... redundancy rules ;) */
	GnomeMDIChild *active_child;
	GtkWidget *active_view;  
	GnomeApp *active_window;

	GList *windows;     /* toplevel windows - GnomeApp widgets */
	GList *children;    /* children - GnomeMDIChild objects*/

	GSList *registered; /* see comment for gnome_mdi_(un)register() functions below for an explanation. */
	
    /* paths for insertion of mdi_child specific menus and mdi_child list menu via
       gnome-app-helper routines */
	gchar *child_menu_path; 
	gchar *child_list_path;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_mdi_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_new</NAME>
<RETURNS>GtkObject      *</RETURNS>
gchar *appname, gchar *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_set_mode</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GnomeMDIMode mode
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_set_menubar_template</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GnomeUIInfo *menu_tmpl
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_set_toolbar_template</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GnomeUIInfo *tbar_tmpl
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_set_child_menu_path</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_set_child_list_path</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_add_view</NAME>
<RETURNS>gint  </RETURNS>
GnomeMDI *mdi, GnomeMDIChild *child
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_add_toplevel_view</NAME>
<RETURNS>gint  </RETURNS>
GnomeMDI *mdi, GnomeMDIChild *child
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_remove_view</NAME>
<RETURNS>gint  </RETURNS>
GnomeMDI *mdi, GtkWidget *view, gint force
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_active_view</NAME>
<RETURNS>GtkWidget      *</RETURNS>
GnomeMDI *mdi
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_set_active_view</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GtkWidget *view
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_add_child</NAME>
<RETURNS>gint  </RETURNS>
GnomeMDI *mdi, GnomeMDIChild *child
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_remove_child</NAME>
<RETURNS>gint  </RETURNS>
GnomeMDI *mdi, GnomeMDIChild *child, gint force
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_remove_all</NAME>
<RETURNS>gint  </RETURNS>
GnomeMDI *mdi, gint force
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_open_toplevel</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_update_child</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GnomeMDIChild *child
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_active_child</NAME>
<RETURNS>GnomeMDIChild  *</RETURNS>
GnomeMDI *mdi
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_find_child</NAME>
<RETURNS>GnomeMDIChild  *</RETURNS>
GnomeMDI *mdi, gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_active_window</NAME>
<RETURNS>GnomeApp       *</RETURNS>
GnomeMDI *mdi
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_register</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GtkObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_unregister</NAME>
<RETURNS>void  </RETURNS>
GnomeMDI *mdi, GtkObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_app_from_view</NAME>
<RETURNS>GnomeApp       *</RETURNS>
GtkWidget *view
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_child_from_view</NAME>
<RETURNS>GnomeMDIChild  *</RETURNS>
GtkWidget *view
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_view_from_window</NAME>
<RETURNS>GtkWidget      *</RETURNS>
GnomeMDI *mdi, GnomeApp *app
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_menubar_info</NAME>
<RETURNS>GnomeUIInfo    *</RETURNS>
GnomeApp *app
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_toolbar_info</NAME>
<RETURNS>GnomeUIInfo    *</RETURNS>
GnomeApp *app
</FUNCTION>
<FUNCTION>
<NAME>gnome_mdi_get_child_menu_info</NAME>
<RETURNS>GnomeUIInfo    *</RETURNS>
GnomeApp *app
</FUNCTION>
<MACRO>
<NAME>GNOME_MESSAGE_BOX</NAME>
#define GNOME_MESSAGE_BOX(obj)        GTK_CHECK_CAST (obj, gnome_message_box_get_type (), GnomeMessageBox)
</MACRO>
<MACRO>
<NAME>GNOME_MESSAGE_BOX_CLASS</NAME>
#define GNOME_MESSAGE_BOX_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_message_box_get_type (), GnomeMessageBoxClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_MESSAGE_BOX</NAME>
#define GNOME_IS_MESSAGE_BOX(obj)       GTK_CHECK_TYPE (obj, gnome_message_box_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_MESSAGE_BOX_INFO</NAME>
#define GNOME_MESSAGE_BOX_INFO      "info"
</MACRO>
<MACRO>
<NAME>GNOME_MESSAGE_BOX_WARNING</NAME>
#define GNOME_MESSAGE_BOX_WARNING   "warning"
</MACRO>
<MACRO>
<NAME>GNOME_MESSAGE_BOX_ERROR</NAME>
#define GNOME_MESSAGE_BOX_ERROR     "error"
</MACRO>
<MACRO>
<NAME>GNOME_MESSAGE_BOX_QUESTION</NAME>
#define GNOME_MESSAGE_BOX_QUESTION  "question"
</MACRO>
<MACRO>
<NAME>GNOME_MESSAGE_BOX_GENERIC</NAME>
#define GNOME_MESSAGE_BOX_GENERIC   "generic"
</MACRO>
<STRUCT>
<NAME>GnomeMessageBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMessageBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMessageBoxButton</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeMessageBox</NAME>
struct GnomeMessageBox
{
  GnomeDialog dialog;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_message_box_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_message_box_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar           *message,const gchar           *messagebox_type,...
</FUNCTION>
<FUNCTION>
<NAME>gnome_message_box_newv</NAME>
<RETURNS>GtkWidget *</RETURNS>
const gchar           *message,const gchar           *messagebox_type,const gchar 	      **buttons
</FUNCTION>
<FUNCTION>
<NAME>gnome_message_box_set_modal</NAME>
<RETURNS>void  </RETURNS>
GnomeMessageBox *messagebox
</FUNCTION>
<FUNCTION>
<NAME>gnome_message_box_set_default</NAME>
<RETURNS>void  </RETURNS>
GnomeMessageBox *messagebox,gint            button
</FUNCTION>
<MACRO>
<NAME>GNOME_NUMBER_ENTRY</NAME>
#define GNOME_NUMBER_ENTRY(obj)         GTK_CHECK_CAST (obj, gnome_number_entry_get_type (), GnomeNumberEntry)
</MACRO>
<MACRO>
<NAME>GNOME_NUMBER_ENTRY_CLASS</NAME>
#define GNOME_NUMBER_ENTRY_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_number_entry_get_type (), GnomeNumberEntryClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_NUMBER_ENTRY</NAME>
#define GNOME_IS_NUMBER_ENTRY(obj)      GTK_CHECK_TYPE (obj, gnome_number_entry_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeNumberEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeNumberEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeNumberEntry</NAME>
struct GnomeNumberEntry {
	GtkHBox hbox;

	char *calc_dialog_title;
	
	GtkWidget *calc_dlg;

	GtkWidget *gentry;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_number_entry_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_number_entry_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
char *history_id,char *calc_dialog_title
</FUNCTION>
<FUNCTION>
<NAME>gnome_number_entry_gnome_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeNumberEntry *nentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_number_entry_gtk_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeNumberEntry *nentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_number_entry_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeNumberEntry *nentry,char *calc_dialog_title
</FUNCTION>
<FUNCTION>
<NAME>gnome_number_entry_get_number</NAME>
<RETURNS>gdouble  </RETURNS>
GnomeNumberEntry *nentry
</FUNCTION>
<MACRO>
<NAME>GNOME_PAPER_SELECTOR</NAME>
#define GNOME_PAPER_SELECTOR(obj)         GTK_CHECK_CAST (obj, gnome_paper_selector_get_type (), GnomePaperSelector)
</MACRO>
<MACRO>
<NAME>GNOME_PAPER_SELECTOR_CLASS</NAME>
#define GNOME_PAPER_SELECTOR_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_paper_selector_get_type (), GnomePaperSelectorClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_PAPER_SELECTOR</NAME>
#define GNOME_IS_PAPER_SELECTOR(obj)      GTK_CHECK_TYPE (obj, gnome_paper_selector_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomePaperSelector</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePaperSelectorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePaperSelector</NAME>
struct GnomePaperSelector {
  GtkVBox vbox;
  
  GtkWidget *paper;
  GtkWidget *width;
  GtkWidget *height;
  GtkWidget *unit;
  GtkWidget *unit_label;

  gint paper_id;
  gint width_id;
  gint height_id;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_paper_selector_get_type</NAME>
<RETURNS>guint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_new</NAME>
<RETURNS>GtkWidget 	*</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_name</NAME>
<RETURNS>gchar 		*</RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_width</NAME>
<RETURNS>gfloat 	</RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_height</NAME>
<RETURNS>gfloat 	</RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_left_margin</NAME>
<RETURNS>gfloat  </RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_right_margin</NAME>
<RETURNS>gfloat  </RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_top_margin</NAME>
<RETURNS>gfloat  </RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_get_bottom_margin</NAME>
<RETURNS>gfloat  </RETURNS>
GnomePaperSelector *gspaper
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_set_name</NAME>
<RETURNS>void 	</RETURNS>
GnomePaperSelector *gspaper,gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_set_width</NAME>
<RETURNS>void 	</RETURNS>
GnomePaperSelector *gspaper,gfloat width
</FUNCTION>
<FUNCTION>
<NAME>gnome_paper_selector_set_height</NAME>
<RETURNS>void 	</RETURNS>
GnomePaperSelector *gspaper,gfloat height
</FUNCTION>
<MACRO>
<NAME>GNOME_PIXMAP_ENTRY</NAME>
#define GNOME_PIXMAP_ENTRY(obj)         GTK_CHECK_CAST (obj, gnome_pixmap_entry_get_type (), GnomePixmapEntry)
</MACRO>
<MACRO>
<NAME>GNOME_PIXMAP_ENTRY_CLASS</NAME>
#define GNOME_PIXMAP_ENTRY_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_pixmap_entry_get_type (), GnomePixmapEntryClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_PIXMAP_ENTRY</NAME>
#define GNOME_IS_PIXMAP_ENTRY(obj)      GTK_CHECK_TYPE (obj, gnome_pixmap_entry_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomePixmapEntry</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePixmapEntryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePixmapEntry</NAME>
struct GnomePixmapEntry {
	GtkVBox vbox;
	
	GtkWidget *fentry;

	int do_preview; /*put a preview frame with the pixmap next to
			  the entry*/
	GtkWidget *preview;
	GtkWidget *preview_sw;
	
	/*very private*/
	char *last_preview;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_pixmap_entry_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
char *history_id,char *browse_dialog_title,int do_preview
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_set_pixmap_subdir</NAME>
<RETURNS>void  </RETURNS>
GnomePixmapEntry *pentry,const char *subdir
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_gnome_file_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomePixmapEntry *pentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_gnome_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomePixmapEntry *pentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_gtk_entry</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomePixmapEntry *pentry
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_set_preview</NAME>
<RETURNS>void  </RETURNS>
GnomePixmapEntry *pentry,int do_preview
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_set_preview_size</NAME>
<RETURNS>void 	</RETURNS>
GnomePixmapEntry *pentry,int preview_w,int preview_h
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_entry_get_filename</NAME>
<RETURNS>char       *</RETURNS>
GnomePixmapEntry *pentry
</FUNCTION>
<MACRO>
<NAME>GNOME_PIXMAP</NAME>
#define GNOME_PIXMAP(obj)         GTK_CHECK_CAST (obj, gnome_pixmap_get_type (), GnomePixmap)
</MACRO>
<MACRO>
<NAME>GNOME_PIXMAP_CLASS</NAME>
#define GNOME_PIXMAP_CLASS(klass) GTK_CHECK_CLASS_CAST (klass, gnome_pixmap_get_type (), GnomePixmapClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_PIXMAP</NAME>
#define GNOME_IS_PIXMAP(obj)      GTK_CHECK_TYPE (obj, gnome_pixmap_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomePixmap</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePixmapClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePixmap</NAME>
struct GnomePixmap {
	GtkWidget widget;

	GdkPixmap *pixmap;
	GdkBitmap *mask;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_pixmap_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_file</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const char *filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_file_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const char *filename, int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_xpm_d</NAME>
<RETURNS>GtkWidget  *</RETURNS>
char **xpm_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_xpm_d_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
char **xpm_data, int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_rgb_d</NAME>
<RETURNS>GtkWidget  *</RETURNS>
unsigned char *data, unsigned char *alpha,int rgb_width, int rgb_height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_rgb_d_shaped</NAME>
<RETURNS>GtkWidget  *</RETURNS>
unsigned char *data, unsigned char *alpha,int rgb_width, int rgb_height,GdkImlibColor *shape_color
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_rgb_d_shaped_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
unsigned char *data,unsigned char *alpha,int rgb_width, int rgb_height,int width, int height,GdkImlibColor *shape_color
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_rgb_d_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
unsigned char *data, unsigned char *alpha,int rgb_width, int rgb_height,int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_gnome_pixmap</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomePixmap *gpixmap
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_imlib</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkImlibImage *im
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_new_from_imlib_at_size</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GdkImlibImage *im,int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_file</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, const char *filename
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_file_at_size</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, const char *filename, int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_xpm_d</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, char **xpm_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_xpm_d_at_size</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, char **xpm_data, int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_rgb_d</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, unsigned char *data, unsigned char *alpha,int rgb_width, int rgb_height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_rgb_d_shaped</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, unsigned char *data, unsigned char *alpha,int rgb_width, int rgb_height,GdkImlibColor *shape_color
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_rgb_d_shaped_at_size</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap,unsigned char *data,unsigned char *alpha,int rgb_width, int rgb_height,int width, int height,GdkImlibColor *shape_color
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_rgb_d_at_size</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap, unsigned char *data, unsigned char *alpha,int rgb_width, int rgb_height,int width, int height
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_imlib</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap,GdkImlibImage *im
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_load_imlib_at_size</NAME>
<RETURNS>void  </RETURNS>
GnomePixmap *gpixmap,GdkImlibImage *im,int width, int height
</FUNCTION>
<MACRO>
<NAME>gnome_widget_add_help</NAME>
#define gnome_widget_add_help(widget, help) \
	(gnome_widget_add_help_with_uidata((widget),(help),NULL, NULL))
</MACRO>
<FUNCTION>
<NAME>gnome_widget_add_help_with_uidata</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *widget,gchar *help,GnomeUIInfo *menuinfo,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_popup_menu_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeUIInfo *uiinfo
</FUNCTION>
<FUNCTION>
<NAME>gnome_popup_menu_new_with_accelgroup</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomeUIInfo *uiinfo,GtkAccelGroup *accelgroup
</FUNCTION>
<FUNCTION>
<NAME>gnome_popup_menu_get_accel_group</NAME>
<RETURNS>GtkAccelGroup  *</RETURNS>
GtkMenu *menu
</FUNCTION>
<FUNCTION>
<NAME>gnome_popup_menu_attach</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *popup, GtkWidget *widget,gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_popup_menu_do_popup</NAME>
<RETURNS>void  </RETURNS>
GtkWidget *popup, GtkMenuPositionFunc pos_func, gpointer pos_data,GdkEventButton *event, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gnome_popup_menu_do_popup_modal</NAME>
<RETURNS>int  </RETURNS>
GtkWidget *popup, GtkMenuPositionFunc pos_func, gpointer pos_data,GdkEventButton *event, gpointer user_data
</FUNCTION>
<STRUCT>
<NAME>GnomePreferences</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePreferences</NAME>
struct GnomePreferences {
  GtkButtonBoxStyle dialog_buttons_style;
  int property_box_buttons_ok : 1;
  int property_box_buttons_apply : 1;
  int property_box_buttons_close : 1;
  int property_box_buttons_help : 1;
  int statusbar_not_dialog : 1;
  int statusbar_is_interactive : 1;
  int statusbar_meter_on_right : 1;
  int menubar_detachable : 1;
  int menubar_relief : 1;
  int toolbar_detachable : 1;
  int toolbar_relief : 1;
  int toolbar_relief_btn : 1;
  int toolbar_lines : 1;
  int toolbar_labels : 1;
  int dialog_centered : 1;
  int menus_have_tearoff : 1;
  int menus_have_icons : 1;
  int disable_imlib_cache : 1;
  GtkWindowType dialog_type;
  GtkWindowPosition dialog_position;
  GnomeMDIMode mdi_mode;
  GtkPositionType mdi_tab_pos;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_preferences_load</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_save</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_load_custom</NAME>
<RETURNS>void  </RETURNS>
GnomePreferences *settings
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_save_custom</NAME>
<RETURNS>void  </RETURNS>
GnomePreferences *settings
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_button_layout</NAME>
<RETURNS>GtkButtonBoxStyle  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_button_layout</NAME>
<RETURNS>void  </RETURNS>
GtkButtonBoxStyle style
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_statusbar_dialog</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_statusbar_dialog</NAME>
<RETURNS>void  </RETURNS>
gboolean statusbar
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_statusbar_interactive</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_statusbar_interactive</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_statusbar_meter_on_right</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_statusbar_meter_on_right</NAME>
<RETURNS>void  </RETURNS>
gboolean status_meter_on_right
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_menubar_detachable</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_menubar_detachable</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_menubar_relief</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_menubar_relief</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_toolbar_detachable</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_toolbar_detachable</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_toolbar_relief</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_toolbar_relief</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_toolbar_relief_btn</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_toolbar_relief_btn</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_toolbar_lines</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_toolbar_lines</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_toolbar_labels</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_toolbar_labels</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_dialog_centered</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_dialog_centered</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_dialog_type</NAME>
<RETURNS>GtkWindowType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_dialog_type</NAME>
<RETURNS>void  </RETURNS>
GtkWindowType t
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_dialog_position</NAME>
<RETURNS>GtkWindowPosition  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_dialog_position</NAME>
<RETURNS>void  </RETURNS>
GtkWindowPosition p
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_mdi_mode</NAME>
<RETURNS>GnomeMDIMode  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_mdi_mode</NAME>
<RETURNS>void  </RETURNS>
GnomeMDIMode m
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_mdi_tab_pos</NAME>
<RETURNS>GtkPositionType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_mdi_tab_pos</NAME>
<RETURNS>void  </RETURNS>
GtkPositionType p
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_property_box_apply</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_property_box_button_apply</NAME>
<RETURNS>void  </RETURNS>
int v
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_menus_have_tearoff</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_menus_have_tearoff</NAME>
<RETURNS>void  </RETURNS>
gboolean b
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_menus_have_icons</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_menus_have_icons</NAME>
<RETURNS>void  </RETURNS>
int have_icons
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_get_disable_imlib_cache</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_preferences_set_disable_imlib_cache</NAME>
<RETURNS>void  </RETURNS>
int disable_imlib_cache
</FUNCTION>
<MACRO>
<NAME>GNOME_PROC_BAR</NAME>
#define GNOME_PROC_BAR(obj)		GTK_CHECK_CAST (obj, gnome_proc_bar_get_type (), GnomeProcBar)
</MACRO>
<MACRO>
<NAME>GNOME_PROC_BAR__CLASS</NAME>
#define GNOME_PROC_BAR__CLASS(klass)	GTK_CHECK_CLASS_CAST (klass, gnome_proc_bar_get_type (), GnomeProcBarClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_PROC_BAR</NAME>
#define GNOME_IS_PROC_BAR(obj)		GTK_CHECK_TYPE (obj, gnome_proc_bar_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeProcBar</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeProcBarClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeProcBar</NAME>
struct GnomeProcBar {

	GtkHBox hbox;

	GtkWidget *bar;
	GtkWidget *label;
	GtkWidget *frame;

	gboolean vertical : 1;

	GdkPixmap *bs;
	GdkColor *colors;

	gint colors_allocated;
	gint first_request;
	gint n;
	gint tag;

	unsigned *last;

	gint (*cb)();
	gpointer cb_data;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_proc_bar_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_proc_bar_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkWidget *label,gint n, GdkColor *colors,gint (*cb)()
</FUNCTION>
<FUNCTION>
<NAME>gnome_proc_bar_set_values</NAME>
<RETURNS>void  </RETURNS>
GnomeProcBar *pb, unsigned val []
</FUNCTION>
<FUNCTION>
<NAME>gnome_proc_bar_set_orient</NAME>
<RETURNS>void  </RETURNS>
GnomeProcBar *pb, gboolean vertical
</FUNCTION>
<FUNCTION>
<NAME>gnome_proc_bar_start</NAME>
<RETURNS>void  </RETURNS>
GnomeProcBar *pb, gint gtime, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gnome_proc_bar_stop</NAME>
<RETURNS>void  </RETURNS>
GnomeProcBar *pb
</FUNCTION>
<FUNCTION>
<NAME>gnome_proc_bar_update</NAME>
<RETURNS>void  </RETURNS>
GnomeProcBar *pb, GdkColor *colors
</FUNCTION>
<STRUCT>
<NAME>GnomePropertyObject</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePropertyDescriptor</NAME>
</STRUCT>
<ENUM>
<NAME>GnomePropertyAction</NAME>
typedef enum {
	GNOME_PROPERTY_ACTION_APPLY = 1,
	GNOME_PROPERTY_ACTION_UPDATE,
	GNOME_PROPERTY_ACTION_LOAD,
	GNOME_PROPERTY_ACTION_SAVE,
	GNOME_PROPERTY_ACTION_LOAD_TEMP,
	GNOME_PROPERTY_ACTION_SAVE_TEMP,
	GNOME_PROPERTY_ACTION_DISCARD_TEMP,
	GNOME_PROPERTY_ACTION_CHANGED
} GnomePropertyAction;
</ENUM>
<STRUCT>
<NAME>GnomePropertyDescriptor</NAME>
struct GnomePropertyDescriptor {
	guint size;
	const gchar *label;
	GtkWidget * (*init_func) (GnomePropertyObject *);
	void (*apply_func) (GnomePropertyObject *);
	void (*update_func) (GnomePropertyObject *);
	void (*load_func) (GnomePropertyObject *);
	void (*save_func) (GnomePropertyObject *);
	void (*load_temp_func) (GnomePropertyObject *);
	gint (*save_temp_func) (GnomePropertyObject *);
	void (*discard_temp_func) (GnomePropertyObject *);
	void (*changed_func) (GnomePropertyObject *);
	GList *next;
};
</STRUCT>
<STRUCT>
<NAME>GnomePropertyObject</NAME>
struct GnomePropertyObject {
	GtkWidget *label;
	GnomePropertyDescriptor *descriptor;
	gpointer prop_data, temp_data, user_data;
	GList *object_list;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_property_object_new</NAME>
<RETURNS>GnomePropertyObject  *</RETURNS>
GnomePropertyDescriptor *descriptor,gpointer property_data_ptr
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_register</NAME>
<RETURNS>void</RETURNS>
GnomePropertyBox *property_box,GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_list_walk</NAME>
<RETURNS>void</RETURNS>
GList *property_object_list,GnomePropertyAction action
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_apply</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_update</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_load</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_save</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_load_temp</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_save_temp</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_discard_temp</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_object_changed</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyObject *object
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_entry_font</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomePropertyObject *object, const gchar *label,gchar **font_name_ptr, GdkFont **font_ptr
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_entry_colors</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GnomePropertyObject *object, const gchar *label,gint num_colors, gint columns, gint *table_pos,GdkColor *colors, const gchar *texts []
</FUNCTION>
<MACRO>
<NAME>GNOME_PROPERTY_BOX</NAME>
#define GNOME_PROPERTY_BOX(Obj)         GTK_CHECK_CAST (Obj, gnome_property_box_get_type (), GnomePropertyBox)
</MACRO>
<MACRO>
<NAME>GNOME_PROPERTY_BOX_CLASS</NAME>
#define GNOME_PROPERTY_BOX_CLASS(Klass) GTK_CHECK_CLASS_CAST (Klass, gnome_property_box_get_type (), GnomePropertyBoxClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_PROPERTY_BOX</NAME>
#define GNOME_IS_PROPERTY_BOX(Obj)      GTK_CHECK_TYPE (Obj, gnome_property_box_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_PROPERTY_BOX_DIRTY</NAME>
#define GNOME_PROPERTY_BOX_DIRTY	"gnome_property_box_dirty"
</MACRO>
<STRUCT>
<NAME>GnomePropertyBox</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePropertyBoxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomePropertyBox</NAME>
struct GnomePropertyBox
{
	GnomeDialog dialog;

	GtkWidget *notebook;	    /* The notebook widget.  */
	GtkWidget *ok_button;	    /* OK button.  */
	GtkWidget *apply_button;    /* Apply button.  */
	GtkWidget *cancel_button;   /* Cancel/Close button.  */
	GtkWidget *help_button;	    /* Help button.  */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_property_box_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_box_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_box_changed</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyBox *property_box
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_box_set_modified</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyBox *property_box,gboolean state
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_box_append_page</NAME>
<RETURNS>gint 	</RETURNS>
GnomePropertyBox *property_box,GtkWidget *child,GtkWidget *tab_label
</FUNCTION>
<FUNCTION>
<NAME>gnome_property_box_set_state</NAME>
<RETURNS>void  </RETURNS>
GnomePropertyBox *property_box,gboolean state
</FUNCTION>
<MACRO>
<NAME>GNOME_SCORES</NAME>
#define GNOME_SCORES(obj)          GTK_CHECK_CAST (obj, gnome_scores_get_type (), GnomeScores)
</MACRO>
<MACRO>
<NAME>GNOME_SCORES_CLASS</NAME>
#define GNOME_SCORES_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gnome_scores_get_type (), GnomeScoresClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_SCORES</NAME>
#define GNOME_IS_SCORES(obj)       GTK_CHECK_TYPE (obj, gnome_scores_get_type ())
</MACRO>
<STRUCT>
<NAME>GnomeScores</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeScoresClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeScores</NAME>
struct GnomeScores
{
  GnomeDialog dialog;

  GtkWidget *but_clear;
  guint	    n_scores;

  GtkWidget *logo;
  GtkWidget **label_names;
  GtkWidget **label_scores;
  GtkWidget **label_times;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_scores_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
guint n_scores,gchar **names,gfloat *scores,time_t *times,guint clear
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_logo_label</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,gchar *txt,gchar *font,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_logo_pixmap</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,gchar *logo
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_logo_widget</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,GtkWidget *w
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_color</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,guint pos,GdkColor *col
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_def_color</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,GdkColor *col
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_colors</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,GdkColor *col
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_logo_label_title</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,gchar *txt
</FUNCTION>
<FUNCTION>
<NAME>gnome_scores_set_current_player</NAME>
<RETURNS>void  </RETURNS>
GnomeScores *gs,gint i
</FUNCTION>
<MACRO>
<NAME>GNOME_SPELL</NAME>
#define GNOME_SPELL(obj)		GTK_CHECK_CAST(obj, gnome_spell_get_type(), GnomeSpell)
</MACRO>
<MACRO>
<NAME>GNOME_SPELL_CLASS</NAME>
#define GNOME_SPELL_CLASS(klass)		GTK_CHECK_CLASS_CAST(klass, gnome_spell_get_type(), GnomeSpelliClass)
</MACRO>
<MACRO>
<NAME>GNOME_IS_SPELL</NAME>
#define GNOME_IS_SPELL(obj)		GTK_CHECK_TYPE(obj, gnome_spell_get_type())
</MACRO>
<STRUCT>
<NAME>GnomeSpell</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeSpellClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeSpellInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeSpellInfo</NAME>
struct GnomeSpellInfo {
	gchar* original;
	gchar* replacement;
	gchar* word;
	guint offset;
	GSList * words;
};
</STRUCT>
<STRUCT>
<NAME>GnomeSpell</NAME>
struct GnomeSpell {
	GtkVBox vbox;

	GSList * spellinfo;

	GtkWidget* page_spell;
	GtkWidget* page_config;
	GtkWidget* word;
	GtkWidget* list;
	GtkWidget* b_accept;
	GtkWidget* b_skip;
	GtkWidget* b_replace;
	GtkWidget* b_insert;
	GtkWidget* b_insertl;
	GtkWidget* command;
	GtkWidget* dict;
	GtkWidget* pdict;
	GtkWidget* wchars;
	GtkWidget* wlen;
	GtkWidget* sort;
	GtkWidget* runtog;
	GtkWidget* discard;
	GtkWidget* tooltip;
	GtkWidget* killproc;
	GtkTooltips* tooltips;
	GSList* awords;

	FILE* rispell;
	FILE* wispell;
	pid_t spell_pid;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_spell_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_spell_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_spell_check</NAME>
<RETURNS>gint  </RETURNS>
GnomeSpell* gtkspell, gchar* str
</FUNCTION>
<FUNCTION>
<NAME>gnome_spell_accept</NAME>
<RETURNS>void  </RETURNS>
GnomeSpell* gtkspell, gchar* word
</FUNCTION>
<FUNCTION>
<NAME>gnome_spell_insert</NAME>
<RETURNS>void  </RETURNS>
GnomeSpell* gtkspell, gchar* word, gint lowercase
</FUNCTION>
<FUNCTION>
<NAME>gnome_spell_next</NAME>
<RETURNS>int 	</RETURNS>
GnomeSpell* gtkspell
</FUNCTION>
<FUNCTION>
<NAME>gnome_spell_kill</NAME>
<RETURNS>void 	</RETURNS>
GnomeSpell* gtkspell
</FUNCTION>
<FUNCTION>
<NAME>gnome_startup_acquire_token</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *property_name,const gchar *sm_id
</FUNCTION>
<MACRO>
<NAME>USE_NEW_GNOME_STOCK</NAME>
#define USE_NEW_GNOME_STOCK 1
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_NEW</NAME>
#define GNOME_STOCK_PIXMAP_NEW         "New"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_OPEN</NAME>
#define GNOME_STOCK_PIXMAP_OPEN        "Open"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_CLOSE</NAME>
#define GNOME_STOCK_PIXMAP_CLOSE       "Close"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_REVERT</NAME>
#define GNOME_STOCK_PIXMAP_REVERT      "Revert"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_SAVE</NAME>
#define GNOME_STOCK_PIXMAP_SAVE        "Save"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_SAVE_AS</NAME>
#define GNOME_STOCK_PIXMAP_SAVE_AS     "Save As"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_CUT</NAME>
#define GNOME_STOCK_PIXMAP_CUT         "Cut"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_COPY</NAME>
#define GNOME_STOCK_PIXMAP_COPY        "Copy"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_PASTE</NAME>
#define GNOME_STOCK_PIXMAP_PASTE       "Paste"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_CLEAR</NAME>
#define GNOME_STOCK_PIXMAP_CLEAR       "Clear"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_PROPERTIES</NAME>
#define GNOME_STOCK_PIXMAP_PROPERTIES  "Properties"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_PREFERENCES</NAME>
#define GNOME_STOCK_PIXMAP_PREFERENCES "Preferences"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_HELP</NAME>
#define GNOME_STOCK_PIXMAP_HELP        "Help"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_SCORES</NAME>
#define GNOME_STOCK_PIXMAP_SCORES      "Scores"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_PRINT</NAME>
#define GNOME_STOCK_PIXMAP_PRINT       "Print"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_SEARCH</NAME>
#define GNOME_STOCK_PIXMAP_SEARCH      "Search"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_SRCHRPL</NAME>
#define GNOME_STOCK_PIXMAP_SRCHRPL     "Search/Replace"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BACK</NAME>
#define GNOME_STOCK_PIXMAP_BACK        "Back"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_FORWARD</NAME>
#define GNOME_STOCK_PIXMAP_FORWARD     "Forward"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_FIRST</NAME>
#define GNOME_STOCK_PIXMAP_FIRST       "First"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_LAST</NAME>
#define GNOME_STOCK_PIXMAP_LAST        "Last"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_HOME</NAME>
#define GNOME_STOCK_PIXMAP_HOME        "Home"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_STOP</NAME>
#define GNOME_STOCK_PIXMAP_STOP        "Stop"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_REFRESH</NAME>
#define GNOME_STOCK_PIXMAP_REFRESH     "Refresh"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_UNDO</NAME>
#define GNOME_STOCK_PIXMAP_UNDO        "Undo"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_REDO</NAME>
#define GNOME_STOCK_PIXMAP_REDO        "Redo"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TIMER</NAME>
#define GNOME_STOCK_PIXMAP_TIMER       "Timer"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TIMER_STOP</NAME>
#define GNOME_STOCK_PIXMAP_TIMER_STOP  "Timer Stopped"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MAIL</NAME>
#define GNOME_STOCK_PIXMAP_MAIL	       "Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MAIL_RCV</NAME>
#define GNOME_STOCK_PIXMAP_MAIL_RCV    "Receive Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MAIL_SND</NAME>
#define GNOME_STOCK_PIXMAP_MAIL_SND    "Send Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MAIL_RPL</NAME>
#define GNOME_STOCK_PIXMAP_MAIL_RPL    "Reply to Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MAIL_FWD</NAME>
#define GNOME_STOCK_PIXMAP_MAIL_FWD    "Forward Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MAIL_NEW</NAME>
#define GNOME_STOCK_PIXMAP_MAIL_NEW    "New Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TRASH</NAME>
#define GNOME_STOCK_PIXMAP_TRASH       "Trash"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TRASH_FULL</NAME>
#define GNOME_STOCK_PIXMAP_TRASH_FULL  "Trash Full"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_UNDELETE</NAME>
#define GNOME_STOCK_PIXMAP_UNDELETE    "Undelete"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_SPELLCHECK</NAME>
#define GNOME_STOCK_PIXMAP_SPELLCHECK  "Spellchecker"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MIC</NAME>
#define GNOME_STOCK_PIXMAP_MIC         "Microphone"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_LINE_IN</NAME>
#define GNOME_STOCK_PIXMAP_LINE_IN     "Line In"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_CDROM</NAME>
#define GNOME_STOCK_PIXMAP_CDROM       "Cdrom"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_VOLUME</NAME>
#define GNOME_STOCK_PIXMAP_VOLUME      "Volume"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MIDI</NAME>
#define GNOME_STOCK_PIXMAP_MIDI        "Midi"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BOOK_RED</NAME>
#define GNOME_STOCK_PIXMAP_BOOK_RED    "Book Red"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BOOK_GREEN</NAME>
#define GNOME_STOCK_PIXMAP_BOOK_GREEN  "Book Green"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BOOK_BLUE</NAME>
#define GNOME_STOCK_PIXMAP_BOOK_BLUE   "Book Blue"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BOOK_YELLOW</NAME>
#define GNOME_STOCK_PIXMAP_BOOK_YELLOW "Book Yellow"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BOOK_OPEN</NAME>
#define GNOME_STOCK_PIXMAP_BOOK_OPEN   "Book Open"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ABOUT</NAME>
#define GNOME_STOCK_PIXMAP_ABOUT       "About"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_QUIT</NAME>
#define GNOME_STOCK_PIXMAP_QUIT        "Quit"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_MULTIPLE</NAME>
#define GNOME_STOCK_PIXMAP_MULTIPLE    "Multiple"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_NOT</NAME>
#define GNOME_STOCK_PIXMAP_NOT         "Not"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_CONVERT</NAME>
#define GNOME_STOCK_PIXMAP_CONVERT     "Convert"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_JUMP_TO</NAME>
#define GNOME_STOCK_PIXMAP_JUMP_TO     "Jump To"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_UP</NAME>
#define GNOME_STOCK_PIXMAP_UP          "Up"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_DOWN</NAME>
#define GNOME_STOCK_PIXMAP_DOWN        "Down"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TOP</NAME>
#define GNOME_STOCK_PIXMAP_TOP         "Top"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_BOTTOM</NAME>
#define GNOME_STOCK_PIXMAP_BOTTOM      "Bottom"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ATTACH</NAME>
#define GNOME_STOCK_PIXMAP_ATTACH      "Attach"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_INDEX</NAME>
#define GNOME_STOCK_PIXMAP_INDEX       "Index"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_FONT</NAME>
#define GNOME_STOCK_PIXMAP_FONT        "Font"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_EXEC</NAME>
#define GNOME_STOCK_PIXMAP_EXEC        "Exec"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ALIGN_LEFT</NAME>
#define GNOME_STOCK_PIXMAP_ALIGN_LEFT    "Left"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ALIGN_RIGHT</NAME>
#define GNOME_STOCK_PIXMAP_ALIGN_RIGHT   "Right"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ALIGN_CENTER</NAME>
#define GNOME_STOCK_PIXMAP_ALIGN_CENTER  "Center"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ALIGN_JUSTIFY</NAME>
#define GNOME_STOCK_PIXMAP_ALIGN_JUSTIFY "Justify"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_BOLD</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_BOLD      "Bold"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_ITALIC</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_ITALIC    "Italic"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_UNDERLINE</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_UNDERLINE "Underline"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_STRIKEOUT</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_STRIKEOUT "Strikeout"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_INDENT</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_INDENT "Text Indent"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_UNINDENT</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_UNINDENT "Text Unindent"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_EXIT</NAME>
#define GNOME_STOCK_PIXMAP_EXIT        GNOME_STOCK_PIXMAP_QUIT
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_COLORSELECTOR</NAME>
#define GNOME_STOCK_PIXMAP_COLORSELECTOR "Color Select"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_ADD</NAME>
#define GNOME_STOCK_PIXMAP_ADD    "Add"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_REMOVE</NAME>
#define GNOME_STOCK_PIXMAP_REMOVE "Remove"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TABLE_BORDERS</NAME>
#define GNOME_STOCK_PIXMAP_TABLE_BORDERS "Table Borders"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TABLE_FILL</NAME>
#define GNOME_STOCK_PIXMAP_TABLE_FILL "Table Fill"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_BULLETED_LIST</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_BULLETED_LIST "Text Bulleted List"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_TEXT_NUMBERED_LIST</NAME>
#define GNOME_STOCK_PIXMAP_TEXT_NUMBERED_LIST "Text Numbered List"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_REGULAR</NAME>
#define GNOME_STOCK_PIXMAP_REGULAR     "regular"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_DISABLED</NAME>
#define GNOME_STOCK_PIXMAP_DISABLED    "disabled"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_FOCUSED</NAME>
#define GNOME_STOCK_PIXMAP_FOCUSED     "focused"
</MACRO>
<STRUCT>
<NAME>GnomeStockPixmapEntryAny</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryData</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryFile</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryPath</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryGPixmap</NAME>
</STRUCT>
<ENUM>
<NAME>GnomeStockPixmapType</NAME>
typedef enum {
        GNOME_STOCK_PIXMAP_TYPE_NONE,
        GNOME_STOCK_PIXMAP_TYPE_DATA,
        GNOME_STOCK_PIXMAP_TYPE_FILE,
        GNOME_STOCK_PIXMAP_TYPE_PATH,
        GNOME_STOCK_PIXMAP_TYPE_WIDGET,
	GNOME_STOCK_PIXMAP_TYPE_IMLIB,
	GNOME_STOCK_PIXMAP_TYPE_IMLIB_SCALED,
	GNOME_STOCK_PIXMAP_TYPE_GPIXMAP
} GnomeStockPixmapType;
</ENUM>
<STRUCT>
<NAME>GnomeStockPixmapEntryData</NAME>
struct GnomeStockPixmapEntryData {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        gchar **xpm_data;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryImlib</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryImlib</NAME>
struct GnomeStockPixmapEntryImlib {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        const gchar *rgb_data;
	GdkImlibColor shape;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryImlibScaled</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryImlibScaled</NAME>
struct GnomeStockPixmapEntryImlibScaled {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        const gchar *rgb_data;
	GdkImlibColor shape;
	int scaled_width, scaled_height;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryFile</NAME>
struct GnomeStockPixmapEntryFile {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        gchar *filename;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryPath</NAME>
struct GnomeStockPixmapEntryPath {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        gchar *pathname;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryWidget</NAME>
struct GnomeStockPixmapEntryWidget {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        GtkWidget *widget;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryGPixmap</NAME>
struct GnomeStockPixmapEntryGPixmap {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
        GnomePixmap *pixmap;
};
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapEntryAny</NAME>
struct GnomeStockPixmapEntryAny {
        GnomeStockPixmapType type;
	int width, height;
	char *label;
};
</STRUCT>
<UNION>
<NAME>GnomeStockPixmapEntry</NAME>
union GnomeStockPixmapEntry {
        GnomeStockPixmapType type;
        GnomeStockPixmapEntryAny any;
        GnomeStockPixmapEntryData data;
        GnomeStockPixmapEntryFile file;
        GnomeStockPixmapEntryPath path;
        GnomeStockPixmapEntryWidget widget;
	GnomeStockPixmapEntryImlib imlib;
	GnomeStockPixmapEntryImlibScaled imlib_s;
        GnomeStockPixmapEntryGPixmap gpixmap;
};
</UNION>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_WIDGET</NAME>
#define GNOME_STOCK_PIXMAP_WIDGET(obj)         GTK_CHECK_CAST(obj, gnome_stock_pixmap_widget_get_type(), GnomeStockPixmapWidget)
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_WIDGET_CLASS</NAME>
#define GNOME_STOCK_PIXMAP_WIDGET_CLASS(klass) GTK_CHECK_CAST_CLASS(obj, gnome_stock_pixmap_widget_get_type(), GnomeStockPixmapWidget)
</MACRO>
<MACRO>
<NAME>GNOME_IS_STOCK_PIXMAP_WIDGET</NAME>
#define GNOME_IS_STOCK_PIXMAP_WIDGET(obj)      GTK_CHECK_TYPE(obj, gnome_stock_pixmap_widget_get_type())
</MACRO>
<STRUCT>
<NAME>GnomeStockPixmapWidget</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapWidgetClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockPixmapWidget</NAME>
struct GnomeStockPixmapWidget {
	GtkVBox parent_object;

        char *icon;
	int width, height;      /* needed to answer size_requests even before
			         * a pixmap is loaded/created */
        GtkWidget   *window;    /* needed for style and gdk_pixmap_create... */
        GnomePixmap *pixmap;    /* the pixmap currently shown */
        GnomePixmap *regular, *disabled, *focused;  /* pixmap cache */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkWidget *window, const char *icon
</FUNCTION>
<MACRO>
<NAME>GNOME_STOCK_PIXMAP_WIDGET</NAME>
#define GNOME_STOCK_PIXMAP_WIDGET GNOME_STOCK
</MACRO>
<MACRO>
<NAME>GNOME_IS_STOCK_PIXMAP_WIDGET</NAME>
#define GNOME_IS_STOCK_PIXMAP_WIDGET GNOME_IS_STOCK
</MACRO>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkWidget *window, const char *icon
</FUNCTION>
<MACRO>
<NAME>GNOME_STOCK</NAME>
#define GNOME_STOCK(obj)         GTK_CHECK_CAST(obj, gnome_stock_get_type(), GnomeStock)
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_CLASS</NAME>
#define GNOME_STOCK_CLASS(klass) GTK_CHECK_CAST_CLASS(obj, gnome_stock_get_type(), GnomeStock)
</MACRO>
<MACRO>
<NAME>GNOME_IS_STOCK</NAME>
#define GNOME_IS_STOCK(obj)      GTK_CHECK_TYPE(obj, gnome_stock_get_type())
</MACRO>
<STRUCT>
<NAME>GnomeStock</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStockClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeStock</NAME>
struct GnomeStock {
	GnomePixmap pixmap;
	GnomePixmap *regular, *disabled, *focused; /* pixmap cache */
	GnomePixmap *current;
	char *icon;
	guint32 c_regular, c_disabled, c_focused;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_stock_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_new</NAME>
<RETURNS>GtkWidget     *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_new_with_icon</NAME>
<RETURNS>GtkWidget     *</RETURNS>
const char *icon
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_set_icon</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeStock *stock, const char *icon
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap</NAME>
<RETURNS>GnomePixmap            *</RETURNS>
GtkWidget *window,const char *icon,const char *subtype
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget</NAME>
<RETURNS>GtkWidget              *</RETURNS>
GtkWidget *window,const char *icon
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget_at_size</NAME>
<RETURNS>GtkWidget              *</RETURNS>
GtkWidget *window,const char *icon,guint width,guint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget_set_icon</NAME>
<RETURNS>void  </RETURNS>
GnomeStock *widget,const char *icon
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_widget_set_icon</NAME>
<RETURNS>void  </RETURNS>
GnomeStockPixmapWidget *widget,const char *icon
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_register</NAME>
<RETURNS>gint  </RETURNS>
const char *icon,const char *subtype,GnomeStockPixmapEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_change</NAME>
<RETURNS>gint  </RETURNS>
const char *icon,const char *subtype,GnomeStockPixmapEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_checkfor</NAME>
<RETURNS>GnomeStockPixmapEntry  *</RETURNS>
const char *icon,const char *subtype
</FUNCTION>
<FUNCTION>
<NAME>gnome_pixmap_button</NAME>
<RETURNS>GtkWidget             *</RETURNS>
GtkWidget *pixmap,const char *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_button_can_default</NAME>
<RETURNS>void 	</RETURNS>
GtkButton *button,gboolean can_default
</FUNCTION>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_OK</NAME>
#define GNOME_STOCK_BUTTON_OK     "Button_Ok"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_CANCEL</NAME>
#define GNOME_STOCK_BUTTON_CANCEL "Button_Cancel"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_YES</NAME>
#define GNOME_STOCK_BUTTON_YES    "Button_Yes"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_NO</NAME>
#define GNOME_STOCK_BUTTON_NO     "Button_No"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_CLOSE</NAME>
#define GNOME_STOCK_BUTTON_CLOSE  "Button_Close"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_APPLY</NAME>
#define GNOME_STOCK_BUTTON_APPLY  "Button_Apply"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_HELP</NAME>
#define GNOME_STOCK_BUTTON_HELP   "Button_Help"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_NEXT</NAME>
#define GNOME_STOCK_BUTTON_NEXT   "Button_Next"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_PREV</NAME>
#define GNOME_STOCK_BUTTON_PREV   "Button_Prev"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_UP</NAME>
#define GNOME_STOCK_BUTTON_UP     "Button_Up"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_DOWN</NAME>
#define GNOME_STOCK_BUTTON_DOWN   "Button_Down"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_BUTTON_FONT</NAME>
#define GNOME_STOCK_BUTTON_FONT   "Button_Font"
</MACRO>
<FUNCTION>
<NAME>gnome_stock_button</NAME>
<RETURNS>GtkWidget              *</RETURNS>
const char *type
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_or_ordinary_button</NAME>
<RETURNS>GtkWidget              *</RETURNS>
const char *type
</FUNCTION>
<MACRO>
<NAME>GNOME_STOCK_MENU_BLANK</NAME>
#define GNOME_STOCK_MENU_BLANK        "Menu_"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_NEW</NAME>
#define GNOME_STOCK_MENU_NEW          "Menu_New"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_SAVE</NAME>
#define GNOME_STOCK_MENU_SAVE         "Menu_Save"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_SAVE_AS</NAME>
#define GNOME_STOCK_MENU_SAVE_AS      "Menu_Save As"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_REVERT</NAME>
#define GNOME_STOCK_MENU_REVERT       "Menu_Revert"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_OPEN</NAME>
#define GNOME_STOCK_MENU_OPEN         "Menu_Open"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_CLOSE</NAME>
#define GNOME_STOCK_MENU_CLOSE        "Menu_Close"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_QUIT</NAME>
#define GNOME_STOCK_MENU_QUIT         "Menu_Quit"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_CUT</NAME>
#define GNOME_STOCK_MENU_CUT          "Menu_Cut"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_COPY</NAME>
#define GNOME_STOCK_MENU_COPY         "Menu_Copy"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_PASTE</NAME>
#define GNOME_STOCK_MENU_PASTE        "Menu_Paste"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_PROP</NAME>
#define GNOME_STOCK_MENU_PROP         "Menu_Properties"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_PREF</NAME>
#define GNOME_STOCK_MENU_PREF         "Menu_Preferences"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_ABOUT</NAME>
#define GNOME_STOCK_MENU_ABOUT        "Menu_About"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_SCORES</NAME>
#define GNOME_STOCK_MENU_SCORES       "Menu_Scores"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_UNDO</NAME>
#define GNOME_STOCK_MENU_UNDO         "Menu_Undo"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_REDO</NAME>
#define GNOME_STOCK_MENU_REDO         "Menu_Redo"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_PRINT</NAME>
#define GNOME_STOCK_MENU_PRINT        "Menu_Print"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_SEARCH</NAME>
#define GNOME_STOCK_MENU_SEARCH       "Menu_Search"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_SRCHRPL</NAME>
#define GNOME_STOCK_MENU_SRCHRPL      "Menu_Search/Replace"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BACK</NAME>
#define GNOME_STOCK_MENU_BACK         "Menu_Back"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_FORWARD</NAME>
#define GNOME_STOCK_MENU_FORWARD      "Menu_Forward"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_FIRST</NAME>
#define GNOME_STOCK_MENU_FIRST        "Menu_First"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_LAST</NAME>
#define GNOME_STOCK_MENU_LAST         "Menu_Last"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_HOME</NAME>
#define GNOME_STOCK_MENU_HOME         "Menu_Home"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_STOP</NAME>
#define GNOME_STOCK_MENU_STOP         "Menu_Stop"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_REFRESH</NAME>
#define GNOME_STOCK_MENU_REFRESH      "Menu_Refresh"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MAIL</NAME>
#define GNOME_STOCK_MENU_MAIL         "Menu_Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MAIL_RCV</NAME>
#define GNOME_STOCK_MENU_MAIL_RCV     "Menu_Receive Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MAIL_SND</NAME>
#define GNOME_STOCK_MENU_MAIL_SND     "Menu_Send Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MAIL_RPL</NAME>
#define GNOME_STOCK_MENU_MAIL_RPL     "Menu_Reply to Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MAIL_FWD</NAME>
#define GNOME_STOCK_MENU_MAIL_FWD     "Menu_Forward Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MAIL_NEW</NAME>
#define GNOME_STOCK_MENU_MAIL_NEW     "Menu_New Mail"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TRASH</NAME>
#define GNOME_STOCK_MENU_TRASH        "Menu_Trash"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TRASH_FULL</NAME>
#define GNOME_STOCK_MENU_TRASH_FULL   "Menu_Trash Full"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_UNDELETE</NAME>
#define GNOME_STOCK_MENU_UNDELETE     "Menu_Undelete"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TIMER</NAME>
#define GNOME_STOCK_MENU_TIMER        "Menu_Timer"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TIMER_STOP</NAME>
#define GNOME_STOCK_MENU_TIMER_STOP   "Menu_Timer Stopped"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_SPELLCHECK</NAME>
#define GNOME_STOCK_MENU_SPELLCHECK   "Menu_Spellchecker"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MIC</NAME>
#define GNOME_STOCK_MENU_MIC          "Menu_Microphone"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_LINE_IN</NAME>
#define GNOME_STOCK_MENU_LINE_IN      "Menu_Line In"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_CDROM</NAME>
#define GNOME_STOCK_MENU_CDROM	     "Menu_Cdrom"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_VOLUME</NAME>
#define GNOME_STOCK_MENU_VOLUME       "Menu_Volume"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_MIDI</NAME>
#define GNOME_STOCK_MENU_MIDI         "Menu_Midi"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BOOK_RED</NAME>
#define GNOME_STOCK_MENU_BOOK_RED     "Menu_Book Red"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BOOK_GREEN</NAME>
#define GNOME_STOCK_MENU_BOOK_GREEN   "Menu_Book Green"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BOOK_BLUE</NAME>
#define GNOME_STOCK_MENU_BOOK_BLUE    "Menu_Book Blue"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BOOK_YELLOW</NAME>
#define GNOME_STOCK_MENU_BOOK_YELLOW  "Menu_Book Yellow"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BOOK_OPEN</NAME>
#define GNOME_STOCK_MENU_BOOK_OPEN    "Menu_Book Open"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_CONVERT</NAME>
#define GNOME_STOCK_MENU_CONVERT      "Menu_Convert"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_JUMP_TO</NAME>
#define GNOME_STOCK_MENU_JUMP_TO      "Menu_Jump To"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_UP</NAME>
#define GNOME_STOCK_MENU_UP           "Menu_Up"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_DOWN</NAME>
#define GNOME_STOCK_MENU_DOWN         "Menu_Down"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TOP</NAME>
#define GNOME_STOCK_MENU_TOP          "Menu_Top"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_BOTTOM</NAME>
#define GNOME_STOCK_MENU_BOTTOM       "Menu_Bottom"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_ATTACH</NAME>
#define GNOME_STOCK_MENU_ATTACH       "Menu_Attach"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_INDEX</NAME>
#define GNOME_STOCK_MENU_INDEX        "Menu_Index"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_FONT</NAME>
#define GNOME_STOCK_MENU_FONT         "Menu_Font"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_EXEC</NAME>
#define GNOME_STOCK_MENU_EXEC         "Menu_Exec"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_ALIGN_LEFT</NAME>
#define GNOME_STOCK_MENU_ALIGN_LEFT     "Menu_Left"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_ALIGN_RIGHT</NAME>
#define GNOME_STOCK_MENU_ALIGN_RIGHT    "Menu_Right"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_ALIGN_CENTER</NAME>
#define GNOME_STOCK_MENU_ALIGN_CENTER   "Menu_Center"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_ALIGN_JUSTIFY</NAME>
#define GNOME_STOCK_MENU_ALIGN_JUSTIFY  "Menu_Justify"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TEXT_BOLD</NAME>
#define GNOME_STOCK_MENU_TEXT_BOLD      "Menu_Bold"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TEXT_ITALIC</NAME>
#define GNOME_STOCK_MENU_TEXT_ITALIC    "Menu_Italic"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TEXT_UNDERLINE</NAME>
#define GNOME_STOCK_MENU_TEXT_UNDERLINE "Menu_Underline"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_TEXT_STRIKEOUT</NAME>
#define GNOME_STOCK_MENU_TEXT_STRIKEOUT "Menu_Strikeout"
</MACRO>
<MACRO>
<NAME>GNOME_STOCK_MENU_EXIT</NAME>
#define GNOME_STOCK_MENU_EXIT     GNOME_STOCK_MENU_QUIT
</MACRO>
<FUNCTION>
<NAME>gnome_stock_menu_item</NAME>
<RETURNS>GtkWidget              *</RETURNS>
const char *type,const char *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_menu_accel</NAME>
<RETURNS>gboolean 	</RETURNS>
const char *type,guchar *key,guint8 *mod
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_menu_accel_parse</NAME>
<RETURNS>void  </RETURNS>
const char *section
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_transparent_window</NAME>
<RETURNS>GtkWidget  *</RETURNS>
const char *icon, const char *subtype
</FUNCTION>
<FUNCTION>
<NAME>gnome_stock_pixmap_gdk</NAME>
<RETURNS>void  </RETURNS>
const char *icon,const char *subtype,GdkPixmap **pixmap,GdkPixmap **mask
</FUNCTION>
<USER_FUNCTION>
<NAME>GnomeStringCallback</NAME>
<RETURNS>void </RETURNS>
gchar * string, gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GnomeReplyCallback</NAME>
<RETURNS>void </RETURNS>
gint reply, gpointer data
</USER_FUNCTION>
<ENUM>
<NAME>GnomePreferencesType</NAME>
typedef enum {
  GNOME_PREFERENCES_NEVER,
  GNOME_PREFERENCES_USER,
  GNOME_PREFERENCES_ALWAYS
} GnomePreferencesType;
</ENUM>
<MACRO>
<NAME>GNOME_PAD</NAME>
#define GNOME_PAD          8
</MACRO>
<MACRO>
<NAME>GNOME_PAD_SMALL</NAME>
#define GNOME_PAD_SMALL    4
</MACRO>
<MACRO>
<NAME>GNOME_PAD_BIG</NAME>
#define GNOME_PAD_BIG      12
</MACRO>
<MACRO>
<NAME>GNOME_YES</NAME>
#define GNOME_YES 0 
</MACRO>
<MACRO>
<NAME>GNOME_NO</NAME>
#define GNOME_NO 1 
</MACRO>
<MACRO>
<NAME>GNOME_OK</NAME>
#define GNOME_OK 0
</MACRO>
<MACRO>
<NAME>GNOME_CANCEL</NAME>
#define GNOME_CANCEL 1
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_EXIT</NAME>
#define GNOME_KEY_NAME_EXIT 	        'Q'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_EXIT</NAME>
#define GNOME_KEY_MOD_EXIT	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_CLOSE</NAME>
#define GNOME_KEY_NAME_CLOSE 	        'W'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_CLOSE</NAME>
#define	GNOME_KEY_MOD_CLOSE	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_CUT</NAME>
#define GNOME_KEY_NAME_CUT 	        'X'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_CUT</NAME>
#define GNOME_KEY_MOD_CUT 	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_COPY</NAME>
#define GNOME_KEY_NAME_COPY	        'C'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_COPY</NAME>
#define GNOME_KEY_MOD_COPY	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_PASTE</NAME>
#define GNOME_KEY_NAME_PASTE 	        'V'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_PASTE</NAME>
#define GNOME_KEY_MOD_PASTE 	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_SELECT_ALL</NAME>
#define GNOME_KEY_NAME_SELECT_ALL       0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_SELECT_ALL</NAME>
#define GNOME_KEY_MOD_SELECT_ALL        (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_CLEAR</NAME>
#define GNOME_KEY_NAME_CLEAR 	        0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_CLEAR</NAME>
#define GNOME_KEY_MOD_CLEAR 	        (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_UNDO</NAME>
#define GNOME_KEY_NAME_UNDO  	        'Z'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_UNDO</NAME>
#define GNOME_KEY_MOD_UNDO  	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_REDO</NAME>
#define GNOME_KEY_NAME_REDO	        'R'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_REDO</NAME>
#define GNOME_KEY_MOD_REDO	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_SAVE</NAME>
#define GNOME_KEY_NAME_SAVE	        'S'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_SAVE</NAME>
#define GNOME_KEY_MOD_SAVE	        (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_OPEN</NAME>
#define GNOME_KEY_NAME_OPEN	        GDK_F3
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_OPEN</NAME>
#define GNOME_KEY_MOD_OPEN	        (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_SAVE_AS</NAME>
#define GNOME_KEY_NAME_SAVE_AS	        0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_SAVE_AS</NAME>
#define GNOME_KEY_MOD_SAVE_AS           (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_NEW</NAME>
#define GNOME_KEY_NAME_NEW	        0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_NEW</NAME>
#define GNOME_KEY_MOD_NEW	        (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_PRINT</NAME>
#define GNOME_KEY_NAME_PRINT            0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_PRINT</NAME>
#define GNOME_KEY_MOD_PRINT             (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_PRINT_SETUP</NAME>
#define GNOME_KEY_NAME_PRINT_SETUP      0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_PRINT_SETUP</NAME>
#define GNOME_KEY_MOD_PRINT_SETUP       (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_FIND</NAME>
#define GNOME_KEY_NAME_FIND             GDK_F6
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_FIND</NAME>
#define GNOME_KEY_MOD_FIND              (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_FIND_AGAIN</NAME>
#define GNOME_KEY_NAME_FIND_AGAIN       GDK_F6
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_FIND_AGAIN</NAME>
#define GNOME_KEY_MOD_FIND_AGAIN        (GDK_SHIFT_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_REPLACE</NAME>
#define GNOME_KEY_NAME_REPLACE          GDK_F7
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_REPLACE</NAME>
#define GNOME_KEY_MOD_REPLACE           (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_NEW_WINDOW</NAME>
#define GNOME_KEY_NAME_NEW_WINDOW       0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_NEW_WINDOW</NAME>
#define GNOME_KEY_MOD_NEW_WINDOW        (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_CLOSE_WINDOW</NAME>
#define GNOME_KEY_NAME_CLOSE_WINDOW     0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_CLOSE_WINDOW</NAME>
#define GNOME_KEY_MOD_CLOSE_WINDOW      (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_REDO_MOVE</NAME>
#define GNOME_KEY_NAME_REDO_MOVE        'R'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_REDO_MOVE</NAME>
#define GNOME_KEY_MOD_REDO_MOVE         (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_UNDO_MOVE</NAME>
#define GNOME_KEY_NAME_UNDO_MOVE        'Z'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_UNDO_MOVE</NAME>
#define GNOME_KEY_MOD_UNDO_MOVE         (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_PAUSE_GAME</NAME>
#define GNOME_KEY_NAME_PAUSE_GAME       0
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_PAUSE_GAME</NAME>
#define GNOME_KEY_MOD_PAUSE_GAME        (0)
</MACRO>
<MACRO>
<NAME>GNOME_KEY_NAME_NEW_GAME</NAME>
#define GNOME_KEY_NAME_NEW_GAME         'N'
</MACRO>
<MACRO>
<NAME>GNOME_KEY_MOD_NEW_GAME</NAME>
#define GNOME_KEY_MOD_NEW_GAME          (GDK_CONTROL_MASK)
</MACRO>
<MACRO>
<NAME>XA_WIN_PROTOCOLS</NAME>
#define XA_WIN_PROTOCOLS           "_WIN_PROTOCOLS"
</MACRO>
<MACRO>
<NAME>XA_WIN_ICONS</NAME>
#define XA_WIN_ICONS               "_WIN_ICONS"
</MACRO>
<MACRO>
<NAME>XA_WIN_WORKSPACE</NAME>
#define XA_WIN_WORKSPACE           "_WIN_WORKSPACE"
</MACRO>
<MACRO>
<NAME>XA_WIN_WORKSPACE_COUNT</NAME>
#define XA_WIN_WORKSPACE_COUNT     "_WIN_WORKSPACE_COUNT"
</MACRO>
<MACRO>
<NAME>XA_WIN_WORKSPACE_NAMES</NAME>
#define XA_WIN_WORKSPACE_NAMES     "_WIN_WORKSPACE_NAMES"    
</MACRO>
<MACRO>
<NAME>XA_WIN_LAYER</NAME>
#define XA_WIN_LAYER               "_WIN_LAYER"
</MACRO>
<MACRO>
<NAME>XA_WIN_STATE</NAME>
#define XA_WIN_STATE               "_WIN_STATE"
</MACRO>
<MACRO>
<NAME>XA_WIN_HINTS</NAME>
#define XA_WIN_HINTS               "_WIN_HINTS"
</MACRO>
<MACRO>
<NAME>XA_WIN_WORKAREA</NAME>
#define XA_WIN_WORKAREA            "_WIN_WORKAREA"
</MACRO>
<MACRO>
<NAME>XA_WIN_CLIENT_LIST</NAME>
#define XA_WIN_CLIENT_LIST         "_WIN_CLIENT_LIST"
</MACRO>
<MACRO>
<NAME>XA_WIN_APP_STATE</NAME>
#define XA_WIN_APP_STATE           "_WIN_APP_STATE"
</MACRO>
<MACRO>
<NAME>XA_WIN_EXPANDED_SIZE</NAME>
#define XA_WIN_EXPANDED_SIZE       "_WIN_EXPANDED_SIZE"
</MACRO>
<MACRO>
<NAME>XA_WIN_CLIENT_MOVING</NAME>
#define XA_WIN_CLIENT_MOVING       "_WIN_CLIENT_MOVING"
</MACRO>
<MACRO>
<NAME>XA_WIN_SUPPORTING_WM_CHECK</NAME>
#define XA_WIN_SUPPORTING_WM_CHECK "_WIN_SUPPORTING_WM_CHECK"
</MACRO>
<ENUM>
<NAME>GnomeWinLayer</NAME>
typedef enum
{
  WIN_LAYER_DESKTOP     = 0,
  WIN_LAYER_BELOW       = 2,
  WIN_LAYER_NORMAL      = 4,
  WIN_LAYER_ONTOP       = 6,
  WIN_LAYER_DOCK        = 8,
  WIN_LAYER_ABOVE_DOCK  = 10
} GnomeWinLayer;
</ENUM>
<ENUM>
<NAME>GnomeWinState</NAME>
typedef enum
{
  WIN_STATE_STICKY          = (1<<0), /* everyone knows sticky */
  WIN_STATE_MINIMIZED       = (1<<1), /* ??? */
  WIN_STATE_MAXIMIZED_VERT  = (1<<2), /* window in maximized V state */
  WIN_STATE_MAXIMIZED_HORIZ = (1<<3), /* window in maximized H state */
  WIN_STATE_HIDDEN          = (1<<4), /* not on taskbar but window visible */
  WIN_STATE_SHADED          = (1<<5), /* shaded (NeXT style) */
  WIN_STATE_HID_WORKSPACE   = (1<<6), /* not on current desktop */
  WIN_STATE_HID_TRANSIENT   = (1<<7), /* owner of transient is hidden */
  WIN_STATE_FIXED_POSITION  = (1<<8), /* window is fixed in position even */
  WIN_STATE_ARRANGE_IGNORE  = (1<<9)  /* ignore for auto arranging */
} GnomeWinState;
</ENUM>
<ENUM>
<NAME>GnomeWinHints</NAME>
typedef enum
{
  WIN_HINTS_SKIP_FOCUS      = (1<<0), /* "alt-tab" skips this win */
  WIN_HINTS_SKIP_WINLIST    = (1<<1), /* not in win list */
  WIN_HINTS_SKIP_TASKBAR    = (1<<2), /* not on taskbar */
  WIN_HINTS_GROUP_TRANSIENT = (1<<3), /* ??????? */
  WIN_HINTS_FOCUS_ON_CLICK  = (1<<4), /* app only accepts focus when clicked */
  WIN_HINTS_DO_NOT_COVER    = (1<<5)  /* attempt to not cover this window */
} GnomeWinHints;
</ENUM>
<ENUM>
<NAME>GnomeWinAppState</NAME>
typedef enum
{
  WIN_APP_STATE_NONE,
  WIN_APP_STATE_ACTIVE1,
  WIN_APP_STATE_ACTIVE2,
  WIN_APP_STATE_ERROR1,
  WIN_APP_STATE_ERROR2,
  WIN_APP_STATE_FATAL_ERROR1,
  WIN_APP_STATE_FATAL_ERROR2,
  WIN_APP_STATE_IDLE1,
  WIN_APP_STATE_IDLE2,
  WIN_APP_STATE_WAITING1,
  WIN_APP_STATE_WAITING2,
  WIN_APP_STATE_WORKING1,
  WIN_APP_STATE_WORKING2,
  WIN_APP_STATE_NEED_USER_INPUT1,
  WIN_APP_STATE_NEED_USER_INPUT2,
  WIN_APP_STATE_STRUGGLING1,
  WIN_APP_STATE_STRUGGLING2,
  WIN_APP_STATE_DISK_TRAFFIC1,
  WIN_APP_STATE_DISK_TRAFFIC2,
  WIN_APP_STATE_NETWORK_TRAFFIC1,
  WIN_APP_STATE_NETWORK_TRAFFIC2,
  WIN_APP_STATE_OVERLOADED1,
  WIN_APP_STATE_OVERLOADED2,
  WIN_APP_STATE_PERCENT000_1,
  WIN_APP_STATE_PERCENT000_2,
  WIN_APP_STATE_PERCENT010_1,
  WIN_APP_STATE_PERCENT010_2,
  WIN_APP_STATE_PERCENT020_1,
  WIN_APP_STATE_PERCENT020_2,
  WIN_APP_STATE_PERCENT030_1,
  WIN_APP_STATE_PERCENT030_2,
  WIN_APP_STATE_PERCENT040_1,
  WIN_APP_STATE_PERCENT040_2,
  WIN_APP_STATE_PERCENT050_1,
  WIN_APP_STATE_PERCENT050_2,
  WIN_APP_STATE_PERCENT060_1,
  WIN_APP_STATE_PERCENT060_2,
  WIN_APP_STATE_PERCENT070_1,
  WIN_APP_STATE_PERCENT070_2,
  WIN_APP_STATE_PERCENT080_1,
  WIN_APP_STATE_PERCENT080_2,
  WIN_APP_STATE_PERCENT090_1,
  WIN_APP_STATE_PERCENT090_2,
  WIN_APP_STATE_PERCENT100_1,
  WIN_APP_STATE_PERCENT100_2
} GnomeWinAppState;
</ENUM>
<FUNCTION>
<NAME>gnome_win_hints_init</NAME>
<RETURNS>void</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_layer</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, GnomeWinLayer layer
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_layer</NAME>
<RETURNS>GnomeWinLayer</RETURNS>
GtkWidget *window
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_state</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, GnomeWinState state
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_state</NAME>
<RETURNS>GnomeWinState</RETURNS>
GtkWidget *window
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_hints</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, GnomeWinHints skip
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_hints</NAME>
<RETURNS>GnomeWinHints</RETURNS>
GtkWidget *window
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_workspace</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, gint workspace
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_workspace</NAME>
<RETURNS>gint</RETURNS>
GtkWidget *window
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_current_workspace</NAME>
<RETURNS>void</RETURNS>
gint workspace
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_current_workspace</NAME>
<RETURNS>gint</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_workspace_names</NAME>
<RETURNS>GList *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_workspace_count</NAME>
<RETURNS>gint</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_expanded_size</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, gint x, gint y, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_expanded_size</NAME>
<RETURNS>gboolean</RETURNS>
GtkWidget *window, gint *x, gint *y, gint *width, gint *height
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_moving</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, gboolean moving
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_app_state</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window,  GnomeWinAppState state
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_app_state</NAME>
<RETURNS>GnomeWinAppState</RETURNS>
GtkWidget *window
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_set_moving</NAME>
<RETURNS>void</RETURNS>
GtkWidget *window, gboolean moving
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_wm_exists</NAME>
<RETURNS>gboolean</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_win_hints_get_client_window_ids</NAME>
<RETURNS>GList *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_CLOCK</NAME>
#define GTK_CLOCK(obj) GTK_CHECK_CAST(obj, gtk_clock_get_type(), GtkClock)
</MACRO>
<MACRO>
<NAME>GTK_CLOCK_CLASS</NAME>
#define GTK_CLOCK_CLASS(class) GTK_CHECK_CAST_CLASS(class, gtk_clock_get_type(), GtkClockClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_CLOCK</NAME>
#define GTK_IS_CLOCK(obj) GTK_CHECK_TYPE(obj, gtk_clock_get_type())
</MACRO>
<STRUCT>
<NAME>GtkClock</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkClockClass</NAME>
</STRUCT>
<ENUM>
<NAME>GtkClockType</NAME>
typedef enum
{
	GTK_CLOCK_INCREASING,
	GTK_CLOCK_DECREASING,
	GTK_CLOCK_REALTIME
} GtkClockType;
</ENUM>
<STRUCT>
<NAME>GtkClock</NAME>
struct GtkClock {
	GtkLabel widget;
	GtkClockType type;
	gint timer_id;
	gint update_interval;
	time_t seconds;
	time_t stopped;
	gchar *fmt;
	struct tm *tm;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_clock_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_clock_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
GtkClockType type
</FUNCTION>
<FUNCTION>
<NAME>gtk_clock_set_format</NAME>
<RETURNS>void  </RETURNS>
GtkClock *gclock, gchar *fmt
</FUNCTION>
<FUNCTION>
<NAME>gtk_clock_set_seconds</NAME>
<RETURNS>void  </RETURNS>
GtkClock *gclock, time_t seconds
</FUNCTION>
<FUNCTION>
<NAME>gtk_clock_set_update_interval</NAME>
<RETURNS>void  </RETURNS>
GtkClock *gclock, gint seconds
</FUNCTION>
<FUNCTION>
<NAME>gtk_clock_start</NAME>
<RETURNS>void  </RETURNS>
GtkClock *gclock
</FUNCTION>
<FUNCTION>
<NAME>gtk_clock_stop</NAME>
<RETURNS>void  </RETURNS>
GtkClock *gclock
</FUNCTION>
<MACRO>
<NAME>GTK_TED</NAME>
#define GTK_TED(obj)          GTK_CHECK_CAST (obj, gtk_ted_get_type (), GtkTed)
</MACRO>
<MACRO>
<NAME>GTK_TED_CLASS</NAME>
#define GTK_TED_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_ted_get_type (), GtkTedClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_TED</NAME>
#define GTK_IS_TED(obj)       GTK_CHECK_TYPE (obj, gtk_ted_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkTed</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkTedClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>gtk_ted_get_type</NAME>
<RETURNS>guint 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_ted_set_app_name</NAME>
<RETURNS>void  </RETURNS>
char *str
</FUNCTION>
<FUNCTION>
<NAME>gtk_ted_prepare</NAME>
<RETURNS>void  </RETURNS>
GtkTed *ted
</FUNCTION>
<FUNCTION>
<NAME>gtk_ted_new</NAME>
<RETURNS>GtkWidget          *</RETURNS>
char *dialog_name
</FUNCTION>
<FUNCTION>
<NAME>gtk_ted_new_layout</NAME>
<RETURNS>GtkWidget          *</RETURNS>
char *dialog_name, char *layout
</FUNCTION>
<FUNCTION>
<NAME>gtk_ted_add</NAME>
<RETURNS>void  </RETURNS>
GtkTed *ted, GtkWidget *widget, char *name
</FUNCTION>
<STRUCT>
<NAME>GtkTed</NAME>
struct GtkTed
{
	GtkTable   table;

	GHashTable *widgets;
	GtkWidget  *widget_box;
	int        last_col, last_row;
	int        top_col,  top_row;
	char       *dialog_name;
	int        need_gui;
	int        in_gui;
};
</STRUCT>
<MACRO>
<NAME>GTK_CAULDRON_TOPLEVEL</NAME>
#define GTK_CAULDRON_TOPLEVEL	(0x1L<<0)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_DIALOG</NAME>
#define GTK_CAULDRON_DIALOG		(0x1L<<1)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_POPUP</NAME>
#define GTK_CAULDRON_POPUP		(0x1L<<2)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE_SHIFT</NAME>
#define GTK_CAULDRON_SPACE_SHIFT	(3)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE_MASK</NAME>
#define GTK_CAULDRON_SPACE_MASK	(0xFL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE1</NAME>
#define GTK_CAULDRON_SPACE1		(0x1L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE2</NAME>
#define GTK_CAULDRON_SPACE2		(0x2L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE3</NAME>
#define GTK_CAULDRON_SPACE3		(0x3L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE4</NAME>
#define GTK_CAULDRON_SPACE4		(0x4L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE5</NAME>
#define GTK_CAULDRON_SPACE5		(0x5L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE6</NAME>
#define GTK_CAULDRON_SPACE6		(0x6L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE7</NAME>
#define GTK_CAULDRON_SPACE7		(0x7L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE8</NAME>
#define GTK_CAULDRON_SPACE8		(0x8L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE9</NAME>
#define GTK_CAULDRON_SPACE9		(0x9L<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE10</NAME>
#define GTK_CAULDRON_SPACE10		(0xAL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE11</NAME>
#define GTK_CAULDRON_SPACE11		(0xBL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE12</NAME>
#define GTK_CAULDRON_SPACE12		(0xCL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE13</NAME>
#define GTK_CAULDRON_SPACE13		(0xDL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE14</NAME>
#define GTK_CAULDRON_SPACE14		(0xEL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_SPACE15</NAME>
#define GTK_CAULDRON_SPACE15		(0xFL<<GTK_CAULDRON_SPACE_SHIFT)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_IGNOREESCAPE</NAME>
#define GTK_CAULDRON_IGNOREESCAPE	(0x1L<<7)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_IGNOREENTER</NAME>
#define GTK_CAULDRON_IGNOREENTER	(0x1L<<8)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_GRAB</NAME>
#define GTK_CAULDRON_GRAB		(0x1L<<9)
</MACRO>
<MACRO>
<NAME>GTK_CAULDRON_PARENT</NAME>
#define GTK_CAULDRON_PARENT		(0x1L<<10)
</MACRO>
<USER_FUNCTION>
<NAME>GtkCauldronNextArgCallback</NAME>
<RETURNS>void </RETURNS>
gint cauldron_type, gpointer user_data, void *result
</USER_FUNCTION>
<VARIABLE>
<NAME>GTK_CAULDRON_ENTER</NAME>
extern gchar *GTK_CAULDRON_ENTER;
</VARIABLE>
<VARIABLE>
<NAME>GTK_CAULDRON_ESCAPE</NAME>
extern gchar *GTK_CAULDRON_ESCAPE;
</VARIABLE>
<USER_FUNCTION>
<NAME>GtkCauldronCustomCallback</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkWidget * widget, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gtk_dialog_cauldron</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar * title, glong options, ...
</FUNCTION>
<FUNCTION>
<NAME>gtk_dialog_cauldron_parse</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar * title, glong options,const gchar * format,GtkCauldronNextArgCallback next_arg,gpointer user_data,GtkWidget *parent
</FUNCTION>
<MACRO>
<NAME>GTK_DIAL</NAME>
#define GTK_DIAL(obj)          GTK_CHECK_CAST (obj, gtk_dial_get_type (), GtkDial)
</MACRO>
<MACRO>
<NAME>GTK_DIAL_CLASS</NAME>
#define GTK_DIAL_CLASS(klass)  GTK_CHECK_CLASS_CAST (klass, gtk_dial_get_type (), GtkDialClass)
</MACRO>
<MACRO>
<NAME>GTK_IS_DIAL</NAME>
#define GTK_IS_DIAL(obj)       GTK_CHECK_TYPE (obj, gtk_dial_get_type ())
</MACRO>
<STRUCT>
<NAME>GtkDial</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDialClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkDial</NAME>
struct GtkDial
{
  GtkWidget     widget;
  GdkPixmap     *offscreen_pixmap;
  GtkAdjustment *adjustment;

  guint policy : 2;
  guint view_only : 1;
  guint8 button;

  /* Dimensions of dial components */
  gint radius;
  gint pointer_width;

  guint32 timer;

  gfloat angle;
  gfloat percentage;
  gfloat old_value;
  gfloat old_lower;
  gfloat old_upper;

};
</STRUCT>
<FUNCTION>
<NAME>gtk_dial_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
GtkAdjustment  *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_get_type</NAME>
<RETURNS>guint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_get_adjustment</NAME>
<RETURNS>GtkAdjustment *</RETURNS>
GtkDial        *dial
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_set_update_policy</NAME>
<RETURNS>void  </RETURNS>
GtkDial        *dial,GtkUpdateType  policy
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_set_adjustment</NAME>
<RETURNS>void  </RETURNS>
GtkDial        *dial,GtkAdjustment  *adjustment
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_set_percentage</NAME>
<RETURNS>gfloat  </RETURNS>
GtkDial        *dial,gfloat         percent
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_get_percentage</NAME>
<RETURNS>gfloat  </RETURNS>
GtkDial        *dial
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_set_value</NAME>
<RETURNS>gfloat  </RETURNS>
GtkDial        *dial,gfloat         value
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_get_value</NAME>
<RETURNS>gfloat  </RETURNS>
GtkDial        *dial
</FUNCTION>
<FUNCTION>
<NAME>gtk_dial_set_view_only</NAME>
<RETURNS>void  </RETURNS>
GtkDial        *dial,gboolean       view_only
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_PIXMAP_MENU_ITEM</NAME>
#define GTK_TYPE_PIXMAP_MENU_ITEM	    (gtk_pixmap_menu_item_get_type ())
</MACRO>
<MACRO>
<NAME>GTK_PIXMAP_MENU_ITEM</NAME>
#define GTK_PIXMAP_MENU_ITEM(obj)	    (GTK_CHECK_CAST ((obj), GTK_TYPE_PIXMAP_MENU_ITEM, GtkPixmapMenuItem))
</MACRO>
<MACRO>
<NAME>GTK_PIXMAP_MENU_ITEM_CLASS</NAME>
#define GTK_PIXMAP_MENU_ITEM_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_PIXMAP_MENU_ITEM, GtkPixmapMenuItemClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_PIXMAP_MENU_ITEM</NAME>
#define GTK_IS_PIXMAP_MENU_ITEM(obj)	    (GTK_CHECK_TYPE ((obj), GTK_TYPE_PIXMAP_MENU_ITEM))
</MACRO>
<MACRO>
<NAME>GTK_IS_PIXMAP_MENU_ITEM_CLASS</NAME>
#define GTK_IS_PIXMAP_MENU_ITEM_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_PIXMAP_MENU_ITEM))
</MACRO>
<STRUCT>
<NAME>GtkPixmapMenuItem</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPixmapMenuItemClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GtkPixmapMenuItem</NAME>
struct GtkPixmapMenuItem
{
  GtkMenuItem menu_item;

  GtkWidget *pixmap;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_pixmap_menu_item_get_type</NAME>
<RETURNS>GtkType 	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_pixmap_menu_item_new</NAME>
<RETURNS>GtkWidget *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_pixmap_menu_item_set_pixmap</NAME>
<RETURNS>void  </RETURNS>
GtkPixmapMenuItem *menu_item,GtkWidget *pixmap
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_DRUID_PAGE_FINISH</NAME>
#define GNOME_TYPE_DRUID_PAGE_FINISH			(gnome_druid_page_finish_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_FINISH</NAME>
#define GNOME_DRUID_PAGE_FINISH(obj)			(GTK_CHECK_CAST ((obj), GNOME_TYPE_DRUID_PAGE_FINISH, GnomeDruidPageFinish))
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_FINISH_CLASS</NAME>
#define GNOME_DRUID_PAGE_FINISH_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_DRUID_PAGE_FINISH, GnomeDruidPageFinishClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_FINISH</NAME>
#define GNOME_IS_DRUID_PAGE_FINISH(obj)			(GTK_CHECK_TYPE ((obj), GNOME_TYPE_DRUID_PAGE_FINISH))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_FINISH_CLASS</NAME>
#define GNOME_IS_DRUID_PAGE_FINISH_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), GNOME_TYPE_DRUID_PAGE_FINISH))
</MACRO>
<STRUCT>
<NAME>GnomeDruidPageFinish</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageFinishClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageFinish</NAME>
struct GnomeDruidPageFinish
{
	GnomeDruidPage parent;

	GdkColor background_color;
	GdkColor textbox_color;
	GdkColor logo_background_color;
	GdkColor title_color;
	GdkColor text_color;

	gchar *title;
	gchar *text;
	GdkImlibImage *logo_image;
	GdkImlibImage *watermark_image;

	/*< private >*/
	GtkWidget *canvas;
	GnomeCanvasItem *background_item;
	GnomeCanvasItem *textbox_item;
	GnomeCanvasItem *text_item;
	GnomeCanvasItem *logo_item;
	GnomeCanvasItem *logoframe_item;
	GnomeCanvasItem *watermark_item;
	GnomeCanvasItem *title_item;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_druid_page_finish_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_new_with_vals</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gchar *title,gchar* text,GdkImlibImage *logo,GdkImlibImage *watermark
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_bg_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_textbox_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_logo_bg_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_title_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_text_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_text</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,gchar *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,gchar *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_logo</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkImlibImage *logo_image
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish_set_watermark</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageFinish *druid_page_finish,GdkImlibImage *watermark
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_DRUID_PAGE_STANDARD</NAME>
#define GNOME_TYPE_DRUID_PAGE_STANDARD			(gnome_druid_page_standard_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_STANDARD</NAME>
#define GNOME_DRUID_PAGE_STANDARD(obj)			(GTK_CHECK_CAST ((obj), GNOME_TYPE_DRUID_PAGE_STANDARD, GnomeDruidPageStandard))
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_STANDARD_CLASS</NAME>
#define GNOME_DRUID_PAGE_STANDARD_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_DRUID_PAGE_STANDARD, GnomeDruidPageStandardClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_STANDARD</NAME>
#define GNOME_IS_DRUID_PAGE_STANDARD(obj)			(GTK_CHECK_TYPE ((obj), GNOME_TYPE_DRUID_PAGE_STANDARD))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_STANDARD_CLASS</NAME>
#define GNOME_IS_DRUID_PAGE_STANDARD_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), GNOME_TYPE_DRUID_PAGE_STANDARD))
</MACRO>
<STRUCT>
<NAME>GnomeDruidPageStandard</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageStandardClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageStandard</NAME>
struct GnomeDruidPageStandard
{
	GnomeDruidPage parent;

	GtkWidget *vbox;
	GdkColor background_color;
	GdkColor logo_background_color;
	GdkColor title_color;
	GdkImlibImage *logo_image;

	gchar *title;
	
	/*< private >*/
	GtkWidget *canvas;
	GtkWidget *side_bar;
	GnomeCanvasItem *logoframe_item;
	GnomeCanvasItem *logo_item;
	GnomeCanvasItem *title_item;
	GnomeCanvasItem *background_item;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_druid_page_standard_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_new_with_vals</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gchar *title, GdkImlibImage *logo
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_set_bg_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStandard *druid_page_standard,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_set_logo_bg_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStandard *druid_page_standard,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_set_title_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStandard *druid_page_standard,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStandard *druid_page_standard,gchar *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_standard_set_logo</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStandard *druid_page_standard,GdkImlibImage *logo_image
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_DRUID_PAGE_START</NAME>
#define GNOME_TYPE_DRUID_PAGE_START			(gnome_druid_page_start_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_START</NAME>
#define GNOME_DRUID_PAGE_START(obj)			(GTK_CHECK_CAST ((obj), GNOME_TYPE_DRUID_PAGE_START, GnomeDruidPageStart))
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_START_CLASS</NAME>
#define GNOME_DRUID_PAGE_START_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_DRUID_PAGE_START, GnomeDruidPageStartClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_START</NAME>
#define GNOME_IS_DRUID_PAGE_START(obj)			(GTK_CHECK_TYPE ((obj), GNOME_TYPE_DRUID_PAGE_START))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_START_CLASS</NAME>
#define GNOME_IS_DRUID_PAGE_START_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), GNOME_TYPE_DRUID_PAGE_START))
</MACRO>
<STRUCT>
<NAME>GnomeDruidPageStart</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageStartClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageStart</NAME>
struct GnomeDruidPageStart
{
	GnomeDruidPage parent;

	GdkColor background_color;
	GdkColor textbox_color;
	GdkColor logo_background_color;
	GdkColor title_color;
	GdkColor text_color;

	gchar *title;
	gchar *text;
	GdkImlibImage *logo_image;
	GdkImlibImage *watermark_image;

	/*< private >*/
	GtkWidget *canvas;
	GnomeCanvasItem *background_item;
	GnomeCanvasItem *textbox_item;
	GnomeCanvasItem *text_item;
	GnomeCanvasItem *logo_item;
	GnomeCanvasItem *logoframe_item;
	GnomeCanvasItem *watermark_item;
	GnomeCanvasItem *title_item;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_druid_page_start_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_new_with_vals</NAME>
<RETURNS>GtkWidget  *</RETURNS>
gchar *title,gchar* text,GdkImlibImage *logo,GdkImlibImage *watermark
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_bg_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_textbox_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_logo_bg_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_title_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_text_color</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkColor *color
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_text</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,gchar *text
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_title</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,gchar *title
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_logo</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkImlibImage *logo_image
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_start_set_watermark</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPageStart *druid_page_start,GdkImlibImage *watermark
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_DRUID_PAGE</NAME>
#define GNOME_TYPE_DRUID_PAGE			(gnome_druid_page_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE</NAME>
#define GNOME_DRUID_PAGE(obj)			(GTK_CHECK_CAST ((obj), GNOME_TYPE_DRUID_PAGE, GnomeDruidPage))
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_PAGE_CLASS</NAME>
#define GNOME_DRUID_PAGE_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_DRUID_PAGE, GnomeDruidPageClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE</NAME>
#define GNOME_IS_DRUID_PAGE(obj)		(GTK_CHECK_TYPE ((obj), GNOME_TYPE_DRUID_PAGE))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_PAGE_CLASS</NAME>
#define GNOME_IS_DRUID_PAGE_CLASS(klass)	(GTK_CHECK_CLASS_TYPE ((obj), GNOME_TYPE_DRUID_PAGE))
</MACRO>
<STRUCT>
<NAME>GnomeDruidPage</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidPage</NAME>
struct GnomeDruidPage
{
	GtkBin parent;
};
</STRUCT>
<FUNCTION>
<NAME>gnome_druid_page_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_next</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDruidPage *druid_page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_prepare</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPage *druid_page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_back</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDruidPage *druid_page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_cancel</NAME>
<RETURNS>gboolean  </RETURNS>
GnomeDruidPage *druid_page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_page_finish</NAME>
<RETURNS>void  </RETURNS>
GnomeDruidPage *druid_page
</FUNCTION>
<MACRO>
<NAME>GNOME_TYPE_DRUID</NAME>
#define GNOME_TYPE_DRUID			(gnome_druid_get_type ())
</MACRO>
<MACRO>
<NAME>GNOME_DRUID</NAME>
#define GNOME_DRUID(obj)			(GTK_CHECK_CAST ((obj), GNOME_TYPE_DRUID, GnomeDruid))
</MACRO>
<MACRO>
<NAME>GNOME_DRUID_CLASS</NAME>
#define GNOME_DRUID_CLASS(klass)		(GTK_CHECK_CLASS_CAST ((klass), GNOME_TYPE_DRUID, GnomeDruidClass))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID</NAME>
#define GNOME_IS_DRUID(obj)			(GTK_CHECK_TYPE ((obj), GNOME_TYPE_DRUID))
</MACRO>
<MACRO>
<NAME>GNOME_IS_DRUID_CLASS</NAME>
#define GNOME_IS_DRUID_CLASS(klass)		(GTK_CHECK_CLASS_TYPE ((obj), GNOME_TYPE_DRUID))
</MACRO>
<STRUCT>
<NAME>GnomeDruid</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruidClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GnomeDruid</NAME>
struct GnomeDruid
{
	GtkContainer parent;
	GtkWidget *back;
	GtkWidget *next;
	GtkWidget *cancel;
	GtkWidget *finish;

	/*< private >*/
	GnomeDruidPage *current;
	GList *children;
	gboolean show_finish; /* if TRUE, then we are showing the finish button instead of the next button */
};
</STRUCT>
<FUNCTION>
<NAME>gnome_druid_get_type</NAME>
<RETURNS>GtkType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_new</NAME>
<RETURNS>GtkWidget  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_set_buttons_sensitive</NAME>
<RETURNS>void 	</RETURNS>
GnomeDruid *druid,gboolean back_sensitive,gboolean next_sensitive,gboolean cancel_sensitive
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_set_show_finish</NAME>
<RETURNS>void 	</RETURNS>
GnomeDruid *druid, gboolean show_finish
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_prepend_page</NAME>
<RETURNS>void  </RETURNS>
GnomeDruid *druid, GnomeDruidPage *page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_insert_page</NAME>
<RETURNS>void  </RETURNS>
GnomeDruid *druid, GnomeDruidPage *back_page, GnomeDruidPage *page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_append_page</NAME>
<RETURNS>void  </RETURNS>
GnomeDruid *druid, GnomeDruidPage *page
</FUNCTION>
<FUNCTION>
<NAME>gnome_druid_set_page</NAME>
<RETURNS>void 	</RETURNS>
GnomeDruid *druid, GnomeDruidPage *page
</FUNCTION>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_ANIMATOR_STATUS</NAME>
extern GtkType GTK_TYPE_GNOME_ANIMATOR_STATUS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_ANIMATOR_LOOP_TYPE</NAME>
extern GtkType GTK_TYPE_GNOME_ANIMATOR_LOOP_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_UI_INFO_TYPE</NAME>
extern GtkType GTK_TYPE_GNOME_UI_INFO_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_UI_INFO_CONFIGURABLE_TYPES</NAME>
extern GtkType GTK_TYPE_GNOME_UI_INFO_CONFIGURABLE_TYPES;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_UI_PIXMAP_TYPE</NAME>
extern GtkType GTK_TYPE_GNOME_UI_PIXMAP_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_CALCULATOR_MODE</NAME>
extern GtkType GTK_TYPE_GNOME_CALCULATOR_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_INTERACT_STYLE</NAME>
extern GtkType GTK_TYPE_GNOME_INTERACT_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_DIALOG_TYPE</NAME>
extern GtkType GTK_TYPE_GNOME_DIALOG_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_SAVE_STYLE</NAME>
extern GtkType GTK_TYPE_GNOME_SAVE_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_RESTART_STYLE</NAME>
extern GtkType GTK_TYPE_GNOME_RESTART_STYLE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_CLIENT_STATE</NAME>
extern GtkType GTK_TYPE_GNOME_CLIENT_STATE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_CLIENT_FLAGS</NAME>
extern GtkType GTK_TYPE_GNOME_CLIENT_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_DATE_EDIT_FLAGS</NAME>
extern GtkType GTK_TYPE_GNOME_DATE_EDIT_FLAGS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_DOCK_PLACEMENT</NAME>
extern GtkType GTK_TYPE_GNOME_DOCK_PLACEMENT;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_DOCK_ITEM_BEHAVIOR</NAME>
extern GtkType GTK_TYPE_GNOME_DOCK_ITEM_BEHAVIOR;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_FONT_PICKER_MODE</NAME>
extern GtkType GTK_TYPE_GNOME_FONT_PICKER_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_ICON_LIST_MODE</NAME>
extern GtkType GTK_TYPE_GNOME_ICON_LIST_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_MDI_MODE</NAME>
extern GtkType GTK_TYPE_GNOME_MDI_MODE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_PROPERTY_ACTION</NAME>
extern GtkType GTK_TYPE_GNOME_PROPERTY_ACTION;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_STOCK_PIXMAP_TYPE</NAME>
extern GtkType GTK_TYPE_GNOME_STOCK_PIXMAP_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_PREFERENCES_TYPE</NAME>
extern GtkType GTK_TYPE_GNOME_PREFERENCES_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_WIN_LAYER</NAME>
extern GtkType GTK_TYPE_GNOME_WIN_LAYER;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_WIN_STATE</NAME>
extern GtkType GTK_TYPE_GNOME_WIN_STATE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_WIN_HINTS</NAME>
extern GtkType GTK_TYPE_GNOME_WIN_HINTS;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_WIN_APP_STATE</NAME>
extern GtkType GTK_TYPE_GNOME_WIN_APP_STATE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_CLOCK_TYPE</NAME>
extern GtkType GTK_TYPE_CLOCK_TYPE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GDK_IMLIB_IMAGE</NAME>
extern GtkType GTK_TYPE_GDK_IMLIB_IMAGE;
</VARIABLE>
<VARIABLE>
<NAME>GTK_TYPE_GNOME_CANVAS_POINTS</NAME>
extern GtkType GTK_TYPE_GNOME_CANVAS_POINTS;
</VARIABLE>
<MACRO>
<NAME>GNOME_TYPE_NUM_BUILTINS</NAME>
#define	GNOME_TYPE_NUM_BUILTINS	(28)
</MACRO>
