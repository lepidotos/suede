/*
 * This file was generated by orbit-idl - DO NOT EDIT!
 */

#include <string.h>
#include "Table.h"

#if ( (TC_IMPL_TC_GNOME_Table_0 == 'T') \
&& (TC_IMPL_TC_GNOME_Table_1 == 'a') \
&& (TC_IMPL_TC_GNOME_Table_2 == 'b') \
&& (TC_IMPL_TC_GNOME_Table_3 == 'l') \
&& (TC_IMPL_TC_GNOME_Table_4 == 'e') \
) && !defined(TC_DEF_TC_GNOME_Table)
#define TC_DEF_TC_GNOME_Table 1
const struct CORBA_TypeCode_struct TC_GNOME_Table_struct = {
   {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
    ORBIT_PSEUDO_TYPECODE},
   CORBA_tk_objref, "Table", "IDL:GNOME/Table:1.0",
   0, 0,
   NULL,
   NULL,
   NULL,
   CORBA_OBJECT_NIL, 0, -1, 0, 0
};
#endif
#if ( (TC_IMPL_TC_GNOME_Table_Value_0 == 'T') \
&& (TC_IMPL_TC_GNOME_Table_Value_1 == 'a') \
&& (TC_IMPL_TC_GNOME_Table_Value_2 == 'b') \
&& (TC_IMPL_TC_GNOME_Table_Value_3 == 'l') \
&& (TC_IMPL_TC_GNOME_Table_Value_4 == 'e') \
) && !defined(TC_DEF_TC_GNOME_Table_Value)
#define TC_DEF_TC_GNOME_Table_Value 1
static const CORBA_short anon_sublabel_values_array8[] = { 2, 0 };
static const char *anon_subnames_array5[] = { "v_float", "str" };
static const CORBA_TypeCode anon_subtypes_array6[] =
   { (CORBA_TypeCode) & TC_CORBA_double_struct,
(CORBA_TypeCode) & TC_CORBA_string_struct };
static const CORBA_any anon_sublabels_array7[] =
   { {(CORBA_TypeCode) & TC_CORBA_short_struct,
      (gpointer) & anon_sublabel_values_array8[0], CORBA_FALSE},
   {(CORBA_TypeCode) & TC_CORBA_short_struct,
    (gpointer) & anon_sublabel_values_array8[1], CORBA_FALSE} };
const struct CORBA_TypeCode_struct TC_GNOME_Table_Value_struct = {
   {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
    ORBIT_PSEUDO_TYPECODE},
   CORBA_tk_union, "Value", "IDL:GNOME/Table/Value:1.0",
   0, 2,
   (const char **) anon_subnames_array5,
   (CORBA_TypeCode *) anon_subtypes_array6,
   (CORBA_any *) anon_sublabels_array7,
   (CORBA_TypeCode) & TC_CORBA_short_struct, 0, -1, 0, 0
};
#endif
#if ( (TC_IMPL_TC_GNOME_Table_OutOfRange_0 == 'T') \
&& (TC_IMPL_TC_GNOME_Table_OutOfRange_1 == 'a') \
&& (TC_IMPL_TC_GNOME_Table_OutOfRange_2 == 'b') \
&& (TC_IMPL_TC_GNOME_Table_OutOfRange_3 == 'l') \
&& (TC_IMPL_TC_GNOME_Table_OutOfRange_4 == 'e') \
) && !defined(TC_DEF_TC_GNOME_Table_OutOfRange)
#define TC_DEF_TC_GNOME_Table_OutOfRange 1
const struct CORBA_TypeCode_struct TC_GNOME_Table_OutOfRange_struct = {
   {{(ORBit_RootObject_Interface *) & ORBit_TypeCode_epv, TRUE, -1},
    ORBIT_PSEUDO_TYPECODE},
   CORBA_tk_except, "OutOfRange", "IDL:GNOME/Table/OutOfRange:1.0",
   0, 0,
   NULL,
   NULL,
   NULL,
   CORBA_OBJECT_NIL, 0, -1, 0, 0
};
#endif
gpointer
GNOME_Table_Value__free(gpointer mem, gpointer dat,
			CORBA_boolean free_strings)
{
   GNOME_Table_Value *val = mem;

   switch (val->_d) {
     case 2:
	break;
     case 0:
	CORBA_string__free(&(val->_u.str), NULL, free_strings);
	break;
     default:
	break;
   }
   return (gpointer) (val + 1);
}

GNOME_Table_Value *
GNOME_Table_Value__alloc(void)
{
   GNOME_Table_Value *retval;

   retval =
      ORBit_alloc(sizeof(GNOME_Table_Value),
		  (ORBit_free_childvals) GNOME_Table_Value__free,
		  GUINT_TO_POINTER(1));
   memset(retval, '\0', sizeof(GNOME_Table_Value));
   return retval;
}

gpointer
GNOME_Table_OutOfRange__free(gpointer mem, gpointer dat,
			     CORBA_boolean free_strings)
{
   GNOME_Table_OutOfRange *var = mem;

   return (gpointer) (var + 1);
}

CORBA_unsigned_long GNOME_Table__classid = 0;
